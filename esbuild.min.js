var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/util/iteratorProxy.js
var require_iteratorProxy = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next2() {
          if (index < values.length) {
            var value = values[index];
            index = index + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = exports.default = iteratorProxy;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/util/iterationDecorator.js
var require_iterationDecorator = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/ariaPropsMap.js
var require_ariaPropsMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r2, a) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
        var t = {}.toString.call(r2).slice(8, -1);
        return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a) {
      (null == a || a > r2.length) && (a = r2.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l) {
      var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t) {
        var e2, n2, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r2)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l); f = true) ;
        } catch (r3) {
          o = true, n2 = r3;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var properties = [["aria-activedescendant", {
      "type": "id"
    }], ["aria-atomic", {
      "type": "boolean"
    }], ["aria-autocomplete", {
      "type": "token",
      "values": ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      "type": "string"
    }], ["aria-brailleroledescription", {
      "type": "string"
    }], ["aria-busy", {
      "type": "boolean"
    }], ["aria-checked", {
      "type": "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      "type": "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", true, false]
    }], ["aria-describedby", {
      "type": "idlist"
    }], ["aria-description", {
      "type": "string"
    }], ["aria-details", {
      "type": "id"
    }], ["aria-disabled", {
      "type": "boolean"
    }], ["aria-dropeffect", {
      "type": "tokenlist",
      "values": ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      "type": "id"
    }], ["aria-expanded", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-flowto", {
      "type": "idlist"
    }], ["aria-grabbed", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-haspopup", {
      "type": "token",
      "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-invalid", {
      "type": "token",
      "values": ["grammar", false, "spelling", true]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      "type": "string"
    }], ["aria-labelledby", {
      "type": "idlist"
    }], ["aria-level", {
      "type": "integer"
    }], ["aria-live", {
      "type": "token",
      "values": ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      "type": "boolean"
    }], ["aria-multiselectable", {
      "type": "boolean"
    }], ["aria-orientation", {
      "type": "token",
      "values": ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      "type": "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      "type": "integer"
    }], ["aria-pressed", {
      "type": "tristate"
    }], ["aria-readonly", {
      "type": "boolean"
    }], ["aria-relevant", {
      "type": "tokenlist",
      "values": ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      "type": "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-setsize", {
      "type": "integer"
    }], ["aria-sort", {
      "type": "token",
      "values": ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      "type": "number"
    }], ["aria-valuemin", {
      "type": "number"
    }], ["aria-valuenow", {
      "type": "number"
    }], ["aria-valuetext", {
      "type": "string"
    }]];
    var ariaPropsMap = {
      entries: function entries() {
        return properties;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _properties = properties; _i < _properties.length; _i++) {
          var _properties$_i = _slicedToArray(_properties[_i], 2), key2 = _properties$_i[0], values = _properties$_i[1];
          fn.call(thisArg, values, key2, properties);
        }
      },
      get: function get3(key2) {
        var item = properties.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!ariaPropsMap.get(key2);
      },
      keys: function keys() {
        return properties.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return properties.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/domMap.js
var require_domMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/domMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r2, a) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
        var t = {}.toString.call(r2).slice(8, -1);
        return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a) {
      (null == a || a > r2.length) && (a = r2.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l) {
      var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t) {
        var e2, n2, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r2)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l); f = true) ;
        } catch (r3) {
          o = true, n2 = r3;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var dom = [["a", {
      reserved: false
    }], ["abbr", {
      reserved: false
    }], ["acronym", {
      reserved: false
    }], ["address", {
      reserved: false
    }], ["applet", {
      reserved: false
    }], ["area", {
      reserved: false
    }], ["article", {
      reserved: false
    }], ["aside", {
      reserved: false
    }], ["audio", {
      reserved: false
    }], ["b", {
      reserved: false
    }], ["base", {
      reserved: true
    }], ["bdi", {
      reserved: false
    }], ["bdo", {
      reserved: false
    }], ["big", {
      reserved: false
    }], ["blink", {
      reserved: false
    }], ["blockquote", {
      reserved: false
    }], ["body", {
      reserved: false
    }], ["br", {
      reserved: false
    }], ["button", {
      reserved: false
    }], ["canvas", {
      reserved: false
    }], ["caption", {
      reserved: false
    }], ["center", {
      reserved: false
    }], ["cite", {
      reserved: false
    }], ["code", {
      reserved: false
    }], ["col", {
      reserved: true
    }], ["colgroup", {
      reserved: true
    }], ["content", {
      reserved: false
    }], ["data", {
      reserved: false
    }], ["datalist", {
      reserved: false
    }], ["dd", {
      reserved: false
    }], ["del", {
      reserved: false
    }], ["details", {
      reserved: false
    }], ["dfn", {
      reserved: false
    }], ["dialog", {
      reserved: false
    }], ["dir", {
      reserved: false
    }], ["div", {
      reserved: false
    }], ["dl", {
      reserved: false
    }], ["dt", {
      reserved: false
    }], ["em", {
      reserved: false
    }], ["embed", {
      reserved: false
    }], ["fieldset", {
      reserved: false
    }], ["figcaption", {
      reserved: false
    }], ["figure", {
      reserved: false
    }], ["font", {
      reserved: false
    }], ["footer", {
      reserved: false
    }], ["form", {
      reserved: false
    }], ["frame", {
      reserved: false
    }], ["frameset", {
      reserved: false
    }], ["h1", {
      reserved: false
    }], ["h2", {
      reserved: false
    }], ["h3", {
      reserved: false
    }], ["h4", {
      reserved: false
    }], ["h5", {
      reserved: false
    }], ["h6", {
      reserved: false
    }], ["head", {
      reserved: true
    }], ["header", {
      reserved: false
    }], ["hgroup", {
      reserved: false
    }], ["hr", {
      reserved: false
    }], ["html", {
      reserved: true
    }], ["i", {
      reserved: false
    }], ["iframe", {
      reserved: false
    }], ["img", {
      reserved: false
    }], ["input", {
      reserved: false
    }], ["ins", {
      reserved: false
    }], ["kbd", {
      reserved: false
    }], ["keygen", {
      reserved: false
    }], ["label", {
      reserved: false
    }], ["legend", {
      reserved: false
    }], ["li", {
      reserved: false
    }], ["link", {
      reserved: true
    }], ["main", {
      reserved: false
    }], ["map", {
      reserved: false
    }], ["mark", {
      reserved: false
    }], ["marquee", {
      reserved: false
    }], ["menu", {
      reserved: false
    }], ["menuitem", {
      reserved: false
    }], ["meta", {
      reserved: true
    }], ["meter", {
      reserved: false
    }], ["nav", {
      reserved: false
    }], ["noembed", {
      reserved: true
    }], ["noscript", {
      reserved: true
    }], ["object", {
      reserved: false
    }], ["ol", {
      reserved: false
    }], ["optgroup", {
      reserved: false
    }], ["option", {
      reserved: false
    }], ["output", {
      reserved: false
    }], ["p", {
      reserved: false
    }], ["param", {
      reserved: true
    }], ["picture", {
      reserved: true
    }], ["pre", {
      reserved: false
    }], ["progress", {
      reserved: false
    }], ["q", {
      reserved: false
    }], ["rp", {
      reserved: false
    }], ["rt", {
      reserved: false
    }], ["rtc", {
      reserved: false
    }], ["ruby", {
      reserved: false
    }], ["s", {
      reserved: false
    }], ["samp", {
      reserved: false
    }], ["script", {
      reserved: true
    }], ["section", {
      reserved: false
    }], ["select", {
      reserved: false
    }], ["small", {
      reserved: false
    }], ["source", {
      reserved: true
    }], ["spacer", {
      reserved: false
    }], ["span", {
      reserved: false
    }], ["strike", {
      reserved: false
    }], ["strong", {
      reserved: false
    }], ["style", {
      reserved: true
    }], ["sub", {
      reserved: false
    }], ["summary", {
      reserved: false
    }], ["sup", {
      reserved: false
    }], ["table", {
      reserved: false
    }], ["tbody", {
      reserved: false
    }], ["td", {
      reserved: false
    }], ["textarea", {
      reserved: false
    }], ["tfoot", {
      reserved: false
    }], ["th", {
      reserved: false
    }], ["thead", {
      reserved: false
    }], ["time", {
      reserved: false
    }], ["title", {
      reserved: true
    }], ["tr", {
      reserved: false
    }], ["track", {
      reserved: true
    }], ["tt", {
      reserved: false
    }], ["u", {
      reserved: false
    }], ["ul", {
      reserved: false
    }], ["var", {
      reserved: false
    }], ["video", {
      reserved: false
    }], ["wbr", {
      reserved: false
    }], ["xmp", {
      reserved: false
    }]];
    var domMap = {
      entries: function entries() {
        return dom;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _dom = dom; _i < _dom.length; _i++) {
          var _dom$_i = _slicedToArray(_dom[_i], 2), key2 = _dom$_i[0], values = _dom$_i[1];
          fn.call(thisArg, values, key2, dom);
        }
      },
      get: function get3(key2) {
        var item = dom.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!domMap.get(key2);
      },
      keys: function keys() {
        return dom.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return dom.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(domMap, domMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/commandRole.js
var require_commandRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var commandRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = commandRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js
var require_compositeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var compositeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = compositeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/inputRole.js
var require_inputRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var inputRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = inputRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js
var require_landmarkRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var landmarkRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = landmarkRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js
var require_rangeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rangeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = rangeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js
var require_roletypeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var roletypeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = exports.default = roletypeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js
var require_sectionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = sectionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js
var require_sectionheadRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionheadRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = sectionheadRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/selectRole.js
var require_selectRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var selectRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = selectRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/structureRole.js
var require_structureRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var structureRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = structureRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js
var require_widgetRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var widgetRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = widgetRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/windowRole.js
var require_windowRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var windowRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = windowRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js
var require_ariaAbstractRoles = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _commandRole = _interopRequireDefault(require_commandRole());
    var _compositeRole = _interopRequireDefault(require_compositeRole());
    var _inputRole = _interopRequireDefault(require_inputRole());
    var _landmarkRole = _interopRequireDefault(require_landmarkRole());
    var _rangeRole = _interopRequireDefault(require_rangeRole());
    var _roletypeRole = _interopRequireDefault(require_roletypeRole());
    var _sectionRole = _interopRequireDefault(require_sectionRole());
    var _sectionheadRole = _interopRequireDefault(require_sectionheadRole());
    var _selectRole = _interopRequireDefault(require_selectRole());
    var _structureRole = _interopRequireDefault(require_structureRole());
    var _widgetRole = _interopRequireDefault(require_widgetRole());
    var _windowRole = _interopRequireDefault(require_windowRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
    var _default = exports.default = ariaAbstractRoles;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/alertRole.js
var require_alertRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = alertRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js
var require_alertdialogRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertdialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    var _default = exports.default = alertdialogRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/applicationRole.js
var require_applicationRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var applicationRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = applicationRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/articleRole.js
var require_articleRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var articleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = exports.default = articleRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/bannerRole.js
var require_bannerRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bannerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = bannerRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js
var require_blockquoteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var blockquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = blockquoteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/buttonRole.js
var require_buttonRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var buttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = buttonRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/captionRole.js
var require_captionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var captionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = captionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/cellRole.js
var require_cellRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var cellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = cellRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js
var require_checkboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var checkboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = checkboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/codeRole.js
var require_codeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var codeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = codeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js
var require_columnheaderRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var columnheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = columnheaderRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js
var require_comboboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var comboboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = comboboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js
var require_complementaryRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var complementaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = complementaryRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js
var require_contentinfoRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var contentinfoRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = contentinfoRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/definitionRole.js
var require_definitionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var definitionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = definitionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/deletionRole.js
var require_deletionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var deletionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = deletionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/dialogRole.js
var require_dialogRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    var _default = exports.default = dialogRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/directoryRole.js
var require_directoryRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var directoryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = exports.default = directoryRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/documentRole.js
var require_documentRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var documentRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = documentRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js
var require_emphasisRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var emphasisRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = emphasisRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/feedRole.js
var require_feedRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var feedRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = exports.default = feedRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/figureRole.js
var require_figureRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var figureRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = figureRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/formRole.js
var require_formRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = formRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/genericRole.js
var require_genericRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var genericRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = genericRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/gridRole.js
var require_gridRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    var _default = exports.default = gridRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js
var require_gridcellRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridcellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    var _default = exports.default = gridcellRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/groupRole.js
var require_groupRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var groupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = groupRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/headingRole.js
var require_headingRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var headingRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = headingRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/imgRole.js
var require_imgRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var imgRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = imgRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/insertionRole.js
var require_insertionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var insertionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = insertionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/linkRole.js
var require_linkRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var linkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = linkRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listRole.js
var require_listRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = listRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listboxRole.js
var require_listboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = listboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listitemRole.js
var require_listitemRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listitemRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = listitemRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/logRole.js
var require_logRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var logRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = logRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/mainRole.js
var require_mainRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mainRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = mainRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/markRole.js
var require_markRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var markRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = markRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js
var require_marqueeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var marqueeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = marqueeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/mathRole.js
var require_mathRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mathRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = mathRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuRole.js
var require_menuRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = menuRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menubarRole.js
var require_menubarRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menubarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    var _default = exports.default = menubarRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js
var require_menuitemRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = menuitemRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js
var require_menuitemcheckboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemcheckboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    var _default = exports.default = menuitemcheckboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js
var require_menuitemradioRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemradioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    var _default = exports.default = menuitemradioRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/meterRole.js
var require_meterRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var meterRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    var _default = exports.default = meterRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/navigationRole.js
var require_navigationRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var navigationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = navigationRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/noneRole.js
var require_noneRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noneRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = exports.default = noneRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/noteRole.js
var require_noteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = noteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/optionRole.js
var require_optionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var optionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = optionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js
var require_paragraphRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var paragraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = paragraphRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/presentationRole.js
var require_presentationRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var presentationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = presentationRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js
var require_progressbarRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var progressbarRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = exports.default = progressbarRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/radioRole.js
var require_radioRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = radioRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js
var require_radiogroupRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radiogroupRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = radiogroupRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/regionRole.js
var require_regionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var regionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = regionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowRole.js
var require_rowRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    var _default = exports.default = rowRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js
var require_rowgroupRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowgroupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = rowgroupRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js
var require_rowheaderRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = rowheaderRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js
var require_scrollbarRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var scrollbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = exports.default = scrollbarRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/searchRole.js
var require_searchRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = searchRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js
var require_searchboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    var _default = exports.default = searchboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/separatorRole.js
var require_separatorRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var separatorRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = separatorRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/sliderRole.js
var require_sliderRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sliderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = exports.default = sliderRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js
var require_spinbuttonRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var spinbuttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = exports.default = spinbuttonRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/statusRole.js
var require_statusRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var statusRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = statusRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/strongRole.js
var require_strongRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var strongRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = strongRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js
var require_subscriptRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var subscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = subscriptRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js
var require_superscriptRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var superscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = superscriptRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/switchRole.js
var require_switchRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var switchRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    var _default = exports.default = switchRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tabRole.js
var require_tabRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    var _default = exports.default = tabRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tableRole.js
var require_tableRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tableRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tableRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tablistRole.js
var require_tablistRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tablistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    var _default = exports.default = tablistRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js
var require_tabpanelRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabpanelRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tabpanelRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/termRole.js
var require_termRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var termRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = termRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/textboxRole.js
var require_textboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var textboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = textboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/timeRole.js
var require_timeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = timeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/timerRole.js
var require_timerRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    var _default = exports.default = timerRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js
var require_toolbarRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toolbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = toolbarRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js
var require_tooltipRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tooltipRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tooltipRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treeRole.js
var require_treeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = treeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treegridRole.js
var require_treegridRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treegridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    var _default = exports.default = treegridRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js
var require_treeitemRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    var _default = exports.default = treeitemRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js
var require_ariaLiteralRoles = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _alertRole = _interopRequireDefault(require_alertRole());
    var _alertdialogRole = _interopRequireDefault(require_alertdialogRole());
    var _applicationRole = _interopRequireDefault(require_applicationRole());
    var _articleRole = _interopRequireDefault(require_articleRole());
    var _bannerRole = _interopRequireDefault(require_bannerRole());
    var _blockquoteRole = _interopRequireDefault(require_blockquoteRole());
    var _buttonRole = _interopRequireDefault(require_buttonRole());
    var _captionRole = _interopRequireDefault(require_captionRole());
    var _cellRole = _interopRequireDefault(require_cellRole());
    var _checkboxRole = _interopRequireDefault(require_checkboxRole());
    var _codeRole = _interopRequireDefault(require_codeRole());
    var _columnheaderRole = _interopRequireDefault(require_columnheaderRole());
    var _comboboxRole = _interopRequireDefault(require_comboboxRole());
    var _complementaryRole = _interopRequireDefault(require_complementaryRole());
    var _contentinfoRole = _interopRequireDefault(require_contentinfoRole());
    var _definitionRole = _interopRequireDefault(require_definitionRole());
    var _deletionRole = _interopRequireDefault(require_deletionRole());
    var _dialogRole = _interopRequireDefault(require_dialogRole());
    var _directoryRole = _interopRequireDefault(require_directoryRole());
    var _documentRole = _interopRequireDefault(require_documentRole());
    var _emphasisRole = _interopRequireDefault(require_emphasisRole());
    var _feedRole = _interopRequireDefault(require_feedRole());
    var _figureRole = _interopRequireDefault(require_figureRole());
    var _formRole = _interopRequireDefault(require_formRole());
    var _genericRole = _interopRequireDefault(require_genericRole());
    var _gridRole = _interopRequireDefault(require_gridRole());
    var _gridcellRole = _interopRequireDefault(require_gridcellRole());
    var _groupRole = _interopRequireDefault(require_groupRole());
    var _headingRole = _interopRequireDefault(require_headingRole());
    var _imgRole = _interopRequireDefault(require_imgRole());
    var _insertionRole = _interopRequireDefault(require_insertionRole());
    var _linkRole = _interopRequireDefault(require_linkRole());
    var _listRole = _interopRequireDefault(require_listRole());
    var _listboxRole = _interopRequireDefault(require_listboxRole());
    var _listitemRole = _interopRequireDefault(require_listitemRole());
    var _logRole = _interopRequireDefault(require_logRole());
    var _mainRole = _interopRequireDefault(require_mainRole());
    var _markRole = _interopRequireDefault(require_markRole());
    var _marqueeRole = _interopRequireDefault(require_marqueeRole());
    var _mathRole = _interopRequireDefault(require_mathRole());
    var _menuRole = _interopRequireDefault(require_menuRole());
    var _menubarRole = _interopRequireDefault(require_menubarRole());
    var _menuitemRole = _interopRequireDefault(require_menuitemRole());
    var _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole());
    var _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole());
    var _meterRole = _interopRequireDefault(require_meterRole());
    var _navigationRole = _interopRequireDefault(require_navigationRole());
    var _noneRole = _interopRequireDefault(require_noneRole());
    var _noteRole = _interopRequireDefault(require_noteRole());
    var _optionRole = _interopRequireDefault(require_optionRole());
    var _paragraphRole = _interopRequireDefault(require_paragraphRole());
    var _presentationRole = _interopRequireDefault(require_presentationRole());
    var _progressbarRole = _interopRequireDefault(require_progressbarRole());
    var _radioRole = _interopRequireDefault(require_radioRole());
    var _radiogroupRole = _interopRequireDefault(require_radiogroupRole());
    var _regionRole = _interopRequireDefault(require_regionRole());
    var _rowRole = _interopRequireDefault(require_rowRole());
    var _rowgroupRole = _interopRequireDefault(require_rowgroupRole());
    var _rowheaderRole = _interopRequireDefault(require_rowheaderRole());
    var _scrollbarRole = _interopRequireDefault(require_scrollbarRole());
    var _searchRole = _interopRequireDefault(require_searchRole());
    var _searchboxRole = _interopRequireDefault(require_searchboxRole());
    var _separatorRole = _interopRequireDefault(require_separatorRole());
    var _sliderRole = _interopRequireDefault(require_sliderRole());
    var _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole());
    var _statusRole = _interopRequireDefault(require_statusRole());
    var _strongRole = _interopRequireDefault(require_strongRole());
    var _subscriptRole = _interopRequireDefault(require_subscriptRole());
    var _superscriptRole = _interopRequireDefault(require_superscriptRole());
    var _switchRole = _interopRequireDefault(require_switchRole());
    var _tabRole = _interopRequireDefault(require_tabRole());
    var _tableRole = _interopRequireDefault(require_tableRole());
    var _tablistRole = _interopRequireDefault(require_tablistRole());
    var _tabpanelRole = _interopRequireDefault(require_tabpanelRole());
    var _termRole = _interopRequireDefault(require_termRole());
    var _textboxRole = _interopRequireDefault(require_textboxRole());
    var _timeRole = _interopRequireDefault(require_timeRole());
    var _timerRole = _interopRequireDefault(require_timerRole());
    var _toolbarRole = _interopRequireDefault(require_toolbarRole());
    var _tooltipRole = _interopRequireDefault(require_tooltipRole());
    var _treeRole = _interopRequireDefault(require_treeRole());
    var _treegridRole = _interopRequireDefault(require_treegridRole());
    var _treeitemRole = _interopRequireDefault(require_treeitemRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
    var _default = exports.default = ariaLiteralRoles;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js
var require_docAbstractRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAbstractRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docAbstractRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js
var require_docAcknowledgmentsRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAcknowledgmentsRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js
var require_docAfterwordRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAfterwordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAfterwordRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js
var require_docAppendixRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAppendixRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAppendixRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js
var require_docBacklinkRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBacklinkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docBacklinkRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js
var require_docBiblioentryRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBiblioentryRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = exports.default = docBiblioentryRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js
var require_docBibliographyRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliographyRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docBibliographyRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js
var require_docBibliorefRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliorefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docBibliorefRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js
var require_docChapterRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docChapterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docChapterRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js
var require_docColophonRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docColophonRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docColophonRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js
var require_docConclusionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docConclusionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docConclusionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js
var require_docCoverRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCoverRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = exports.default = docCoverRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js
var require_docCreditRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docCreditRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js
var require_docCreditsRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docCreditsRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js
var require_docDedicationRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docDedicationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docDedicationRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js
var require_docEndnoteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = exports.default = docEndnoteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js
var require_docEndnotesRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnotesRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docEndnotesRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js
var require_docEpigraphRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpigraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docEpigraphRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js
var require_docEpilogueRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpilogueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docEpilogueRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js
var require_docErrataRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docErrataRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docErrataRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js
var require_docExampleRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docExampleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docExampleRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js
var require_docFootnoteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docFootnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docFootnoteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js
var require_docForewordRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docForewordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docForewordRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js
var require_docGlossaryRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docGlossaryRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js
var require_docGlossrefRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossrefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docGlossrefRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js
var require_docIndexRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIndexRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docIndexRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js
var require_docIntroductionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIntroductionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docIntroductionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js
var require_docNoterefRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoterefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docNoterefRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js
var require_docNoticeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoticeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = exports.default = docNoticeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js
var require_docPagebreakRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagebreakRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    var _default = exports.default = docPagebreakRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js
var require_docPagefooterRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagefooterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docPagefooterRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js
var require_docPageheaderRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPageheaderRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docPageheaderRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js
var require_docPagelistRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagelistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docPagelistRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js
var require_docPartRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPartRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPartRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js
var require_docPrefaceRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrefaceRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPrefaceRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js
var require_docPrologueRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrologueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPrologueRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js
var require_docPullquoteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPullquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    var _default = exports.default = docPullquoteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js
var require_docQnaRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docQnaRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docQnaRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js
var require_docSubtitleRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docSubtitleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = docSubtitleRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js
var require_docTipRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTipRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = exports.default = docTipRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js
var require_docTocRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTocRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docTocRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js
var require_ariaDpubRoles = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _docAbstractRole = _interopRequireDefault(require_docAbstractRole());
    var _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole());
    var _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole());
    var _docAppendixRole = _interopRequireDefault(require_docAppendixRole());
    var _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole());
    var _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole());
    var _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole());
    var _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole());
    var _docChapterRole = _interopRequireDefault(require_docChapterRole());
    var _docColophonRole = _interopRequireDefault(require_docColophonRole());
    var _docConclusionRole = _interopRequireDefault(require_docConclusionRole());
    var _docCoverRole = _interopRequireDefault(require_docCoverRole());
    var _docCreditRole = _interopRequireDefault(require_docCreditRole());
    var _docCreditsRole = _interopRequireDefault(require_docCreditsRole());
    var _docDedicationRole = _interopRequireDefault(require_docDedicationRole());
    var _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole());
    var _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole());
    var _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole());
    var _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole());
    var _docErrataRole = _interopRequireDefault(require_docErrataRole());
    var _docExampleRole = _interopRequireDefault(require_docExampleRole());
    var _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole());
    var _docForewordRole = _interopRequireDefault(require_docForewordRole());
    var _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole());
    var _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole());
    var _docIndexRole = _interopRequireDefault(require_docIndexRole());
    var _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole());
    var _docNoterefRole = _interopRequireDefault(require_docNoterefRole());
    var _docNoticeRole = _interopRequireDefault(require_docNoticeRole());
    var _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole());
    var _docPagefooterRole = _interopRequireDefault(require_docPagefooterRole());
    var _docPageheaderRole = _interopRequireDefault(require_docPageheaderRole());
    var _docPagelistRole = _interopRequireDefault(require_docPagelistRole());
    var _docPartRole = _interopRequireDefault(require_docPartRole());
    var _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole());
    var _docPrologueRole = _interopRequireDefault(require_docPrologueRole());
    var _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole());
    var _docQnaRole = _interopRequireDefault(require_docQnaRole());
    var _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole());
    var _docTipRole = _interopRequireDefault(require_docTipRole());
    var _docTocRole = _interopRequireDefault(require_docTocRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagefooter", _docPagefooterRole.default], ["doc-pageheader", _docPageheaderRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
    var _default = exports.default = ariaDpubRoles;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js
var require_graphicsDocumentRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsDocumentRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = exports.default = graphicsDocumentRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js
var require_graphicsObjectRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsObjectRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = graphicsObjectRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js
var require_graphicsSymbolRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsSymbolRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = exports.default = graphicsSymbolRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js
var require_ariaGraphicsRoles = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole());
    var _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole());
    var _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
    var _default = exports.default = ariaGraphicsRoles;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/rolesMap.js
var require_rolesMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/rolesMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles());
    var _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles());
    var _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles());
    var _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _createForOfIteratorHelper(r2, e2) {
      var t = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (!t) {
        if (Array.isArray(r2) || (t = _unsupportedIterableToArray(r2)) || e2 && r2 && "number" == typeof r2.length) {
          t && (r2 = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n2() {
            return _n >= r2.length ? { done: true } : { done: false, value: r2[_n++] };
          }, e: function e3(r3) {
            throw r3;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r2);
      }, n: function n2() {
        var r3 = t.next();
        return a = r3.done, r3;
      }, e: function e3(r3) {
        u = true, o = r3;
      }, f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r2, a) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
        var t = {}.toString.call(r2).slice(8, -1);
        return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a) {
      (null == a || a > r2.length) && (a = r2.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l) {
      var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t) {
        var e2, n2, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r2)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l); f = true) ;
        } catch (r3) {
          o = true, n2 = r3;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
      var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value;
          var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = function _loop2() {
              var superClassName = _step2.value;
              var superClassRoleTuple = roles.filter(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                return name === superClassName;
              })[0];
              if (superClassRoleTuple) {
                var superClassDefinition = superClassRoleTuple[1];
                for (var _i = 0, _Object$keys = Object.keys(superClassDefinition.props); _i < _Object$keys.length; _i++) {
                  var prop2 = _Object$keys[_i];
                  if (
                    // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                    !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop2)
                  ) {
                    roleDefinition.props[prop2] = superClassDefinition.props[prop2];
                  }
                }
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              _loop();
            }
          } catch (err2) {
            _iterator2.e(err2);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err2) {
        _iterator.e(err2);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: function entries() {
        return roles;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator3 = _createForOfIteratorHelper(roles), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key2 = _step3$value[0], values = _step3$value[1];
            fn.call(thisArg, values, key2, roles);
          }
        } catch (err2) {
          _iterator3.e(err2);
        } finally {
          _iterator3.f();
        }
      },
      get: function get3(key2) {
        var item = roles.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!rolesMap.get(key2);
      },
      keys: function keys() {
        return roles.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
          return key2;
        });
      },
      values: function values() {
        return roles.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/elementRoleMap.js
var require_elementRoleMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/elementRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r2, a) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
        var t = {}.toString.call(r2).slice(8, -1);
        return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a) {
      (null == a || a > r2.length) && (a = r2.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l) {
      var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t) {
        var e2, n2, i2, u, a = [], f = true, o = false;
        try {
          if (i2 = (t = t.call(r2)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i2.call(t)).done) && (a.push(e2.value), a.length !== l); f = true) ;
        } catch (r3) {
          o = true, n2 = r3;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var elementRoles2 = [];
    var keys = _rolesMap.default.keys();
    for (i = 0; i < keys.length; i++) {
      key2 = keys[i];
      role = _rolesMap.default.get(key2);
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        _loop = function _loop2() {
          var relation = concepts[k];
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var elementRoleRelation = elementRoles2.filter(function(relation2) {
                return ariaRoleRelationConceptEquals(relation2[0], concept);
              })[0];
              var roles;
              if (elementRoleRelation) {
                roles = elementRoleRelation[1];
              } else {
                roles = [];
              }
              var isUnique = true;
              for (var _i = 0; _i < roles.length; _i++) {
                if (roles[_i] === key2) {
                  isUnique = false;
                  break;
                }
              }
              if (isUnique) {
                roles.push(key2);
              }
              if (!elementRoleRelation) {
                elementRoles2.push([concept, roles]);
              }
            }
          }
        };
        for (k = 0; k < concepts.length; k++) {
          _loop();
        }
      }
    }
    var key2;
    var role;
    var concepts;
    var _loop;
    var k;
    var i;
    var elementRoleMap = {
      entries: function entries() {
        return elementRoles2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i2 = 0, _elementRoles = elementRoles2; _i2 < _elementRoles.length; _i2++) {
          var _elementRoles$_i = _slicedToArray(_elementRoles[_i2], 2), _key = _elementRoles$_i[0], values = _elementRoles$_i[1];
          fn.call(thisArg, values, _key, elementRoles2);
        }
      },
      get: function get3(key3) {
        var item = elementRoles2.filter(function(tuple) {
          return key3.name === tuple[0].name && ariaRoleRelationConceptAttributeEquals(key3.attributes, tuple[0].attributes);
        })[0];
        return item && item[1];
      },
      has: function has(key3) {
        return !!elementRoleMap.get(key3);
      },
      keys: function keys2() {
        return elementRoles2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key3 = _ref2[0];
          return key3;
        });
      },
      values: function values() {
        return elementRoles2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    function ariaRoleRelationConceptEquals(a, b) {
      return a.name === b.name && ariaRoleRelationConstraintsEquals(a.constraints, b.constraints) && ariaRoleRelationConceptAttributeEquals(a.attributes, b.attributes);
    }
    function ariaRoleRelationConstraintsEquals(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length !== b.length) {
          return false;
        }
        for (var _i3 = 0; _i3 < a.length; _i3++) {
          if (a[_i3] !== b[_i3]) {
            return false;
          }
        }
      }
      return true;
    }
    function ariaRoleRelationConceptAttributeEquals(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length !== b.length) {
          return false;
        }
        for (var _i4 = 0; _i4 < a.length; _i4++) {
          if (a[_i4].name !== b[_i4].name || a[_i4].value !== b[_i4].value) {
            return false;
          }
          if (a[_i4].constraints === void 0 && b[_i4].constraints !== void 0) {
            return false;
          }
          if (a[_i4].constraints !== void 0 && b[_i4].constraints === void 0) {
            return false;
          }
          if (a[_i4].constraints !== void 0 && b[_i4].constraints !== void 0) {
            if (a[_i4].constraints.length !== b[_i4].constraints.length) {
              return false;
            }
            for (var j = 0; j < a[_i4].constraints.length; j++) {
              if (a[_i4].constraints[j] !== b[_i4].constraints[j]) {
                return false;
              }
            }
          }
        }
      }
      return true;
    }
    var _default = exports.default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/roleElementMap.js
var require_roleElementMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/roleElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r2, a) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
        var t = {}.toString.call(r2).slice(8, -1);
        return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a) : void 0;
      }
    }
    function _arrayLikeToArray(r2, a) {
      (null == a || a > r2.length) && (a = r2.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _iterableToArrayLimit(r2, l) {
      var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t) {
        var e2, n2, i2, u, a = [], f = true, o = false;
        try {
          if (i2 = (t = t.call(r2)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i2.call(t)).done) && (a.push(e2.value), a.length !== l); f = true) ;
        } catch (r3) {
          o = true, n2 = r3;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n2;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    var roleElement = [];
    var keys = _rolesMap.default.keys();
    for (i = 0; i < keys.length; i++) {
      key2 = keys[i];
      role = _rolesMap.default.get(key2);
      relationConcepts = [];
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (k = 0; k < concepts.length; k++) {
          relation = concepts[k];
          if (relation.module === "HTML") {
            concept = relation.concept;
            if (concept != null) {
              relationConcepts.push(concept);
            }
          }
        }
        if (relationConcepts.length > 0) {
          roleElement.push([key2, relationConcepts]);
        }
      }
    }
    var key2;
    var role;
    var relationConcepts;
    var concepts;
    var relation;
    var concept;
    var k;
    var i;
    var roleElementMap = {
      entries: function entries() {
        return roleElement;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _roleElement = roleElement; _i < _roleElement.length; _i++) {
          var _roleElement$_i = _slicedToArray(_roleElement[_i], 2), _key = _roleElement$_i[0], values = _roleElement$_i[1];
          fn.call(thisArg, values, _key, roleElement);
        }
      },
      get: function get3(key3) {
        var item = roleElement.filter(function(tuple) {
          return tuple[0] === key3 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key3) {
        return !!roleElementMap.get(key3);
      },
      keys: function keys2() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key3 = _ref2[0];
          return key3;
        });
      },
      values: function values() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/index.js
var require_lib = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap());
    var _domMap = _interopRequireDefault(require_domMap());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    var _elementRoleMap = _interopRequireDefault(require_elementRoleMap());
    var _roleElementMap = _interopRequireDefault(require_roleElementMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var aria2 = exports.aria = _ariaPropsMap.default;
    var dom = exports.dom = _domMap.default;
    var roles = exports.roles = _rolesMap.default;
    var elementRoles2 = exports.elementRoles = _elementRoleMap.default;
    var roleElements = exports.roleElements = _roleElementMap.default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/util/iteratorProxy.js
var require_iteratorProxy2 = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next2() {
          if (index < values.length) {
            var value = values[index];
            index = index + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/util/iterationDecorator.js
var require_iterationDecorator2 = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AbbrRole.js
var require_AbbrRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AbbrRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AbbrRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "abbr"
        }
      }],
      type: "structure"
    };
    var _default = AbbrRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js
var require_AlertDialogRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertDialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alertdialog"
        }
      }],
      type: "window"
    };
    var _default = AlertDialogRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AlertRole.js
var require_AlertRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AlertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alert"
        }
      }],
      type: "structure"
    };
    var _default = AlertRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AnnotationRole.js
var require_AnnotationRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AnnotationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AnnotationRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = AnnotationRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ApplicationRole.js
var require_ApplicationRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ApplicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ApplicationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "application"
        }
      }],
      type: "window"
    };
    var _default = ApplicationRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ArticleRole.js
var require_ArticleRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ArticleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ArticleRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "article"
        }
      }, {
        module: "HTML",
        concept: {
          name: "article"
        }
      }],
      type: "structure"
    };
    var _default = ArticleRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AudioRole.js
var require_AudioRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AudioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AudioRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "audio"
        }
      }],
      type: "widget"
    };
    var _default = AudioRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BannerRole.js
var require_BannerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BannerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "banner"
        }
      }],
      type: "structure"
    };
    var _default = BannerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js
var require_BlockquoteRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BlockquoteRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "blockquote"
        }
      }],
      type: "structure"
    };
    var _default = BlockquoteRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js
var require_BusyIndicatorRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BusyIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-busy",
            value: "true"
          }]
        }
      }],
      type: "widget"
    };
    var _default = BusyIndicatorRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ButtonRole.js
var require_ButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "button"
        }
      }, {
        module: "HTML",
        concept: {
          name: "button"
        }
      }],
      type: "widget"
    };
    var _default = ButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CanvasRole.js
var require_CanvasRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CanvasRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CanvasRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "canvas"
        }
      }],
      type: "widget"
    };
    var _default = CanvasRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CaptionRole.js
var require_CaptionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "caption"
        }
      }],
      type: "structure"
    };
    var _default = CaptionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CellRole.js
var require_CellRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CellRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "cell"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "gridcell"
        }
      }, {
        module: "HTML",
        concept: {
          name: "td"
        }
      }],
      type: "widget"
    };
    var _default = CellRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js
var require_CheckBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "checkbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = CheckBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColorWellRole.js
var require_ColorWellRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColorWellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColorWellRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "color"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ColorWellRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js
var require_ColumnHeaderRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "columnheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th"
        }
      }],
      type: "widget"
    };
    var _default = ColumnHeaderRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColumnRole.js
var require_ColumnRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColumnRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ColumnRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js
var require_ComboBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComboBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "combobox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ComboBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js
var require_ComplementaryRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComplementaryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "complementary"
        }
      }],
      type: "structure"
    };
    var _default = ComplementaryRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js
var require_ContentInfoRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ContentInfoRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "structureinfo"
        }
      }],
      type: "structure"
    };
    var _default = ContentInfoRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DateRole.js
var require_DateRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DateRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "date"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DateTimeRole.js
var require_DateTimeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DateTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "datetime"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateTimeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DefinitionRole.js
var require_DefinitionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DefinitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DefinitionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dfn"
        }
      }],
      type: "structure"
    };
    var _default = DefinitionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js
var require_DescriptionListDetailRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListDetailRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dd"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListDetailRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js
var require_DescriptionListRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dl"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js
var require_DescriptionListTermRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListTermRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dt"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListTermRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DetailsRole.js
var require_DetailsRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DetailsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DetailsRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "details"
        }
      }],
      type: "structure"
    };
    var _default = DetailsRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DialogRole.js
var require_DialogRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "dialog"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dialog"
        }
      }],
      type: "window"
    };
    var _default = DialogRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DirectoryRole.js
var require_DirectoryRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DirectoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DirectoryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "directory"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dir"
        }
      }],
      type: "structure"
    };
    var _default = DirectoryRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js
var require_DisclosureTriangleRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DisclosureTriangleRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          constraints: ["scoped to a details element"],
          name: "summary"
        }
      }],
      type: "widget"
    };
    var _default = DisclosureTriangleRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DivRole.js
var require_DivRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DivRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DivRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "div"
        }
      }],
      type: "generic"
    };
    var _default = DivRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DocumentRole.js
var require_DocumentRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DocumentRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "document"
        }
      }],
      type: "structure"
    };
    var _default = DocumentRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js
var require_EmbeddedObjectRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var EmbeddedObjectRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "embed"
        }
      }],
      type: "widget"
    };
    var _default = EmbeddedObjectRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FeedRole.js
var require_FeedRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FeedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FeedRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "feed"
        }
      }],
      type: "structure"
    };
    var _default = FeedRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js
var require_FigcaptionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigcaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "figcaption"
        }
      }],
      type: "structure"
    };
    var _default = FigcaptionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FigureRole.js
var require_FigureRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FigureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigureRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "figure"
        }
      }, {
        module: "HTML",
        concept: {
          name: "figure"
        }
      }],
      type: "structure"
    };
    var _default = FigureRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FooterRole.js
var require_FooterRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FooterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "footer"
        }
      }],
      type: "structure"
    };
    var _default = FooterRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FormRole.js
var require_FormRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FormRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FormRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "form"
        }
      }, {
        module: "HTML",
        concept: {
          name: "form"
        }
      }],
      type: "structure"
    };
    var _default = FormRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/GridRole.js
var require_GridRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/GridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "grid"
        }
      }],
      type: "widget"
    };
    var _default = GridRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/GroupRole.js
var require_GroupRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/GroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "group"
        }
      }],
      type: "structure"
    };
    var _default = GroupRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/HeadingRole.js
var require_HeadingRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/HeadingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var HeadingRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "heading"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h1"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h2"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h3"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h4"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h5"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h6"
        }
      }],
      type: "structure"
    };
    var _default = HeadingRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js
var require_IframePresentationalRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframePresentationalRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = IframePresentationalRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IframeRole.js
var require_IframeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IframeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "iframe"
        }
      }],
      type: "window"
    };
    var _default = IframeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IgnoredRole.js
var require_IgnoredRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IgnoredRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IgnoredRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = IgnoredRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js
var require_ImageMapLinkRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapLinkRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = ImageMapLinkRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageMapRole.js
var require_ImageMapRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageMapRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "img",
          attributes: [{
            name: "usemap"
          }]
        }
      }],
      type: "structure"
    };
    var _default = ImageMapRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageRole.js
var require_ImageRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "HTML",
        concept: {
          name: "img"
        }
      }],
      type: "structure"
    };
    var _default = ImageRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js
var require_InlineTextBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InlineTextBoxRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input"
        }
      }],
      type: "widget"
    };
    var _default = InlineTextBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/InputTimeRole.js
var require_InputTimeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/InputTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InputTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "time"
          }]
        }
      }],
      type: "widget"
    };
    var _default = InputTimeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LabelRole.js
var require_LabelRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LabelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LabelRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "label"
        }
      }],
      type: "structure"
    };
    var _default = LabelRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LegendRole.js
var require_LegendRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LegendRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LegendRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "legend"
        }
      }],
      type: "structure"
    };
    var _default = LegendRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LineBreakRole.js
var require_LineBreakRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LineBreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LineBreakRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "br"
        }
      }],
      type: "structure"
    };
    var _default = LineBreakRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LinkRole.js
var require_LinkRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LinkRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "link"
        }
      }, {
        module: "HTML",
        concept: {
          name: "a",
          attributes: [{
            name: "href"
          }]
        }
      }],
      type: "widget"
    };
    var _default = LinkRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js
var require_ListBoxOptionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxOptionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "option"
        }
      }, {
        module: "HTML",
        concept: {
          name: "option"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxOptionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListBoxRole.js
var require_ListBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "datalist"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListItemRole.js
var require_ListItemRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "li"
        }
      }],
      type: "structure"
    };
    var _default = ListItemRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js
var require_ListMarkerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListMarkerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ListMarkerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListRole.js
var require_ListRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "list"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ul"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ol"
        }
      }],
      type: "structure"
    };
    var _default = ListRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LogRole.js
var require_LogRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "log"
        }
      }],
      type: "structure"
    };
    var _default = LogRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MainRole.js
var require_MainRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MainRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "main"
        }
      }, {
        module: "HTML",
        concept: {
          name: "main"
        }
      }],
      type: "structure"
    };
    var _default = MainRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MarkRole.js
var require_MarkRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarkRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "mark"
        }
      }],
      type: "structure"
    };
    var _default = MarkRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MarqueeRole.js
var require_MarqueeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MarqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarqueeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "marquee"
        }
      }, {
        module: "HTML",
        concept: {
          name: "marquee"
        }
      }],
      type: "structure"
    };
    var _default = MarqueeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MathRole.js
var require_MathRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MathRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "math"
        }
      }],
      type: "structure"
    };
    var _default = MathRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuBarRole.js
var require_MenuBarRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menubar"
        }
      }],
      type: "structure"
    };
    var _default = MenuBarRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js
var require_MenuButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemRole.js
var require_MenuItemRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menuitem"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js
var require_MenuItemCheckBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemCheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemcheckbox"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemCheckBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js
var require_MenuItemRadioRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRadioRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemradio"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRadioRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js
var require_MenuListOptionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListOptionRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListOptionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js
var require_MenuListPopupRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListPopupRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListPopupRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuRole.js
var require_MenuRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menu"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menu"
        }
      }],
      type: "structure"
    };
    var _default = MenuRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MeterRole.js
var require_MeterRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MeterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MeterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "meter"
        }
      }],
      type: "structure"
    };
    var _default = MeterRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NavigationRole.js
var require_NavigationRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NavigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NavigationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "navigation"
        }
      }, {
        module: "HTML",
        concept: {
          name: "nav"
        }
      }],
      type: "structure"
    };
    var _default = NavigationRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NoneRole.js
var require_NoneRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NoneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoneRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "none"
        }
      }],
      type: "structure"
    };
    var _default = NoneRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NoteRole.js
var require_NoteRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoteRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "note"
        }
      }],
      type: "structure"
    };
    var _default = NoteRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/OutlineRole.js
var require_OutlineRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/OutlineRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var OutlineRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = OutlineRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ParagraphRole.js
var require_ParagraphRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ParagraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ParagraphRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "p"
        }
      }],
      type: "structure"
    };
    var _default = ParagraphRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js
var require_PopUpButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PopUpButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = PopUpButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PreRole.js
var require_PreRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PreRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PreRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "pre"
        }
      }],
      type: "structure"
    };
    var _default = PreRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PresentationalRole.js
var require_PresentationalRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PresentationalRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "presentation"
        }
      }],
      type: "structure"
    };
    var _default = PresentationalRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js
var require_ProgressIndicatorRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ProgressIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "progressbar"
        }
      }, {
        module: "HTML",
        concept: {
          name: "progress"
        }
      }],
      type: "structure"
    };
    var _default = ProgressIndicatorRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js
var require_RadioButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radio"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "radio"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RadioButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js
var require_RadioGroupRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radiogroup"
        }
      }],
      type: "structure"
    };
    var _default = RadioGroupRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RegionRole.js
var require_RegionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RegionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RegionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "region"
        }
      }],
      type: "structure"
    };
    var _default = RegionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js
var require_RootWebAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RootWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RootWebAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js
var require_RowHeaderRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "rowheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th",
          attributes: [{
            name: "scope",
            value: "row"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RowHeaderRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RowRole.js
var require_RowRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "row"
        }
      }, {
        module: "HTML",
        concept: {
          name: "tr"
        }
      }],
      type: "structure"
    };
    var _default = RowRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RubyRole.js
var require_RubyRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RubyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RubyRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "ruby"
        }
      }],
      type: "structure"
    };
    var _default = RubyRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RulerRole.js
var require_RulerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RulerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RulerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RulerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js
var require_ScrollAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ScrollAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js
var require_ScrollBarRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "scrollbar"
        }
      }],
      type: "widget"
    };
    var _default = ScrollBarRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js
var require_SeamlessWebAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SeamlessWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SeamlessWebAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SearchRole.js
var require_SearchRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SearchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "search"
        }
      }],
      type: "structure"
    };
    var _default = SearchRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js
var require_SearchBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "searchbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "search"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SearchBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SliderRole.js
var require_SliderRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "slider"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "range"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SliderRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js
var require_SliderThumbRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderThumbRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SliderThumbRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js
var require_SpinButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "spinbutton"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "number"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SpinButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js
var require_SpinButtonPartRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonPartRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SpinButtonPartRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SplitterRole.js
var require_SplitterRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SplitterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SplitterRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "separator"
        }
      }],
      type: "widget"
    };
    var _default = SplitterRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/StaticTextRole.js
var require_StaticTextRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/StaticTextRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StaticTextRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = StaticTextRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/StatusRole.js
var require_StatusRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/StatusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StatusRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "status"
        }
      }],
      type: "structure"
    };
    var _default = StatusRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SVGRootRole.js
var require_SVGRootRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SVGRootRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SVGRootRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SVGRootRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SwitchRole.js
var require_SwitchRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SwitchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SwitchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "switch"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SwitchRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabGroupRole.js
var require_TabGroupRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabGroupRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabRole.js
var require_TabRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tab"
        }
      }],
      type: "widget"
    };
    var _default = TabRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js
var require_TableHeaderContainerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableHeaderContainerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = TableHeaderContainerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TableRole.js
var require_TableRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "table"
        }
      }, {
        module: "HTML",
        concept: {
          name: "table"
        }
      }],
      type: "structure"
    };
    var _default = TableRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabListRole.js
var require_TabListRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabListRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabPanelRole.js
var require_TabPanelRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabPanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabPanelRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tabpanel"
        }
      }],
      type: "structure"
    };
    var _default = TabPanelRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TermRole.js
var require_TermRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TermRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "term"
        }
      }],
      type: "structure"
    };
    var _default = TermRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TextAreaRole.js
var require_TextAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TextAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextAreaRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-multiline",
            value: "true"
          }],
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "textarea"
        }
      }],
      type: "widget"
    };
    var _default = TextAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TextFieldRole.js
var require_TextFieldRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TextFieldRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextFieldRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "text"
          }]
        }
      }],
      type: "widget"
    };
    var _default = TextFieldRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TimeRole.js
var require_TimeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "time"
        }
      }],
      type: "structure"
    };
    var _default = TimeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TimerRole.js
var require_TimerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TimerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "timer"
        }
      }],
      type: "structure"
    };
    var _default = TimerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js
var require_ToggleButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToggleButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-pressed"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ToggleButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ToolbarRole.js
var require_ToolbarRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ToolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToolbarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "toolbar"
        }
      }],
      type: "structure"
    };
    var _default = ToolbarRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeRole.js
var require_TreeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tree"
        }
      }],
      type: "widget"
    };
    var _default = TreeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeGridRole.js
var require_TreeGridRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeGridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeGridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treegrid"
        }
      }],
      type: "widget"
    };
    var _default = TreeGridRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeItemRole.js
var require_TreeItemRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treeitem"
        }
      }],
      type: "widget"
    };
    var _default = TreeItemRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js
var require_UserInterfaceTooltipRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UserInterfaceTooltipRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tooltip"
        }
      }],
      type: "structure"
    };
    var _default = UserInterfaceTooltipRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/VideoRole.js
var require_VideoRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/VideoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var VideoRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "video"
        }
      }],
      type: "widget"
    };
    var _default = VideoRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/WebAreaRole.js
var require_WebAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/WebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = WebAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/WindowRole.js
var require_WindowRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/WindowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WindowRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = WindowRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectsMap.js
var require_AXObjectsMap = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AbbrRole = _interopRequireDefault(require_AbbrRole());
    var _AlertDialogRole = _interopRequireDefault(require_AlertDialogRole());
    var _AlertRole = _interopRequireDefault(require_AlertRole());
    var _AnnotationRole = _interopRequireDefault(require_AnnotationRole());
    var _ApplicationRole = _interopRequireDefault(require_ApplicationRole());
    var _ArticleRole = _interopRequireDefault(require_ArticleRole());
    var _AudioRole = _interopRequireDefault(require_AudioRole());
    var _BannerRole = _interopRequireDefault(require_BannerRole());
    var _BlockquoteRole = _interopRequireDefault(require_BlockquoteRole());
    var _BusyIndicatorRole = _interopRequireDefault(require_BusyIndicatorRole());
    var _ButtonRole = _interopRequireDefault(require_ButtonRole());
    var _CanvasRole = _interopRequireDefault(require_CanvasRole());
    var _CaptionRole = _interopRequireDefault(require_CaptionRole());
    var _CellRole = _interopRequireDefault(require_CellRole());
    var _CheckBoxRole = _interopRequireDefault(require_CheckBoxRole());
    var _ColorWellRole = _interopRequireDefault(require_ColorWellRole());
    var _ColumnHeaderRole = _interopRequireDefault(require_ColumnHeaderRole());
    var _ColumnRole = _interopRequireDefault(require_ColumnRole());
    var _ComboBoxRole = _interopRequireDefault(require_ComboBoxRole());
    var _ComplementaryRole = _interopRequireDefault(require_ComplementaryRole());
    var _ContentInfoRole = _interopRequireDefault(require_ContentInfoRole());
    var _DateRole = _interopRequireDefault(require_DateRole());
    var _DateTimeRole = _interopRequireDefault(require_DateTimeRole());
    var _DefinitionRole = _interopRequireDefault(require_DefinitionRole());
    var _DescriptionListDetailRole = _interopRequireDefault(require_DescriptionListDetailRole());
    var _DescriptionListRole = _interopRequireDefault(require_DescriptionListRole());
    var _DescriptionListTermRole = _interopRequireDefault(require_DescriptionListTermRole());
    var _DetailsRole = _interopRequireDefault(require_DetailsRole());
    var _DialogRole = _interopRequireDefault(require_DialogRole());
    var _DirectoryRole = _interopRequireDefault(require_DirectoryRole());
    var _DisclosureTriangleRole = _interopRequireDefault(require_DisclosureTriangleRole());
    var _DivRole = _interopRequireDefault(require_DivRole());
    var _DocumentRole = _interopRequireDefault(require_DocumentRole());
    var _EmbeddedObjectRole = _interopRequireDefault(require_EmbeddedObjectRole());
    var _FeedRole = _interopRequireDefault(require_FeedRole());
    var _FigcaptionRole = _interopRequireDefault(require_FigcaptionRole());
    var _FigureRole = _interopRequireDefault(require_FigureRole());
    var _FooterRole = _interopRequireDefault(require_FooterRole());
    var _FormRole = _interopRequireDefault(require_FormRole());
    var _GridRole = _interopRequireDefault(require_GridRole());
    var _GroupRole = _interopRequireDefault(require_GroupRole());
    var _HeadingRole = _interopRequireDefault(require_HeadingRole());
    var _IframePresentationalRole = _interopRequireDefault(require_IframePresentationalRole());
    var _IframeRole = _interopRequireDefault(require_IframeRole());
    var _IgnoredRole = _interopRequireDefault(require_IgnoredRole());
    var _ImageMapLinkRole = _interopRequireDefault(require_ImageMapLinkRole());
    var _ImageMapRole = _interopRequireDefault(require_ImageMapRole());
    var _ImageRole = _interopRequireDefault(require_ImageRole());
    var _InlineTextBoxRole = _interopRequireDefault(require_InlineTextBoxRole());
    var _InputTimeRole = _interopRequireDefault(require_InputTimeRole());
    var _LabelRole = _interopRequireDefault(require_LabelRole());
    var _LegendRole = _interopRequireDefault(require_LegendRole());
    var _LineBreakRole = _interopRequireDefault(require_LineBreakRole());
    var _LinkRole = _interopRequireDefault(require_LinkRole());
    var _ListBoxOptionRole = _interopRequireDefault(require_ListBoxOptionRole());
    var _ListBoxRole = _interopRequireDefault(require_ListBoxRole());
    var _ListItemRole = _interopRequireDefault(require_ListItemRole());
    var _ListMarkerRole = _interopRequireDefault(require_ListMarkerRole());
    var _ListRole = _interopRequireDefault(require_ListRole());
    var _LogRole = _interopRequireDefault(require_LogRole());
    var _MainRole = _interopRequireDefault(require_MainRole());
    var _MarkRole = _interopRequireDefault(require_MarkRole());
    var _MarqueeRole = _interopRequireDefault(require_MarqueeRole());
    var _MathRole = _interopRequireDefault(require_MathRole());
    var _MenuBarRole = _interopRequireDefault(require_MenuBarRole());
    var _MenuButtonRole = _interopRequireDefault(require_MenuButtonRole());
    var _MenuItemRole = _interopRequireDefault(require_MenuItemRole());
    var _MenuItemCheckBoxRole = _interopRequireDefault(require_MenuItemCheckBoxRole());
    var _MenuItemRadioRole = _interopRequireDefault(require_MenuItemRadioRole());
    var _MenuListOptionRole = _interopRequireDefault(require_MenuListOptionRole());
    var _MenuListPopupRole = _interopRequireDefault(require_MenuListPopupRole());
    var _MenuRole = _interopRequireDefault(require_MenuRole());
    var _MeterRole = _interopRequireDefault(require_MeterRole());
    var _NavigationRole = _interopRequireDefault(require_NavigationRole());
    var _NoneRole = _interopRequireDefault(require_NoneRole());
    var _NoteRole = _interopRequireDefault(require_NoteRole());
    var _OutlineRole = _interopRequireDefault(require_OutlineRole());
    var _ParagraphRole = _interopRequireDefault(require_ParagraphRole());
    var _PopUpButtonRole = _interopRequireDefault(require_PopUpButtonRole());
    var _PreRole = _interopRequireDefault(require_PreRole());
    var _PresentationalRole = _interopRequireDefault(require_PresentationalRole());
    var _ProgressIndicatorRole = _interopRequireDefault(require_ProgressIndicatorRole());
    var _RadioButtonRole = _interopRequireDefault(require_RadioButtonRole());
    var _RadioGroupRole = _interopRequireDefault(require_RadioGroupRole());
    var _RegionRole = _interopRequireDefault(require_RegionRole());
    var _RootWebAreaRole = _interopRequireDefault(require_RootWebAreaRole());
    var _RowHeaderRole = _interopRequireDefault(require_RowHeaderRole());
    var _RowRole = _interopRequireDefault(require_RowRole());
    var _RubyRole = _interopRequireDefault(require_RubyRole());
    var _RulerRole = _interopRequireDefault(require_RulerRole());
    var _ScrollAreaRole = _interopRequireDefault(require_ScrollAreaRole());
    var _ScrollBarRole = _interopRequireDefault(require_ScrollBarRole());
    var _SeamlessWebAreaRole = _interopRequireDefault(require_SeamlessWebAreaRole());
    var _SearchRole = _interopRequireDefault(require_SearchRole());
    var _SearchBoxRole = _interopRequireDefault(require_SearchBoxRole());
    var _SliderRole = _interopRequireDefault(require_SliderRole());
    var _SliderThumbRole = _interopRequireDefault(require_SliderThumbRole());
    var _SpinButtonRole = _interopRequireDefault(require_SpinButtonRole());
    var _SpinButtonPartRole = _interopRequireDefault(require_SpinButtonPartRole());
    var _SplitterRole = _interopRequireDefault(require_SplitterRole());
    var _StaticTextRole = _interopRequireDefault(require_StaticTextRole());
    var _StatusRole = _interopRequireDefault(require_StatusRole());
    var _SVGRootRole = _interopRequireDefault(require_SVGRootRole());
    var _SwitchRole = _interopRequireDefault(require_SwitchRole());
    var _TabGroupRole = _interopRequireDefault(require_TabGroupRole());
    var _TabRole = _interopRequireDefault(require_TabRole());
    var _TableHeaderContainerRole = _interopRequireDefault(require_TableHeaderContainerRole());
    var _TableRole = _interopRequireDefault(require_TableRole());
    var _TabListRole = _interopRequireDefault(require_TabListRole());
    var _TabPanelRole = _interopRequireDefault(require_TabPanelRole());
    var _TermRole = _interopRequireDefault(require_TermRole());
    var _TextAreaRole = _interopRequireDefault(require_TextAreaRole());
    var _TextFieldRole = _interopRequireDefault(require_TextFieldRole());
    var _TimeRole = _interopRequireDefault(require_TimeRole());
    var _TimerRole = _interopRequireDefault(require_TimerRole());
    var _ToggleButtonRole = _interopRequireDefault(require_ToggleButtonRole());
    var _ToolbarRole = _interopRequireDefault(require_ToolbarRole());
    var _TreeRole = _interopRequireDefault(require_TreeRole());
    var _TreeGridRole = _interopRequireDefault(require_TreeGridRole());
    var _TreeItemRole = _interopRequireDefault(require_TreeItemRole());
    var _UserInterfaceTooltipRole = _interopRequireDefault(require_UserInterfaceTooltipRole());
    var _VideoRole = _interopRequireDefault(require_VideoRole());
    var _WebAreaRole = _interopRequireDefault(require_WebAreaRole());
    var _WindowRole = _interopRequireDefault(require_WindowRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err2) {
        _d = true;
        _e = err2;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var AXObjects2 = [["AbbrRole", _AbbrRole.default], ["AlertDialogRole", _AlertDialogRole.default], ["AlertRole", _AlertRole.default], ["AnnotationRole", _AnnotationRole.default], ["ApplicationRole", _ApplicationRole.default], ["ArticleRole", _ArticleRole.default], ["AudioRole", _AudioRole.default], ["BannerRole", _BannerRole.default], ["BlockquoteRole", _BlockquoteRole.default], ["BusyIndicatorRole", _BusyIndicatorRole.default], ["ButtonRole", _ButtonRole.default], ["CanvasRole", _CanvasRole.default], ["CaptionRole", _CaptionRole.default], ["CellRole", _CellRole.default], ["CheckBoxRole", _CheckBoxRole.default], ["ColorWellRole", _ColorWellRole.default], ["ColumnHeaderRole", _ColumnHeaderRole.default], ["ColumnRole", _ColumnRole.default], ["ComboBoxRole", _ComboBoxRole.default], ["ComplementaryRole", _ComplementaryRole.default], ["ContentInfoRole", _ContentInfoRole.default], ["DateRole", _DateRole.default], ["DateTimeRole", _DateTimeRole.default], ["DefinitionRole", _DefinitionRole.default], ["DescriptionListDetailRole", _DescriptionListDetailRole.default], ["DescriptionListRole", _DescriptionListRole.default], ["DescriptionListTermRole", _DescriptionListTermRole.default], ["DetailsRole", _DetailsRole.default], ["DialogRole", _DialogRole.default], ["DirectoryRole", _DirectoryRole.default], ["DisclosureTriangleRole", _DisclosureTriangleRole.default], ["DivRole", _DivRole.default], ["DocumentRole", _DocumentRole.default], ["EmbeddedObjectRole", _EmbeddedObjectRole.default], ["FeedRole", _FeedRole.default], ["FigcaptionRole", _FigcaptionRole.default], ["FigureRole", _FigureRole.default], ["FooterRole", _FooterRole.default], ["FormRole", _FormRole.default], ["GridRole", _GridRole.default], ["GroupRole", _GroupRole.default], ["HeadingRole", _HeadingRole.default], ["IframePresentationalRole", _IframePresentationalRole.default], ["IframeRole", _IframeRole.default], ["IgnoredRole", _IgnoredRole.default], ["ImageMapLinkRole", _ImageMapLinkRole.default], ["ImageMapRole", _ImageMapRole.default], ["ImageRole", _ImageRole.default], ["InlineTextBoxRole", _InlineTextBoxRole.default], ["InputTimeRole", _InputTimeRole.default], ["LabelRole", _LabelRole.default], ["LegendRole", _LegendRole.default], ["LineBreakRole", _LineBreakRole.default], ["LinkRole", _LinkRole.default], ["ListBoxOptionRole", _ListBoxOptionRole.default], ["ListBoxRole", _ListBoxRole.default], ["ListItemRole", _ListItemRole.default], ["ListMarkerRole", _ListMarkerRole.default], ["ListRole", _ListRole.default], ["LogRole", _LogRole.default], ["MainRole", _MainRole.default], ["MarkRole", _MarkRole.default], ["MarqueeRole", _MarqueeRole.default], ["MathRole", _MathRole.default], ["MenuBarRole", _MenuBarRole.default], ["MenuButtonRole", _MenuButtonRole.default], ["MenuItemRole", _MenuItemRole.default], ["MenuItemCheckBoxRole", _MenuItemCheckBoxRole.default], ["MenuItemRadioRole", _MenuItemRadioRole.default], ["MenuListOptionRole", _MenuListOptionRole.default], ["MenuListPopupRole", _MenuListPopupRole.default], ["MenuRole", _MenuRole.default], ["MeterRole", _MeterRole.default], ["NavigationRole", _NavigationRole.default], ["NoneRole", _NoneRole.default], ["NoteRole", _NoteRole.default], ["OutlineRole", _OutlineRole.default], ["ParagraphRole", _ParagraphRole.default], ["PopUpButtonRole", _PopUpButtonRole.default], ["PreRole", _PreRole.default], ["PresentationalRole", _PresentationalRole.default], ["ProgressIndicatorRole", _ProgressIndicatorRole.default], ["RadioButtonRole", _RadioButtonRole.default], ["RadioGroupRole", _RadioGroupRole.default], ["RegionRole", _RegionRole.default], ["RootWebAreaRole", _RootWebAreaRole.default], ["RowHeaderRole", _RowHeaderRole.default], ["RowRole", _RowRole.default], ["RubyRole", _RubyRole.default], ["RulerRole", _RulerRole.default], ["ScrollAreaRole", _ScrollAreaRole.default], ["ScrollBarRole", _ScrollBarRole.default], ["SeamlessWebAreaRole", _SeamlessWebAreaRole.default], ["SearchRole", _SearchRole.default], ["SearchBoxRole", _SearchBoxRole.default], ["SliderRole", _SliderRole.default], ["SliderThumbRole", _SliderThumbRole.default], ["SpinButtonRole", _SpinButtonRole.default], ["SpinButtonPartRole", _SpinButtonPartRole.default], ["SplitterRole", _SplitterRole.default], ["StaticTextRole", _StaticTextRole.default], ["StatusRole", _StatusRole.default], ["SVGRootRole", _SVGRootRole.default], ["SwitchRole", _SwitchRole.default], ["TabGroupRole", _TabGroupRole.default], ["TabRole", _TabRole.default], ["TableHeaderContainerRole", _TableHeaderContainerRole.default], ["TableRole", _TableRole.default], ["TabListRole", _TabListRole.default], ["TabPanelRole", _TabPanelRole.default], ["TermRole", _TermRole.default], ["TextAreaRole", _TextAreaRole.default], ["TextFieldRole", _TextFieldRole.default], ["TimeRole", _TimeRole.default], ["TimerRole", _TimerRole.default], ["ToggleButtonRole", _ToggleButtonRole.default], ["ToolbarRole", _ToolbarRole.default], ["TreeRole", _TreeRole.default], ["TreeGridRole", _TreeGridRole.default], ["TreeItemRole", _TreeItemRole.default], ["UserInterfaceTooltipRole", _UserInterfaceTooltipRole.default], ["VideoRole", _VideoRole.default], ["WebAreaRole", _WebAreaRole.default], ["WindowRole", _WindowRole.default]];
    var AXObjectsMap = {
      entries: function entries() {
        return AXObjects2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjects = AXObjects2; _i < _AXObjects.length; _i++) {
          var _AXObjects$_i = _slicedToArray(_AXObjects[_i], 2), key2 = _AXObjects$_i[0], values = _AXObjects$_i[1];
          fn.call(thisArg, values, key2, AXObjects2);
        }
      },
      get: function get3(key2) {
        var item = AXObjects2.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectsMap.get(key2);
      },
      keys: function keys() {
        return AXObjects2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjects2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectsMap, AXObjectsMap.entries());
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectElementMap.js
var require_AXObjectElementMap = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err2) {
        _d = true;
        _e = err2;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it2) {
        if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it2) o = it2;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err2;
      return { s: function s() {
        it2 = it2.call(o);
      }, n: function n2() {
        var step = it2.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err2 = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it2.return != null) it2.return();
        } finally {
          if (didErr) throw err2;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
                  return key2 === name;
                });
                if (index === -1) {
                  AXObjectElements.push([name, []]);
                  index = AXObjectElements.length - 1;
                }
                AXObjectElements[index][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectElementMap = {
      entries: function entries() {
        return AXObjectElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjectElements = AXObjectElements; _i < _AXObjectElements.length; _i++) {
          var _AXObjectElements$_i = _slicedToArray(_AXObjectElements[_i], 2), key2 = _AXObjectElements$_i[0], values = _AXObjectElements$_i[1];
          fn.call(thisArg, values, key2, AXObjectElements);
        }
      },
      get: function get3(key2) {
        var item = AXObjectElements.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectElementMap.get(key2);
      },
      keys: function keys() {
        return AXObjectElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjectElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectElementMap, AXObjectElementMap.entries());
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectRoleMap.js
var require_AXObjectRoleMap = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err2) {
        _d = true;
        _e = err2;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it2) {
        if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it2) o = it2;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err2;
      return { s: function s() {
        it2 = it2.call(o);
      }, n: function n2() {
        var step = it2.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err2 = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it2.return != null) it2.return();
        } finally {
          if (didErr) throw err2;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectRoleElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "ARIA") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectRoleElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
                  return key2 === name;
                });
                if (index === -1) {
                  AXObjectRoleElements.push([name, []]);
                  index = AXObjectRoleElements.length - 1;
                }
                AXObjectRoleElements[index][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectRoleMap = {
      entries: function entries() {
        return AXObjectRoleElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjectRoleElements = AXObjectRoleElements; _i < _AXObjectRoleElements.length; _i++) {
          var _AXObjectRoleElements2 = _slicedToArray(_AXObjectRoleElements[_i], 2), key2 = _AXObjectRoleElements2[0], values = _AXObjectRoleElements2[1];
          fn.call(thisArg, values, key2, AXObjectRoleElements);
        }
      },
      get: function get3(key2) {
        var item = AXObjectRoleElements.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectRoleMap.get(key2);
      },
      keys: function keys() {
        return AXObjectRoleElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjectRoleElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/elementAXObjectMap.js
var require_elementAXObjectMap = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/elementAXObjectMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err2) {
        _d = true;
        _e = err2;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it2) {
        if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it2) o = it2;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n2() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err2;
      return { s: function s() {
        it2 = it2.call(o);
      }, n: function n2() {
        var step = it2.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err2 = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it2.return != null) it2.return();
        } finally {
          if (didErr) throw err2;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var elementAXObjects3 = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept != null) {
                var conceptStr = JSON.stringify(concept);
                var axObjects;
                var index = 0;
                for (; index < elementAXObjects3.length; index++) {
                  var key2 = elementAXObjects3[index][0];
                  if (JSON.stringify(key2) === conceptStr) {
                    axObjects = elementAXObjects3[index][1];
                    break;
                  }
                }
                if (!Array.isArray(axObjects)) {
                  axObjects = [];
                }
                var loc = axObjects.findIndex(function(item) {
                  return item === name;
                });
                if (loc === -1) {
                  axObjects.push(name);
                }
                if (index < elementAXObjects3.length) {
                  elementAXObjects3.splice(index, 1, [concept, axObjects]);
                } else {
                  elementAXObjects3.push([concept, axObjects]);
                }
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    var _loop;
    function deepAxObjectModelRelationshipConceptAttributeCheck(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length != b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (b[i].name !== a[i].name || b[i].value !== a[i].value) {
            return false;
          }
        }
      }
      return true;
    }
    var elementAXObjectMap = {
      entries: function entries() {
        return elementAXObjects3;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _elementAXObjects = elementAXObjects3; _i < _elementAXObjects.length; _i++) {
          var _elementAXObjects$_i = _slicedToArray(_elementAXObjects[_i], 2), key2 = _elementAXObjects$_i[0], values = _elementAXObjects$_i[1];
          fn.call(thisArg, values, key2, elementAXObjects3);
        }
      },
      get: function get3(key2) {
        var item = elementAXObjects3.find(function(tuple) {
          return key2.name === tuple[0].name && deepAxObjectModelRelationshipConceptAttributeCheck(key2.attributes, tuple[0].attributes);
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!elementAXObjectMap.get(key2);
      },
      keys: function keys() {
        return elementAXObjects3.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return elementAXObjects3.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.elementAXObjects = exports.AXObjects = exports.AXObjectRoles = exports.AXObjectElements = void 0;
    var _AXObjectElementMap = _interopRequireDefault(require_AXObjectElementMap());
    var _AXObjectRoleMap = _interopRequireDefault(require_AXObjectRoleMap());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _elementAXObjectMap = _interopRequireDefault(require_elementAXObjectMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AXObjectElements = _AXObjectElementMap.default;
    exports.AXObjectElements = AXObjectElements;
    var AXObjectRoles2 = _AXObjectRoleMap.default;
    exports.AXObjectRoles = AXObjectRoles2;
    var AXObjects2 = _AXObjectsMap.default;
    exports.AXObjects = AXObjects2;
    var elementAXObjects3 = _elementAXObjectMap.default;
    exports.elementAXObjects = elementAXObjects3;
  }
});

// node_modules/.deno/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/.deno/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.resolveURI = factory());
    })(exports, (function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash2) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash: hash2,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i = 1; i < pointer; i++) {
          path += "/" + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            // fall through
            case 2:
              url.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            // fall through
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            // fall through
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    }));
  }
});

// node_modules/.deno/esbuild-wasm@0.27.0/node_modules/esbuild-wasm/esm/browser.min.js
var Je = Object.defineProperty;
var Ye = (e2, t) => {
  for (var n2 in t) Je(e2, n2, { get: t[n2], enumerable: true });
};
var Se = {};
Ye(Se, { analyzeMetafile: () => gt, analyzeMetafileSync: () => ht, build: () => ut, buildSync: () => pt, context: () => ct, default: () => Rt, formatMessages: () => dt, formatMessagesSync: () => yt, initialize: () => wt, stop: () => bt, transform: () => ft, transformSync: () => mt, version: () => at });
function Me(e2) {
  let t = (i) => {
    if (i === null) n2.write8(0);
    else if (typeof i == "boolean") n2.write8(1), n2.write8(+i);
    else if (typeof i == "number") n2.write8(2), n2.write32(i | 0);
    else if (typeof i == "string") n2.write8(3), n2.write(Z(i));
    else if (i instanceof Uint8Array) n2.write8(4), n2.write(i);
    else if (i instanceof Array) {
      n2.write8(5), n2.write32(i.length);
      for (let u of i) t(u);
    } else {
      let u = Object.keys(i);
      n2.write8(6), n2.write32(u.length);
      for (let l of u) n2.write(Z(l)), t(i[l]);
    }
  }, n2 = new ye();
  return n2.write32(0), n2.write32(e2.id << 1 | +!e2.isRequest), t(e2.value), $e(n2.buf, n2.len - 4, 0), n2.buf.subarray(0, n2.len);
}
function Ae(e2) {
  let t = () => {
    switch (n2.read8()) {
      case 0:
        return null;
      case 1:
        return !!n2.read8();
      case 2:
        return n2.read32();
      case 3:
        return se(n2.read());
      case 4:
        return n2.read();
      case 5: {
        let g = n2.read32(), s = [];
        for (let p = 0; p < g; p++) s.push(t());
        return s;
      }
      case 6: {
        let g = n2.read32(), s = {};
        for (let p = 0; p < g; p++) s[se(n2.read())] = t();
        return s;
      }
      default:
        throw new Error("Invalid packet");
    }
  }, n2 = new ye(e2), i = n2.read32(), u = (i & 1) === 0;
  i >>>= 1;
  let l = t();
  if (n2.ptr !== e2.length) throw new Error("Invalid packet");
  return { id: i, isRequest: u, value: l };
}
var ye = class {
  constructor(t = new Uint8Array(1024)) {
    this.buf = t;
    this.len = 0;
    this.ptr = 0;
  }
  _write(t) {
    if (this.len + t > this.buf.length) {
      let n2 = new Uint8Array((this.len + t) * 2);
      n2.set(this.buf), this.buf = n2;
    }
    return this.len += t, this.len - t;
  }
  write8(t) {
    let n2 = this._write(1);
    this.buf[n2] = t;
  }
  write32(t) {
    let n2 = this._write(4);
    $e(this.buf, t, n2);
  }
  write(t) {
    let n2 = this._write(4 + t.length);
    $e(this.buf, t.length, n2), this.buf.set(t, n2 + 4);
  }
  _read(t) {
    if (this.ptr + t > this.buf.length) throw new Error("Invalid packet");
    return this.ptr += t, this.ptr - t;
  }
  read8() {
    return this.buf[this._read(1)];
  }
  read32() {
    return Ce(this.buf, this._read(4));
  }
  read() {
    let t = this.read32(), n2 = new Uint8Array(t), i = this._read(n2.length);
    return n2.set(this.buf.subarray(i, i + t)), n2;
  }
};
var Z;
var se;
var ke;
if (typeof TextEncoder != "undefined" && typeof TextDecoder != "undefined") {
  let e2 = new TextEncoder(), t = new TextDecoder();
  Z = (n2) => e2.encode(n2), se = (n2) => t.decode(n2), ke = 'new TextEncoder().encode("")';
} else if (typeof Buffer != "undefined") Z = (e2) => Buffer.from(e2), se = (e2) => {
  let { buffer: t, byteOffset: n2, byteLength: i } = e2;
  return Buffer.from(t, n2, i).toString();
}, ke = 'Buffer.from("")';
else throw new Error("No UTF-8 codec found");
if (!(Z("") instanceof Uint8Array)) throw new Error(`Invariant violation: "${ke} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
function Ce(e2, t) {
  return e2[t++] | e2[t++] << 8 | e2[t++] << 16 | e2[t++] << 24;
}
function $e(e2, t, n2) {
  e2[n2++] = t, e2[n2++] = t >> 8, e2[n2++] = t >> 16, e2[n2++] = t >> 24;
}
var _ = JSON.stringify;
var Fe = "warning";
var Pe = "silent";
function fe(e2, t) {
  let n2 = [];
  for (let i of e2) {
    if (Y(i, t), i.indexOf(",") >= 0) throw new Error(`Invalid ${t}: ${i}`);
    n2.push(i);
  }
  return n2.join(",");
}
var we = () => null;
var I = (e2) => typeof e2 == "boolean" ? null : "a boolean";
var y = (e2) => typeof e2 == "string" ? null : "a string";
var ve = (e2) => e2 instanceof RegExp ? null : "a RegExp object";
var ae = (e2) => typeof e2 == "number" && e2 === (e2 | 0) ? null : "an integer";
var Qe = (e2) => typeof e2 == "number" && e2 === (e2 | 0) && e2 >= 0 && e2 <= 65535 ? null : "a valid port number";
var Be = (e2) => typeof e2 == "function" ? null : "a function";
var ie = (e2) => Array.isArray(e2) ? null : "an array";
var G = (e2) => Array.isArray(e2) && e2.every((t) => typeof t == "string") ? null : "an array of strings";
var Q = (e2) => typeof e2 == "object" && e2 !== null && !Array.isArray(e2) ? null : "an object";
var He = (e2) => typeof e2 == "object" && e2 !== null ? null : "an array or an object";
var Xe = (e2) => e2 instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
var Te = (e2) => typeof e2 == "object" && !Array.isArray(e2) ? null : "an object or null";
var Ue = (e2) => typeof e2 == "string" || typeof e2 == "boolean" ? null : "a string or a boolean";
var Ze = (e2) => typeof e2 == "string" || typeof e2 == "object" && e2 !== null && !Array.isArray(e2) ? null : "a string or an object";
var je = (e2) => typeof e2 == "string" || Array.isArray(e2) && e2.every((t) => typeof t == "string") ? null : "a string or an array of strings";
var Le = (e2) => typeof e2 == "string" || e2 instanceof Uint8Array ? null : "a string or a Uint8Array";
var et = (e2) => typeof e2 == "string" || e2 instanceof URL ? null : "a string or a URL";
function r(e2, t, n2, i) {
  let u = e2[n2];
  if (t[n2 + ""] = true, u === void 0) return;
  let l = i(u);
  if (l !== null) throw new Error(`${_(n2)} must be ${l}`);
  return u;
}
function K(e2, t, n2) {
  for (let i in e2) if (!(i in t)) throw new Error(`Invalid option ${n2}: ${_(i)}`);
}
function Ne(e2) {
  let t = /* @__PURE__ */ Object.create(null), n2 = r(e2, t, "wasmURL", et), i = r(e2, t, "wasmModule", Xe), u = r(e2, t, "worker", I);
  return K(e2, t, "in initialize() call"), { wasmURL: n2, wasmModule: i, worker: u };
}
function qe(e2) {
  let t;
  if (e2 !== void 0) {
    t = /* @__PURE__ */ Object.create(null);
    for (let n2 in e2) {
      let i = e2[n2];
      if (typeof i == "string" || i === false) t[n2] = i;
      else throw new Error(`Expected ${_(n2)} in mangle cache to map to either a string or false`);
    }
  }
  return t;
}
function xe(e2, t, n2, i, u) {
  let l = r(t, n2, "color", I), g = r(t, n2, "logLevel", y), s = r(t, n2, "logLimit", ae);
  l !== void 0 ? e2.push(`--color=${l}`) : i && e2.push("--color=true"), e2.push(`--log-level=${g || u}`), e2.push(`--log-limit=${s || 0}`);
}
function Y(e2, t, n2) {
  if (typeof e2 != "string") throw new Error(`Expected value for ${t}${n2 !== void 0 ? " " + _(n2) : ""} to be a string, got ${typeof e2} instead`);
  return e2;
}
function Ie(e2, t, n2) {
  let i = r(t, n2, "legalComments", y), u = r(t, n2, "sourceRoot", y), l = r(t, n2, "sourcesContent", I), g = r(t, n2, "target", je), s = r(t, n2, "format", y), p = r(t, n2, "globalName", y), B2 = r(t, n2, "mangleProps", ve), F = r(t, n2, "reserveProps", ve), w2 = r(t, n2, "mangleQuoted", I), U = r(t, n2, "minify", I), T = r(t, n2, "minifySyntax", I), j = r(t, n2, "minifyWhitespace", I), L = r(t, n2, "minifyIdentifiers", I), S = r(t, n2, "lineLimit", ae), z = r(t, n2, "drop", G), V = r(t, n2, "dropLabels", G), v = r(t, n2, "charset", y), d = r(t, n2, "treeShaking", I), f = r(t, n2, "ignoreAnnotations", I), o = r(t, n2, "jsx", y), R = r(t, n2, "jsxFactory", y), O = r(t, n2, "jsxFragment", y), $ = r(t, n2, "jsxImportSource", y), E2 = r(t, n2, "jsxDev", I), a = r(t, n2, "jsxSideEffects", I), c = r(t, n2, "define", Q), b = r(t, n2, "logOverride", Q), M = r(t, n2, "supported", Q), P = r(t, n2, "pure", G), k = r(t, n2, "keepNames", I), x2 = r(t, n2, "platform", y), C2 = r(t, n2, "tsconfigRaw", Ze), q = r(t, n2, "absPaths", G);
  if (i && e2.push(`--legal-comments=${i}`), u !== void 0 && e2.push(`--source-root=${u}`), l !== void 0 && e2.push(`--sources-content=${l}`), g && e2.push(`--target=${fe(Array.isArray(g) ? g : [g], "target")}`), s && e2.push(`--format=${s}`), p && e2.push(`--global-name=${p}`), x2 && e2.push(`--platform=${x2}`), C2 && e2.push(`--tsconfig-raw=${typeof C2 == "string" ? C2 : JSON.stringify(C2)}`), U && e2.push("--minify"), T && e2.push("--minify-syntax"), j && e2.push("--minify-whitespace"), L && e2.push("--minify-identifiers"), S && e2.push(`--line-limit=${S}`), v && e2.push(`--charset=${v}`), d !== void 0 && e2.push(`--tree-shaking=${d}`), f && e2.push("--ignore-annotations"), z) for (let m of z) e2.push(`--drop:${Y(m, "drop")}`);
  if (V && e2.push(`--drop-labels=${fe(V, "drop label")}`), q && e2.push(`--abs-paths=${fe(q, "abs paths")}`), B2 && e2.push(`--mangle-props=${Re(B2)}`), F && e2.push(`--reserve-props=${Re(F)}`), w2 !== void 0 && e2.push(`--mangle-quoted=${w2}`), o && e2.push(`--jsx=${o}`), R && e2.push(`--jsx-factory=${R}`), O && e2.push(`--jsx-fragment=${O}`), $ && e2.push(`--jsx-import-source=${$}`), E2 && e2.push("--jsx-dev"), a && e2.push("--jsx-side-effects"), c) for (let m in c) {
    if (m.indexOf("=") >= 0) throw new Error(`Invalid define: ${m}`);
    e2.push(`--define:${m}=${Y(c[m], "define", m)}`);
  }
  if (b) for (let m in b) {
    if (m.indexOf("=") >= 0) throw new Error(`Invalid log override: ${m}`);
    e2.push(`--log-override:${m}=${Y(b[m], "log override", m)}`);
  }
  if (M) for (let m in M) {
    if (m.indexOf("=") >= 0) throw new Error(`Invalid supported: ${m}`);
    let A2 = M[m];
    if (typeof A2 != "boolean") throw new Error(`Expected value for supported ${_(m)} to be a boolean, got ${typeof A2} instead`);
    e2.push(`--supported:${m}=${A2}`);
  }
  if (P) for (let m of P) e2.push(`--pure:${Y(m, "pure")}`);
  k && e2.push("--keep-names");
}
function tt(e2, t, n2, i, u) {
  var te;
  let l = [], g = [], s = /* @__PURE__ */ Object.create(null), p = null, B2 = null;
  xe(l, t, s, n2, i), Ie(l, t, s);
  let F = r(t, s, "sourcemap", Ue), w2 = r(t, s, "bundle", I), U = r(t, s, "splitting", I), T = r(t, s, "preserveSymlinks", I), j = r(t, s, "metafile", I), L = r(t, s, "outfile", y), S = r(t, s, "outdir", y), z = r(t, s, "outbase", y), V = r(t, s, "tsconfig", y), v = r(t, s, "resolveExtensions", G), d = r(t, s, "nodePaths", G), f = r(t, s, "mainFields", G), o = r(t, s, "conditions", G), R = r(t, s, "external", G), O = r(t, s, "packages", y), $ = r(t, s, "alias", Q), E2 = r(t, s, "loader", Q), a = r(t, s, "outExtension", Q), c = r(t, s, "publicPath", y), b = r(t, s, "entryNames", y), M = r(t, s, "chunkNames", y), P = r(t, s, "assetNames", y), k = r(t, s, "inject", G), x2 = r(t, s, "banner", Q), C2 = r(t, s, "footer", Q), q = r(t, s, "entryPoints", He), m = r(t, s, "absWorkingDir", y), A2 = r(t, s, "stdin", Q), N = (te = r(t, s, "write", I)) != null ? te : u, D = r(t, s, "allowOverwrite", I), J = r(t, s, "mangleCache", Q);
  if (s.plugins = true, K(t, s, `in ${e2}() call`), F && l.push(`--sourcemap${F === true ? "" : `=${F}`}`), w2 && l.push("--bundle"), D && l.push("--allow-overwrite"), U && l.push("--splitting"), T && l.push("--preserve-symlinks"), j && l.push("--metafile"), L && l.push(`--outfile=${L}`), S && l.push(`--outdir=${S}`), z && l.push(`--outbase=${z}`), V && l.push(`--tsconfig=${V}`), O && l.push(`--packages=${O}`), v && l.push(`--resolve-extensions=${fe(v, "resolve extension")}`), c && l.push(`--public-path=${c}`), b && l.push(`--entry-names=${b}`), M && l.push(`--chunk-names=${M}`), P && l.push(`--asset-names=${P}`), f && l.push(`--main-fields=${fe(f, "main field")}`), o && l.push(`--conditions=${fe(o, "condition")}`), R) for (let h of R) l.push(`--external:${Y(h, "external")}`);
  if ($) for (let h in $) {
    if (h.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${h}`);
    l.push(`--alias:${h}=${Y($[h], "alias", h)}`);
  }
  if (x2) for (let h in x2) {
    if (h.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${h}`);
    l.push(`--banner:${h}=${Y(x2[h], "banner", h)}`);
  }
  if (C2) for (let h in C2) {
    if (h.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${h}`);
    l.push(`--footer:${h}=${Y(C2[h], "footer", h)}`);
  }
  if (k) for (let h of k) l.push(`--inject:${Y(h, "inject")}`);
  if (E2) for (let h in E2) {
    if (h.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${h}`);
    l.push(`--loader:${h}=${Y(E2[h], "loader", h)}`);
  }
  if (a) for (let h in a) {
    if (h.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${h}`);
    l.push(`--out-extension:${h}=${Y(a[h], "out extension", h)}`);
  }
  if (q) if (Array.isArray(q)) for (let h = 0, ne = q.length; h < ne; h++) {
    let H = q[h];
    if (typeof H == "object" && H !== null) {
      let ee = /* @__PURE__ */ Object.create(null), re = r(H, ee, "in", y), X = r(H, ee, "out", y);
      if (K(H, ee, "in entry point at index " + h), re === void 0) throw new Error('Missing property "in" for entry point at index ' + h);
      if (X === void 0) throw new Error('Missing property "out" for entry point at index ' + h);
      g.push([X, re]);
    } else g.push(["", Y(H, "entry point at index " + h)]);
  }
  else for (let h in q) g.push([h, Y(q[h], "entry point", h)]);
  if (A2) {
    let h = /* @__PURE__ */ Object.create(null), ne = r(A2, h, "contents", Le), H = r(A2, h, "resolveDir", y), ee = r(A2, h, "sourcefile", y), re = r(A2, h, "loader", y);
    K(A2, h, 'in "stdin" object'), ee && l.push(`--sourcefile=${ee}`), re && l.push(`--loader=${re}`), H && (B2 = H), typeof ne == "string" ? p = Z(ne) : ne instanceof Uint8Array && (p = ne);
  }
  let W = [];
  if (d) for (let h of d) h += "", W.push(h);
  return { entries: g, flags: l, write: N, stdinContents: p, stdinResolveDir: B2, absWorkingDir: m, nodePaths: W, mangleCache: qe(J) };
}
function nt(e2, t, n2, i) {
  let u = [], l = /* @__PURE__ */ Object.create(null);
  xe(u, t, l, n2, i), Ie(u, t, l);
  let g = r(t, l, "sourcemap", Ue), s = r(t, l, "sourcefile", y), p = r(t, l, "loader", y), B2 = r(t, l, "banner", y), F = r(t, l, "footer", y), w2 = r(t, l, "mangleCache", Q);
  return K(t, l, `in ${e2}() call`), g && u.push(`--sourcemap=${g === true ? "external" : g}`), s && u.push(`--sourcefile=${s}`), p && u.push(`--loader=${p}`), B2 && u.push(`--banner=${B2}`), F && u.push(`--footer=${F}`), { flags: u, mangleCache: qe(w2) };
}
function We(e2) {
  let t = {}, n2 = { didClose: false, reason: "" }, i = {}, u = 0, l = 0, g = new Uint8Array(16 * 1024), s = 0, p = (v) => {
    let d = s + v.length;
    if (d > g.length) {
      let o = new Uint8Array(d * 2);
      o.set(g), g = o;
    }
    g.set(v, s), s += v.length;
    let f = 0;
    for (; f + 4 <= s; ) {
      let o = Ce(g, f);
      if (f + 4 + o > s) break;
      f += 4, j(g.subarray(f, f + o)), f += o;
    }
    f > 0 && (g.copyWithin(0, f, s), s -= f);
  }, B2 = (v) => {
    n2.didClose = true, v && (n2.reason = ": " + (v.message || v));
    let d = "The service was stopped" + n2.reason;
    for (let f in i) i[f](d, null);
    i = {};
  }, F = (v, d, f) => {
    if (n2.didClose) return f("The service is no longer running" + n2.reason, null);
    let o = u++;
    i[o] = (R, O) => {
      try {
        f(R, O);
      } finally {
        v && v.unref();
      }
    }, v && v.ref(), e2.writeToStdin(Me({ id: o, isRequest: true, value: d }));
  }, w2 = (v, d) => {
    if (n2.didClose) throw new Error("The service is no longer running" + n2.reason);
    e2.writeToStdin(Me({ id: v, isRequest: false, value: d }));
  }, U = async (v, d) => {
    try {
      if (d.command === "ping") {
        w2(v, {});
        return;
      }
      if (typeof d.key == "number") {
        let f = t[d.key];
        if (!f) return;
        let o = f[d.command];
        if (o) {
          await o(v, d);
          return;
        }
      }
      throw new Error("Invalid command: " + d.command);
    } catch (f) {
      let o = [oe(f, e2, null, void 0, "")];
      try {
        w2(v, { errors: o });
      } catch (R) {
      }
    }
  }, T = true, j = (v) => {
    if (T) {
      T = false;
      let f = String.fromCharCode(...v);
      if (f !== "0.27.0") throw new Error(`Cannot start service: Host version "0.27.0" does not match binary version ${_(f)}`);
      return;
    }
    let d = Ae(v);
    if (d.isRequest) U(d.id, d.value);
    else {
      let f = i[d.id];
      delete i[d.id], d.value.error ? f(d.value.error, {}) : f(null, d.value);
    }
  };
  return { readFromStdout: p, afterClose: B2, service: { buildOrContext: ({ callName: v, refs: d, options: f, isTTY: o, defaultWD: R, callback: O }) => {
    let $ = 0, E2 = l++, a = {}, c = { ref() {
      ++$ === 1 && d && d.ref();
    }, unref() {
      --$ === 0 && (delete t[E2], d && d.unref());
    } };
    t[E2] = a, c.ref(), rt(v, E2, F, w2, c, e2, a, f, o, R, (b, M) => {
      try {
        O(b, M);
      } finally {
        c.unref();
      }
    });
  }, transform: ({ callName: v, refs: d, input: f, options: o, isTTY: R, fs: O, callback: $ }) => {
    let E2 = ze(), a = (c) => {
      try {
        if (typeof f != "string" && !(f instanceof Uint8Array)) throw new Error('The input to "transform" must be a string or a Uint8Array');
        let { flags: b, mangleCache: M } = nt(v, o, R, Pe), P = { command: "transform", flags: b, inputFS: c !== null, input: c !== null ? Z(c) : typeof f == "string" ? Z(f) : f };
        M && (P.mangleCache = M), F(d, P, (k, x2) => {
          if (k) return $(new Error(k), null);
          let C2 = de(x2.errors, E2), q = de(x2.warnings, E2), m = 1, A2 = () => {
            if (--m === 0) {
              let N = { warnings: q, code: x2.code, map: x2.map, mangleCache: void 0, legalComments: void 0 };
              "legalComments" in x2 && (N.legalComments = x2 == null ? void 0 : x2.legalComments), x2.mangleCache && (N.mangleCache = x2 == null ? void 0 : x2.mangleCache), $(null, N);
            }
          };
          if (C2.length > 0) return $(pe("Transform failed", C2, q), null);
          x2.codeFS && (m++, O.readFile(x2.code, (N, D) => {
            N !== null ? $(N, null) : (x2.code = D, A2());
          })), x2.mapFS && (m++, O.readFile(x2.map, (N, D) => {
            N !== null ? $(N, null) : (x2.map = D, A2());
          })), A2();
        });
      } catch (b) {
        let M = [];
        try {
          xe(M, o, {}, R, Pe);
        } catch (k) {
        }
        let P = oe(b, e2, E2, void 0, "");
        F(d, { command: "error", flags: M, error: P }, () => {
          P.detail = E2.load(P.detail), $(pe("Transform failed", [P], []), null);
        });
      }
    };
    if ((typeof f == "string" || f instanceof Uint8Array) && f.length > 1024 * 1024) {
      let c = a;
      a = () => O.writeFile(f, c);
    }
    a(null);
  }, formatMessages: ({ callName: v, refs: d, messages: f, options: o, callback: R }) => {
    if (!o) throw new Error(`Missing second argument in ${v}() call`);
    let O = {}, $ = r(o, O, "kind", y), E2 = r(o, O, "color", I), a = r(o, O, "terminalWidth", ae);
    if (K(o, O, `in ${v}() call`), $ === void 0) throw new Error(`Missing "kind" in ${v}() call`);
    if ($ !== "error" && $ !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${v}() call`);
    let c = { command: "format-msgs", messages: le(f, "messages", null, "", a), isWarning: $ === "warning" };
    E2 !== void 0 && (c.color = E2), a !== void 0 && (c.terminalWidth = a), F(d, c, (b, M) => {
      if (b) return R(new Error(b), null);
      R(null, M.messages);
    });
  }, analyzeMetafile: ({ callName: v, refs: d, metafile: f, options: o, callback: R }) => {
    o === void 0 && (o = {});
    let O = {}, $ = r(o, O, "color", I), E2 = r(o, O, "verbose", I);
    K(o, O, `in ${v}() call`);
    let a = { command: "analyze-metafile", metafile: f };
    $ !== void 0 && (a.color = $), E2 !== void 0 && (a.verbose = E2), F(d, a, (c, b) => {
      if (c) return R(new Error(c), null);
      R(null, b.result);
    });
  } } };
}
function rt(e2, t, n2, i, u, l, g, s, p, B2, F) {
  let w2 = ze(), U = e2 === "context", T = (S, z) => {
    let V = [];
    try {
      xe(V, s, {}, p, Fe);
    } catch (d) {
    }
    let v = oe(S, l, w2, void 0, z);
    n2(u, { command: "error", flags: V, error: v }, () => {
      v.detail = w2.load(v.detail), F(pe(U ? "Context failed" : "Build failed", [v], []), null);
    });
  }, j;
  if (typeof s == "object") {
    let S = s.plugins;
    if (S !== void 0) {
      if (!Array.isArray(S)) return T(new Error('"plugins" must be an array'), "");
      j = S;
    }
  }
  if (j && j.length > 0) {
    if (l.isSync) return T(new Error("Cannot use plugins in synchronous API calls"), "");
    it(t, n2, i, u, l, g, s, j, w2).then((S) => {
      if (!S.ok) return T(S.error, S.pluginName);
      try {
        L(S.requestPlugins, S.runOnEndCallbacks, S.scheduleOnDisposeCallbacks);
      } catch (z) {
        T(z, "");
      }
    }, (S) => T(S, ""));
    return;
  }
  try {
    L(null, (S, z) => z([], []), () => {
    });
  } catch (S) {
    T(S, "");
  }
  function L(S, z, V) {
    let v = l.hasFS, { entries: d, flags: f, write: o, stdinContents: R, stdinResolveDir: O, absWorkingDir: $, nodePaths: E2, mangleCache: a } = tt(e2, s, p, Fe, v);
    if (o && !l.hasFS) throw new Error('The "write" option is unavailable in this environment');
    let c = { command: "build", key: t, entries: d, flags: f, write: o, stdinContents: R, stdinResolveDir: O, absWorkingDir: $ || B2, nodePaths: E2, context: U };
    S && (c.plugins = S), a && (c.mangleCache = a);
    let b = (k, x2) => {
      let C2 = { errors: de(k.errors, w2), warnings: de(k.warnings, w2), outputFiles: void 0, metafile: void 0, mangleCache: void 0 }, q = C2.errors.slice(), m = C2.warnings.slice();
      k.outputFiles && (C2.outputFiles = k.outputFiles.map(st)), k.metafile && (C2.metafile = JSON.parse(k.metafile)), k.mangleCache && (C2.mangleCache = k.mangleCache), k.writeToStdout !== void 0 && console.log(se(k.writeToStdout).replace(/\n$/, "")), z(C2, (A2, N) => {
        if (q.length > 0 || A2.length > 0) {
          let D = pe("Build failed", q.concat(A2), m.concat(N));
          return x2(D, null, A2, N);
        }
        x2(null, C2, A2, N);
      });
    }, M, P;
    U && (g["on-end"] = (k, x2) => new Promise((C2) => {
      b(x2, (q, m, A2, N) => {
        let D = { errors: A2, warnings: N };
        P && P(q, m), M = void 0, P = void 0, i(k, D), C2();
      });
    })), n2(u, c, (k, x2) => {
      if (k) return F(new Error(k), null);
      if (!U) return b(x2, (m, A2) => (V(), F(m, A2)));
      if (x2.errors.length > 0) return F(pe("Context failed", x2.errors, x2.warnings), null);
      let C2 = false, q = { rebuild: () => (M || (M = new Promise((m, A2) => {
        let N;
        P = (J, W) => {
          N || (N = () => J ? A2(J) : m(W));
        };
        let D = () => {
          n2(u, { command: "rebuild", key: t }, (W, te) => {
            W ? A2(new Error(W)) : N ? N() : D();
          });
        };
        D();
      })), M), watch: (m = {}) => new Promise((A2, N) => {
        if (!l.hasFS) throw new Error('Cannot use the "watch" API in this environment');
        let D = {}, J = r(m, D, "delay", ae);
        K(m, D, "in watch() call");
        let W = { command: "watch", key: t };
        J && (W.delay = J), n2(u, W, (te) => {
          te ? N(new Error(te)) : A2(void 0);
        });
      }), serve: (m = {}) => new Promise((A2, N) => {
        if (!l.hasFS) throw new Error('Cannot use the "serve" API in this environment');
        let D = {}, J = r(m, D, "port", Qe), W = r(m, D, "host", y), te = r(m, D, "servedir", y), h = r(m, D, "keyfile", y), ne = r(m, D, "certfile", y), H = r(m, D, "fallback", y), ee = r(m, D, "cors", Q), re = r(m, D, "onRequest", Be);
        K(m, D, "in serve() call");
        let X = { command: "serve", key: t, onRequest: !!re };
        if (J !== void 0 && (X.port = J), W !== void 0 && (X.host = W), te !== void 0 && (X.servedir = te), h !== void 0 && (X.keyfile = h), ne !== void 0 && (X.certfile = ne), H !== void 0 && (X.fallback = H), ee) {
          let ge = {}, ce = r(ee, ge, "origin", je);
          K(ee, ge, 'on "cors" object'), Array.isArray(ce) ? X.corsOrigin = ce : ce !== void 0 && (X.corsOrigin = [ce]);
        }
        n2(u, X, (ge, ce) => {
          if (ge) return N(new Error(ge));
          re && (g["serve-request"] = (_e, Ve) => {
            re(Ve.args), i(_e, {});
          }), A2(ce);
        });
      }), cancel: () => new Promise((m) => {
        if (C2) return m();
        n2(u, { command: "cancel", key: t }, () => {
          m();
        });
      }), dispose: () => new Promise((m) => {
        if (C2) return m();
        C2 = true, n2(u, { command: "dispose", key: t }, () => {
          m(), V(), u.unref();
        });
      }) };
      u.ref(), F(null, q);
    });
  }
}
var it = async (e2, t, n2, i, u, l, g, s, p) => {
  let B2 = [], F = [], w2 = {}, U = {}, T = [], j = 0, L = 0, S = [], z = false;
  s = [...s];
  for (let d of s) {
    let f = {};
    if (typeof d != "object") throw new Error(`Plugin at index ${L} must be an object`);
    let o = r(d, f, "name", y);
    if (typeof o != "string" || o === "") throw new Error(`Plugin at index ${L} is missing a name`);
    try {
      let R = r(d, f, "setup", Be);
      if (typeof R != "function") throw new Error("Plugin is missing a setup function");
      K(d, f, `on plugin ${_(o)}`);
      let O = { name: o, onStart: false, onEnd: false, onResolve: [], onLoad: [] };
      L++;
      let E2 = R({ initialOptions: g, resolve: (a, c = {}) => {
        if (!z) throw new Error('Cannot call "resolve" before plugin setup has completed');
        if (typeof a != "string") throw new Error("The path to resolve must be a string");
        let b = /* @__PURE__ */ Object.create(null), M = r(c, b, "pluginName", y), P = r(c, b, "importer", y), k = r(c, b, "namespace", y), x2 = r(c, b, "resolveDir", y), C2 = r(c, b, "kind", y), q = r(c, b, "pluginData", we), m = r(c, b, "with", Q);
        return K(c, b, "in resolve() call"), new Promise((A2, N) => {
          let D = { command: "resolve", path: a, key: e2, pluginName: o };
          if (M != null && (D.pluginName = M), P != null && (D.importer = P), k != null && (D.namespace = k), x2 != null && (D.resolveDir = x2), C2 != null) D.kind = C2;
          else throw new Error('Must specify "kind" when calling "resolve"');
          q != null && (D.pluginData = p.store(q)), m != null && (D.with = lt(m, "with")), t(i, D, (J, W) => {
            J !== null ? N(new Error(J)) : A2({ errors: de(W.errors, p), warnings: de(W.warnings, p), path: W.path, external: W.external, sideEffects: W.sideEffects, namespace: W.namespace, suffix: W.suffix, pluginData: p.load(W.pluginData) });
          });
        });
      }, onStart(a) {
        let c = 'This error came from the "onStart" callback registered here:', b = he(new Error(c), u, "onStart");
        B2.push({ name: o, callback: a, note: b }), O.onStart = true;
      }, onEnd(a) {
        let c = 'This error came from the "onEnd" callback registered here:', b = he(new Error(c), u, "onEnd");
        F.push({ name: o, callback: a, note: b }), O.onEnd = true;
      }, onResolve(a, c) {
        let b = 'This error came from the "onResolve" callback registered here:', M = he(new Error(b), u, "onResolve"), P = {}, k = r(a, P, "filter", ve), x2 = r(a, P, "namespace", y);
        if (K(a, P, `in onResolve() call for plugin ${_(o)}`), k == null) throw new Error("onResolve() call is missing a filter");
        let C2 = j++;
        w2[C2] = { name: o, callback: c, note: M }, O.onResolve.push({ id: C2, filter: Re(k), namespace: x2 || "" });
      }, onLoad(a, c) {
        let b = 'This error came from the "onLoad" callback registered here:', M = he(new Error(b), u, "onLoad"), P = {}, k = r(a, P, "filter", ve), x2 = r(a, P, "namespace", y);
        if (K(a, P, `in onLoad() call for plugin ${_(o)}`), k == null) throw new Error("onLoad() call is missing a filter");
        let C2 = j++;
        U[C2] = { name: o, callback: c, note: M }, O.onLoad.push({ id: C2, filter: Re(k), namespace: x2 || "" });
      }, onDispose(a) {
        T.push(a);
      }, esbuild: u.esbuild });
      E2 && await E2, S.push(O);
    } catch (R) {
      return { ok: false, error: R, pluginName: o };
    }
  }
  l["on-start"] = async (d, f) => {
    p.clear();
    let o = { errors: [], warnings: [] };
    await Promise.all(B2.map(async ({ name: R, callback: O, note: $ }) => {
      try {
        let E2 = await O();
        if (E2 != null) {
          if (typeof E2 != "object") throw new Error(`Expected onStart() callback in plugin ${_(R)} to return an object`);
          let a = {}, c = r(E2, a, "errors", ie), b = r(E2, a, "warnings", ie);
          K(E2, a, `from onStart() callback in plugin ${_(R)}`), c != null && o.errors.push(...le(c, "errors", p, R, void 0)), b != null && o.warnings.push(...le(b, "warnings", p, R, void 0));
        }
      } catch (E2) {
        o.errors.push(oe(E2, u, p, $ && $(), R));
      }
    })), n2(d, o);
  }, l["on-resolve"] = async (d, f) => {
    let o = {}, R = "", O, $;
    for (let E2 of f.ids) try {
      ({ name: R, callback: O, note: $ } = w2[E2]);
      let a = await O({ path: f.path, importer: f.importer, namespace: f.namespace, resolveDir: f.resolveDir, kind: f.kind, pluginData: p.load(f.pluginData), with: f.with });
      if (a != null) {
        if (typeof a != "object") throw new Error(`Expected onResolve() callback in plugin ${_(R)} to return an object`);
        let c = {}, b = r(a, c, "pluginName", y), M = r(a, c, "path", y), P = r(a, c, "namespace", y), k = r(a, c, "suffix", y), x2 = r(a, c, "external", I), C2 = r(a, c, "sideEffects", I), q = r(a, c, "pluginData", we), m = r(a, c, "errors", ie), A2 = r(a, c, "warnings", ie), N = r(a, c, "watchFiles", G), D = r(a, c, "watchDirs", G);
        K(a, c, `from onResolve() callback in plugin ${_(R)}`), o.id = E2, b != null && (o.pluginName = b), M != null && (o.path = M), P != null && (o.namespace = P), k != null && (o.suffix = k), x2 != null && (o.external = x2), C2 != null && (o.sideEffects = C2), q != null && (o.pluginData = p.store(q)), m != null && (o.errors = le(m, "errors", p, R, void 0)), A2 != null && (o.warnings = le(A2, "warnings", p, R, void 0)), N != null && (o.watchFiles = be(N, "watchFiles")), D != null && (o.watchDirs = be(D, "watchDirs"));
        break;
      }
    } catch (a) {
      o = { id: E2, errors: [oe(a, u, p, $ && $(), R)] };
      break;
    }
    n2(d, o);
  }, l["on-load"] = async (d, f) => {
    let o = {}, R = "", O, $;
    for (let E2 of f.ids) try {
      ({ name: R, callback: O, note: $ } = U[E2]);
      let a = await O({ path: f.path, namespace: f.namespace, suffix: f.suffix, pluginData: p.load(f.pluginData), with: f.with });
      if (a != null) {
        if (typeof a != "object") throw new Error(`Expected onLoad() callback in plugin ${_(R)} to return an object`);
        let c = {}, b = r(a, c, "pluginName", y), M = r(a, c, "contents", Le), P = r(a, c, "resolveDir", y), k = r(a, c, "pluginData", we), x2 = r(a, c, "loader", y), C2 = r(a, c, "errors", ie), q = r(a, c, "warnings", ie), m = r(a, c, "watchFiles", G), A2 = r(a, c, "watchDirs", G);
        K(a, c, `from onLoad() callback in plugin ${_(R)}`), o.id = E2, b != null && (o.pluginName = b), M instanceof Uint8Array ? o.contents = M : M != null && (o.contents = Z(M)), P != null && (o.resolveDir = P), k != null && (o.pluginData = p.store(k)), x2 != null && (o.loader = x2), C2 != null && (o.errors = le(C2, "errors", p, R, void 0)), q != null && (o.warnings = le(q, "warnings", p, R, void 0)), m != null && (o.watchFiles = be(m, "watchFiles")), A2 != null && (o.watchDirs = be(A2, "watchDirs"));
        break;
      }
    } catch (a) {
      o = { id: E2, errors: [oe(a, u, p, $ && $(), R)] };
      break;
    }
    n2(d, o);
  };
  let V = (d, f) => f([], []);
  F.length > 0 && (V = (d, f) => {
    (async () => {
      let o = [], R = [];
      for (let { name: O, callback: $, note: E2 } of F) {
        let a, c;
        try {
          let b = await $(d);
          if (b != null) {
            if (typeof b != "object") throw new Error(`Expected onEnd() callback in plugin ${_(O)} to return an object`);
            let M = {}, P = r(b, M, "errors", ie), k = r(b, M, "warnings", ie);
            K(b, M, `from onEnd() callback in plugin ${_(O)}`), P != null && (a = le(P, "errors", p, O, void 0)), k != null && (c = le(k, "warnings", p, O, void 0));
          }
        } catch (b) {
          a = [oe(b, u, p, E2 && E2(), O)];
        }
        if (a) {
          o.push(...a);
          try {
            d.errors.push(...a);
          } catch (b) {
          }
        }
        if (c) {
          R.push(...c);
          try {
            d.warnings.push(...c);
          } catch (b) {
          }
        }
      }
      f(o, R);
    })();
  });
  let v = () => {
    for (let d of T) setTimeout(() => d(), 0);
  };
  return z = true, { ok: true, requestPlugins: S, runOnEndCallbacks: V, scheduleOnDisposeCallbacks: v };
};
function ze() {
  let e2 = /* @__PURE__ */ new Map(), t = 0;
  return { clear() {
    e2.clear();
  }, load(n2) {
    return e2.get(n2);
  }, store(n2) {
    if (n2 === void 0) return -1;
    let i = t++;
    return e2.set(i, n2), i;
  } };
}
function he(e2, t, n2) {
  let i, u = false;
  return () => {
    if (u) return i;
    u = true;
    try {
      let l = (e2.stack + "").split(`
`);
      l.splice(1, 1);
      let g = Ke(t, l, n2);
      if (g) return i = { text: e2.message, location: g }, i;
    } catch (l) {
    }
  };
}
function oe(e2, t, n2, i, u) {
  let l = "Internal error", g = null;
  try {
    l = (e2 && e2.message || e2) + "";
  } catch (s) {
  }
  try {
    g = Ke(t, (e2.stack + "").split(`
`), "");
  } catch (s) {
  }
  return { id: "", pluginName: u, text: l, location: g, notes: i ? [i] : [], detail: n2 ? n2.store(e2) : -1 };
}
function Ke(e2, t, n2) {
  let i = "    at ";
  if (e2.readFileSync && !t[0].startsWith(i) && t[1].startsWith(i)) for (let u = 1; u < t.length; u++) {
    let l = t[u];
    if (l.startsWith(i)) for (l = l.slice(i.length); ; ) {
      let g = /^(?:new |async )?\S+ \((.*)\)$/.exec(l);
      if (g) {
        l = g[1];
        continue;
      }
      if (g = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(l), g) {
        l = g[1];
        continue;
      }
      if (g = /^(\S+):(\d+):(\d+)$/.exec(l), g) {
        let s;
        try {
          s = e2.readFileSync(g[1], "utf8");
        } catch (w2) {
          break;
        }
        let p = s.split(/\r\n|\r|\n|\u2028|\u2029/)[+g[2] - 1] || "", B2 = +g[3] - 1, F = p.slice(B2, B2 + n2.length) === n2 ? n2.length : 0;
        return { file: g[1], namespace: "file", line: +g[2], column: Z(p.slice(0, B2)).length, length: Z(p.slice(B2, B2 + F)).length, lineText: p + `
` + t.slice(1).join(`
`), suggestion: "" };
      }
      break;
    }
  }
  return null;
}
function pe(e2, t, n2) {
  let i = 5;
  e2 += t.length < 1 ? "" : ` with ${t.length} error${t.length < 2 ? "" : "s"}:` + t.slice(0, i + 1).map((l, g) => {
    if (g === i) return `
...`;
    if (!l.location) return `
error: ${l.text}`;
    let { file: s, line: p, column: B2 } = l.location, F = l.pluginName ? `[plugin: ${l.pluginName}] ` : "";
    return `
${s}:${p}:${B2}: ERROR: ${F}${l.text}`;
  }).join("");
  let u = new Error(e2);
  for (let [l, g] of [["errors", t], ["warnings", n2]]) Object.defineProperty(u, l, { configurable: true, enumerable: true, get: () => g, set: (s) => Object.defineProperty(u, l, { configurable: true, enumerable: true, value: s }) });
  return u;
}
function de(e2, t) {
  for (let n2 of e2) n2.detail = t.load(n2.detail);
  return e2;
}
function De(e2, t, n2) {
  if (e2 == null) return null;
  let i = {}, u = r(e2, i, "file", y), l = r(e2, i, "namespace", y), g = r(e2, i, "line", ae), s = r(e2, i, "column", ae), p = r(e2, i, "length", ae), B2 = r(e2, i, "lineText", y), F = r(e2, i, "suggestion", y);
  if (K(e2, i, t), B2) {
    let w2 = B2.slice(0, (s && s > 0 ? s : 0) + (p && p > 0 ? p : 0) + (n2 && n2 > 0 ? n2 : 80));
    !/[\x7F-\uFFFF]/.test(w2) && !/\n/.test(B2) && (B2 = w2);
  }
  return { file: u || "", namespace: l || "", line: g || 0, column: s || 0, length: p || 0, lineText: B2 || "", suggestion: F || "" };
}
function le(e2, t, n2, i, u) {
  let l = [], g = 0;
  for (let s of e2) {
    let p = {}, B2 = r(s, p, "id", y), F = r(s, p, "pluginName", y), w2 = r(s, p, "text", y), U = r(s, p, "location", Te), T = r(s, p, "notes", ie), j = r(s, p, "detail", we), L = `in element ${g} of "${t}"`;
    K(s, p, L);
    let S = [];
    if (T) for (let z of T) {
      let V = {}, v = r(z, V, "text", y), d = r(z, V, "location", Te);
      K(z, V, L), S.push({ text: v || "", location: De(d, L, u) });
    }
    l.push({ id: B2 || "", pluginName: F || i, text: w2 || "", location: De(U, L, u), notes: S, detail: n2 ? n2.store(j) : -1 }), g++;
  }
  return l;
}
function be(e2, t) {
  let n2 = [];
  for (let i of e2) {
    if (typeof i != "string") throw new Error(`${_(t)} must be an array of strings`);
    n2.push(i);
  }
  return n2;
}
function lt(e2, t) {
  let n2 = /* @__PURE__ */ Object.create(null);
  for (let i in e2) {
    let u = e2[i];
    if (typeof u != "string") throw new Error(`key ${_(i)} in object ${_(t)} must be a string`);
    n2[i] = u;
  }
  return n2;
}
function st({ path: e2, contents: t, hash: n2 }) {
  let i = null;
  return { path: e2, contents: t, hash: n2, get text() {
    let u = this.contents;
    return (i === null || u !== t) && (t = u, i = se(u)), i;
  } };
}
function Re(e2) {
  let t = e2.source;
  return e2.flags && (t = `(?${e2.flags})${t}`), t;
}
var at = "0.27.0";
var ut = (e2) => me().build(e2);
var ct = (e2) => me().context(e2);
var ft = (e2, t) => me().transform(e2, t);
var dt = (e2, t) => me().formatMessages(e2, t);
var gt = (e2, t) => me().analyzeMetafile(e2, t);
var pt = () => {
  throw new Error('The "buildSync" API only works in node');
};
var mt = () => {
  throw new Error('The "transformSync" API only works in node');
};
var yt = () => {
  throw new Error('The "formatMessagesSync" API only works in node');
};
var ht = () => {
  throw new Error('The "analyzeMetafileSync" API only works in node');
};
var bt = () => (Oe && Oe(), Promise.resolve());
var ue;
var Oe;
var Ee;
var me = () => {
  if (Ee) return Ee;
  throw ue ? new Error('You need to wait for the promise returned from "initialize" to be resolved before calling this') : new Error('You need to call "initialize" before calling this');
};
var wt = (e2) => {
  e2 = Ne(e2 || {});
  let t = e2.wasmURL, n2 = e2.wasmModule, i = e2.worker !== false;
  if (!t && !n2) throw new Error('Must provide either the "wasmURL" option or the "wasmModule" option');
  if (ue) throw new Error('Cannot call "initialize" more than once');
  return ue = vt(t || "", n2, i), ue.catch(() => {
    ue = void 0;
  }), ue;
};
var vt = async (e2, t, n2) => {
  let i, u, l = new Promise((w2) => u = w2);
  if (n2) {
    let w2 = new Blob(['onmessage=(postMessage=>{\n// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\nlet onmessage,globalThis={};for(let r=self;r;r=Object.getPrototypeOf(r))for(let f of Object.getOwnPropertyNames(r))f in globalThis||Object.defineProperty(globalThis,f,{get:()=>self[f]});(()=>{const r=()=>{const a=new Error("not implemented");return a.code="ENOSYS",a};if(!globalThis.fs){let a="";globalThis.fs={constants:{O_WRONLY:-1,O_RDWR:-1,O_CREAT:-1,O_TRUNC:-1,O_APPEND:-1,O_EXCL:-1,O_DIRECTORY:-1},writeSync(i,s){a+=y.decode(s);const n=a.lastIndexOf(`\n`);return n!=-1&&(console.log(a.substring(0,n)),a=a.substring(n+1)),s.length},write(i,s,n,o,h,u){if(n!==0||o!==s.length||h!==null){u(r());return}const m=this.writeSync(i,s);u(null,m)},chmod(i,s,n){n(r())},chown(i,s,n,o){o(r())},close(i,s){s(r())},fchmod(i,s,n){n(r())},fchown(i,s,n,o){o(r())},fstat(i,s){s(r())},fsync(i,s){s(null)},ftruncate(i,s,n){n(r())},lchown(i,s,n,o){o(r())},link(i,s,n){n(r())},lstat(i,s){s(r())},mkdir(i,s,n){n(r())},open(i,s,n,o){o(r())},read(i,s,n,o,h,u){u(r())},readdir(i,s){s(r())},readlink(i,s){s(r())},rename(i,s,n){n(r())},rmdir(i,s){s(r())},stat(i,s){s(r())},symlink(i,s,n){n(r())},truncate(i,s,n){n(r())},unlink(i,s){s(r())},utimes(i,s,n,o){o(r())}}}if(globalThis.process||(globalThis.process={getuid(){return-1},getgid(){return-1},geteuid(){return-1},getegid(){return-1},getgroups(){throw r()},pid:-1,ppid:-1,umask(){throw r()},cwd(){throw r()},chdir(){throw r()}}),globalThis.path||(globalThis.path={resolve(...a){return a.join("/")}}),!globalThis.crypto)throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");if(!globalThis.performance)throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");if(!globalThis.TextEncoder)throw new Error("globalThis.TextEncoder is not available, polyfill required");if(!globalThis.TextDecoder)throw new Error("globalThis.TextDecoder is not available, polyfill required");const f=new TextEncoder("utf-8"),y=new TextDecoder("utf-8");globalThis.Go=class{constructor(){this.argv=["js"],this.env={},this.exit=t=>{t!==0&&console.warn("exit code:",t)},this._exitPromise=new Promise(t=>{this._resolveExitPromise=t}),this._pendingEvent=null,this._scheduledTimeouts=new Map,this._nextCallbackTimeoutID=1;const a=(t,e)=>{this.mem.setUint32(t+0,e,!0),this.mem.setUint32(t+4,Math.floor(e/4294967296),!0)},i=(t,e)=>{this.mem.setUint32(t+0,e,!0)},s=t=>{const e=this.mem.getUint32(t+0,!0),l=this.mem.getInt32(t+4,!0);return e+l*4294967296},n=t=>{const e=this.mem.getFloat64(t,!0);if(e===0)return;if(!isNaN(e))return e;const l=this.mem.getUint32(t,!0);return this._values[l]},o=(t,e)=>{if(typeof e=="number"&&e!==0){if(isNaN(e)){this.mem.setUint32(t+4,2146959360,!0),this.mem.setUint32(t,0,!0);return}this.mem.setFloat64(t,e,!0);return}if(e===void 0){this.mem.setFloat64(t,0,!0);return}let c=this._ids.get(e);c===void 0&&(c=this._idPool.pop(),c===void 0&&(c=this._values.length),this._values[c]=e,this._goRefCounts[c]=0,this._ids.set(e,c)),this._goRefCounts[c]++;let g=0;switch(typeof e){case"object":e!==null&&(g=1);break;case"string":g=2;break;case"symbol":g=3;break;case"function":g=4;break}this.mem.setUint32(t+4,2146959360|g,!0),this.mem.setUint32(t,c,!0)},h=t=>{const e=s(t+0),l=s(t+8);return new Uint8Array(this._inst.exports.mem.buffer,e,l)},u=t=>{const e=s(t+0),l=s(t+8),c=new Array(l);for(let g=0;g<l;g++)c[g]=n(e+g*8);return c},m=t=>{const e=s(t+0),l=s(t+8);return y.decode(new DataView(this._inst.exports.mem.buffer,e,l))},d=(t,e)=>(this._inst.exports.testExport0(),this._inst.exports.testExport(t,e)),w=Date.now()-performance.now();this.importObject={_gotest:{add:(t,e)=>t+e,callExport:d},gojs:{"runtime.wasmExit":t=>{t>>>=0;const e=this.mem.getInt32(t+8,!0);this.exited=!0,delete this._inst,delete this._values,delete this._goRefCounts,delete this._ids,delete this._idPool,this.exit(e)},"runtime.wasmWrite":t=>{t>>>=0;const e=s(t+8),l=s(t+16),c=this.mem.getInt32(t+24,!0);globalThis.fs.writeSync(e,new Uint8Array(this._inst.exports.mem.buffer,l,c))},"runtime.resetMemoryDataView":t=>{t>>>=0,this.mem=new DataView(this._inst.exports.mem.buffer)},"runtime.nanotime1":t=>{t>>>=0,a(t+8,(w+performance.now())*1e6)},"runtime.walltime":t=>{t>>>=0;const e=new Date().getTime();a(t+8,e/1e3),this.mem.setInt32(t+16,e%1e3*1e6,!0)},"runtime.scheduleTimeoutEvent":t=>{t>>>=0;const e=this._nextCallbackTimeoutID;this._nextCallbackTimeoutID++,this._scheduledTimeouts.set(e,setTimeout(()=>{for(this._resume();this._scheduledTimeouts.has(e);)console.warn("scheduleTimeoutEvent: missed timeout event"),this._resume()},s(t+8))),this.mem.setInt32(t+16,e,!0)},"runtime.clearTimeoutEvent":t=>{t>>>=0;const e=this.mem.getInt32(t+8,!0);clearTimeout(this._scheduledTimeouts.get(e)),this._scheduledTimeouts.delete(e)},"runtime.getRandomData":t=>{t>>>=0,crypto.getRandomValues(h(t+8))},"syscall/js.finalizeRef":t=>{t>>>=0;const e=this.mem.getUint32(t+8,!0);if(this._goRefCounts[e]--,this._goRefCounts[e]===0){const l=this._values[e];this._values[e]=null,this._ids.delete(l),this._idPool.push(e)}},"syscall/js.stringVal":t=>{t>>>=0,o(t+24,m(t+8))},"syscall/js.valueGet":t=>{t>>>=0;const e=Reflect.get(n(t+8),m(t+16));t=this._inst.exports.getsp()>>>0,o(t+32,e)},"syscall/js.valueSet":t=>{t>>>=0,Reflect.set(n(t+8),m(t+16),n(t+32))},"syscall/js.valueDelete":t=>{t>>>=0,Reflect.deleteProperty(n(t+8),m(t+16))},"syscall/js.valueIndex":t=>{t>>>=0,o(t+24,Reflect.get(n(t+8),s(t+16)))},"syscall/js.valueSetIndex":t=>{t>>>=0,Reflect.set(n(t+8),s(t+16),n(t+24))},"syscall/js.valueCall":t=>{t>>>=0;try{const e=n(t+8),l=Reflect.get(e,m(t+16)),c=u(t+32),g=Reflect.apply(l,e,c);t=this._inst.exports.getsp()>>>0,o(t+56,g),this.mem.setUint8(t+64,1)}catch(e){t=this._inst.exports.getsp()>>>0,o(t+56,e),this.mem.setUint8(t+64,0)}},"syscall/js.valueInvoke":t=>{t>>>=0;try{const e=n(t+8),l=u(t+16),c=Reflect.apply(e,void 0,l);t=this._inst.exports.getsp()>>>0,o(t+40,c),this.mem.setUint8(t+48,1)}catch(e){t=this._inst.exports.getsp()>>>0,o(t+40,e),this.mem.setUint8(t+48,0)}},"syscall/js.valueNew":t=>{t>>>=0;try{const e=n(t+8),l=u(t+16),c=Reflect.construct(e,l);t=this._inst.exports.getsp()>>>0,o(t+40,c),this.mem.setUint8(t+48,1)}catch(e){t=this._inst.exports.getsp()>>>0,o(t+40,e),this.mem.setUint8(t+48,0)}},"syscall/js.valueLength":t=>{t>>>=0,a(t+16,parseInt(n(t+8).length))},"syscall/js.valuePrepareString":t=>{t>>>=0;const e=f.encode(String(n(t+8)));o(t+16,e),a(t+24,e.length)},"syscall/js.valueLoadString":t=>{t>>>=0;const e=n(t+8);h(t+16).set(e)},"syscall/js.valueInstanceOf":t=>{t>>>=0,this.mem.setUint8(t+24,n(t+8)instanceof n(t+16)?1:0)},"syscall/js.copyBytesToGo":t=>{t>>>=0;const e=h(t+8),l=n(t+32);if(!(l instanceof Uint8Array||l instanceof Uint8ClampedArray)){this.mem.setUint8(t+48,0);return}const c=l.subarray(0,e.length);e.set(c),a(t+40,c.length),this.mem.setUint8(t+48,1)},"syscall/js.copyBytesToJS":t=>{t>>>=0;const e=n(t+8),l=h(t+16);if(!(e instanceof Uint8Array||e instanceof Uint8ClampedArray)){this.mem.setUint8(t+48,0);return}const c=l.subarray(0,e.length);e.set(c),a(t+40,c.length),this.mem.setUint8(t+48,1)},debug:t=>{console.log(t)}}}}async run(a){if(!(a instanceof WebAssembly.Instance))throw new Error("Go.run: WebAssembly.Instance expected");this._inst=a,this.mem=new DataView(this._inst.exports.mem.buffer),this._values=[NaN,0,null,!0,!1,globalThis,this],this._goRefCounts=new Array(this._values.length).fill(1/0),this._ids=new Map([[0,1],[null,2],[!0,3],[!1,4],[globalThis,5],[this,6]]),this._idPool=[],this.exited=!1;let i=4096;const s=d=>{const w=i,t=f.encode(d+"\\0");return new Uint8Array(this.mem.buffer,i,t.length).set(t),i+=t.length,i%8!==0&&(i+=8-i%8),w},n=this.argv.length,o=[];this.argv.forEach(d=>{o.push(s(d))}),o.push(0),Object.keys(this.env).sort().forEach(d=>{o.push(s(`${d}=${this.env[d]}`))}),o.push(0);const u=i;if(o.forEach(d=>{this.mem.setUint32(i,d,!0),this.mem.setUint32(i+4,0,!0),i+=8}),i>=12288)throw new Error("total length of command line and environment variables exceeds limit");this._inst.exports.run(n,u),this.exited&&this._resolveExitPromise(),await this._exitPromise}_resume(){if(this.exited)throw new Error("Go program has already exited");this._inst.exports.resume(),this.exited&&this._resolveExitPromise()}_makeFuncWrapper(a){const i=this;return function(){const s={id:a,this:this,args:arguments};return i._pendingEvent=s,i._resume(),s.result}}}})(),onmessage=({data:r})=>{let f=new TextDecoder,y=globalThis.fs,a="";y.writeSync=(h,u)=>{if(h===1)postMessage(u);else if(h===2){a+=f.decode(u);let m=a.split(`\n`);m.length>1&&console.log(m.slice(0,-1).join(`\n`)),a=m[m.length-1]}else throw new Error("Bad write");return u.length};let i=[],s,n=0;onmessage=({data:h})=>(h.length>0&&(i.push(h),s&&s()),o),y.read=(h,u,m,d,w,t)=>{if(h!==0||m!==0||d!==u.length||w!==null)throw new Error("Bad read");if(i.length===0){s=()=>y.read(h,u,m,d,w,t);return}let e=i[0],l=Math.max(0,Math.min(d,e.length-n));u.set(e.subarray(n,n+l),m),n+=l,n===e.length&&(i.shift(),n=0),t(null,l)};let o=new globalThis.Go;return o.argv=["","--service=0.27.0"],tryToInstantiateModule(r,o).then(h=>{postMessage(null),o.run(h)},h=>{postMessage(h)}),o};async function tryToInstantiateModule(r,f){if(r instanceof WebAssembly.Module)return WebAssembly.instantiate(r,f.importObject);const y=await fetch(r);if(!y.ok)throw new Error(`Failed to download ${JSON.stringify(r)}`);if("instantiateStreaming"in WebAssembly&&/^application\\/wasm($|;)/i.test(y.headers.get("Content-Type")||""))return(await WebAssembly.instantiateStreaming(y,f.importObject)).instance;const a=await y.arrayBuffer();return(await WebAssembly.instantiate(a,f.importObject)).instance}return r=>onmessage(r);})(postMessage)'], { type: "text/javascript" });
    i = new Worker(URL.createObjectURL(w2));
  } else {
    let w2 = ((postMessage) => {
      let onmessage, globalThis2 = {};
      for (let r2 = self; r2; r2 = Object.getPrototypeOf(r2)) for (let f of Object.getOwnPropertyNames(r2)) f in globalThis2 || Object.defineProperty(globalThis2, f, { get: () => self[f] });
      (() => {
        const r2 = () => {
          const a = new Error("not implemented");
          return a.code = "ENOSYS", a;
        };
        if (!globalThis2.fs) {
          let a = "";
          globalThis2.fs = { constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1, O_DIRECTORY: -1 }, writeSync(i2, s2) {
            a += y2.decode(s2);
            const n3 = a.lastIndexOf(`
`);
            return n3 != -1 && (console.log(a.substring(0, n3)), a = a.substring(n3 + 1)), s2.length;
          }, write(i2, s2, n3, o, h, u2) {
            if (n3 !== 0 || o !== s2.length || h !== null) {
              u2(r2());
              return;
            }
            const m = this.writeSync(i2, s2);
            u2(null, m);
          }, chmod(i2, s2, n3) {
            n3(r2());
          }, chown(i2, s2, n3, o) {
            o(r2());
          }, close(i2, s2) {
            s2(r2());
          }, fchmod(i2, s2, n3) {
            n3(r2());
          }, fchown(i2, s2, n3, o) {
            o(r2());
          }, fstat(i2, s2) {
            s2(r2());
          }, fsync(i2, s2) {
            s2(null);
          }, ftruncate(i2, s2, n3) {
            n3(r2());
          }, lchown(i2, s2, n3, o) {
            o(r2());
          }, link(i2, s2, n3) {
            n3(r2());
          }, lstat(i2, s2) {
            s2(r2());
          }, mkdir(i2, s2, n3) {
            n3(r2());
          }, open(i2, s2, n3, o) {
            o(r2());
          }, read(i2, s2, n3, o, h, u2) {
            u2(r2());
          }, readdir(i2, s2) {
            s2(r2());
          }, readlink(i2, s2) {
            s2(r2());
          }, rename(i2, s2, n3) {
            n3(r2());
          }, rmdir(i2, s2) {
            s2(r2());
          }, stat(i2, s2) {
            s2(r2());
          }, symlink(i2, s2, n3) {
            n3(r2());
          }, truncate(i2, s2, n3) {
            n3(r2());
          }, unlink(i2, s2) {
            s2(r2());
          }, utimes(i2, s2, n3, o) {
            o(r2());
          } };
        }
        if (globalThis2.process || (globalThis2.process = { getuid() {
          return -1;
        }, getgid() {
          return -1;
        }, geteuid() {
          return -1;
        }, getegid() {
          return -1;
        }, getgroups() {
          throw r2();
        }, pid: -1, ppid: -1, umask() {
          throw r2();
        }, cwd() {
          throw r2();
        }, chdir() {
          throw r2();
        } }), globalThis2.path || (globalThis2.path = { resolve(...a) {
          return a.join("/");
        } }), !globalThis2.crypto) throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");
        if (!globalThis2.performance) throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");
        if (!globalThis2.TextEncoder) throw new Error("globalThis.TextEncoder is not available, polyfill required");
        if (!globalThis2.TextDecoder) throw new Error("globalThis.TextDecoder is not available, polyfill required");
        const f = new TextEncoder("utf-8"), y2 = new TextDecoder("utf-8");
        globalThis2.Go = class {
          constructor() {
            this.argv = ["js"], this.env = {}, this.exit = (t2) => {
              t2 !== 0 && console.warn("exit code:", t2);
            }, this._exitPromise = new Promise((t2) => {
              this._resolveExitPromise = t2;
            }), this._pendingEvent = null, this._scheduledTimeouts = /* @__PURE__ */ new Map(), this._nextCallbackTimeoutID = 1;
            const a = (t2, e3) => {
              this.mem.setUint32(t2 + 0, e3, true), this.mem.setUint32(t2 + 4, Math.floor(e3 / 4294967296), true);
            }, i2 = (t2, e3) => {
              this.mem.setUint32(t2 + 0, e3, true);
            }, s2 = (t2) => {
              const e3 = this.mem.getUint32(t2 + 0, true), l2 = this.mem.getInt32(t2 + 4, true);
              return e3 + l2 * 4294967296;
            }, n3 = (t2) => {
              const e3 = this.mem.getFloat64(t2, true);
              if (e3 === 0) return;
              if (!isNaN(e3)) return e3;
              const l2 = this.mem.getUint32(t2, true);
              return this._values[l2];
            }, o = (t2, e3) => {
              if (typeof e3 == "number" && e3 !== 0) {
                if (isNaN(e3)) {
                  this.mem.setUint32(t2 + 4, 2146959360, true), this.mem.setUint32(t2, 0, true);
                  return;
                }
                this.mem.setFloat64(t2, e3, true);
                return;
              }
              if (e3 === void 0) {
                this.mem.setFloat64(t2, 0, true);
                return;
              }
              let c = this._ids.get(e3);
              c === void 0 && (c = this._idPool.pop(), c === void 0 && (c = this._values.length), this._values[c] = e3, this._goRefCounts[c] = 0, this._ids.set(e3, c)), this._goRefCounts[c]++;
              let g2 = 0;
              switch (typeof e3) {
                case "object":
                  e3 !== null && (g2 = 1);
                  break;
                case "string":
                  g2 = 2;
                  break;
                case "symbol":
                  g2 = 3;
                  break;
                case "function":
                  g2 = 4;
                  break;
              }
              this.mem.setUint32(t2 + 4, 2146959360 | g2, true), this.mem.setUint32(t2, c, true);
            }, h = (t2) => {
              const e3 = s2(t2 + 0), l2 = s2(t2 + 8);
              return new Uint8Array(this._inst.exports.mem.buffer, e3, l2);
            }, u2 = (t2) => {
              const e3 = s2(t2 + 0), l2 = s2(t2 + 8), c = new Array(l2);
              for (let g2 = 0; g2 < l2; g2++) c[g2] = n3(e3 + g2 * 8);
              return c;
            }, m = (t2) => {
              const e3 = s2(t2 + 0), l2 = s2(t2 + 8);
              return y2.decode(new DataView(this._inst.exports.mem.buffer, e3, l2));
            }, d = (t2, e3) => (this._inst.exports.testExport0(), this._inst.exports.testExport(t2, e3)), w3 = Date.now() - performance.now();
            this.importObject = { _gotest: { add: (t2, e3) => t2 + e3, callExport: d }, gojs: { "runtime.wasmExit": (t2) => {
              t2 >>>= 0;
              const e3 = this.mem.getInt32(t2 + 8, true);
              this.exited = true, delete this._inst, delete this._values, delete this._goRefCounts, delete this._ids, delete this._idPool, this.exit(e3);
            }, "runtime.wasmWrite": (t2) => {
              t2 >>>= 0;
              const e3 = s2(t2 + 8), l2 = s2(t2 + 16), c = this.mem.getInt32(t2 + 24, true);
              globalThis2.fs.writeSync(e3, new Uint8Array(this._inst.exports.mem.buffer, l2, c));
            }, "runtime.resetMemoryDataView": (t2) => {
              t2 >>>= 0, this.mem = new DataView(this._inst.exports.mem.buffer);
            }, "runtime.nanotime1": (t2) => {
              t2 >>>= 0, a(t2 + 8, (w3 + performance.now()) * 1e6);
            }, "runtime.walltime": (t2) => {
              t2 >>>= 0;
              const e3 = (/* @__PURE__ */ new Date()).getTime();
              a(t2 + 8, e3 / 1e3), this.mem.setInt32(t2 + 16, e3 % 1e3 * 1e6, true);
            }, "runtime.scheduleTimeoutEvent": (t2) => {
              t2 >>>= 0;
              const e3 = this._nextCallbackTimeoutID;
              this._nextCallbackTimeoutID++, this._scheduledTimeouts.set(e3, setTimeout(() => {
                for (this._resume(); this._scheduledTimeouts.has(e3); ) console.warn("scheduleTimeoutEvent: missed timeout event"), this._resume();
              }, s2(t2 + 8))), this.mem.setInt32(t2 + 16, e3, true);
            }, "runtime.clearTimeoutEvent": (t2) => {
              t2 >>>= 0;
              const e3 = this.mem.getInt32(t2 + 8, true);
              clearTimeout(this._scheduledTimeouts.get(e3)), this._scheduledTimeouts.delete(e3);
            }, "runtime.getRandomData": (t2) => {
              t2 >>>= 0, crypto.getRandomValues(h(t2 + 8));
            }, "syscall/js.finalizeRef": (t2) => {
              t2 >>>= 0;
              const e3 = this.mem.getUint32(t2 + 8, true);
              if (this._goRefCounts[e3]--, this._goRefCounts[e3] === 0) {
                const l2 = this._values[e3];
                this._values[e3] = null, this._ids.delete(l2), this._idPool.push(e3);
              }
            }, "syscall/js.stringVal": (t2) => {
              t2 >>>= 0, o(t2 + 24, m(t2 + 8));
            }, "syscall/js.valueGet": (t2) => {
              t2 >>>= 0;
              const e3 = Reflect.get(n3(t2 + 8), m(t2 + 16));
              t2 = this._inst.exports.getsp() >>> 0, o(t2 + 32, e3);
            }, "syscall/js.valueSet": (t2) => {
              t2 >>>= 0, Reflect.set(n3(t2 + 8), m(t2 + 16), n3(t2 + 32));
            }, "syscall/js.valueDelete": (t2) => {
              t2 >>>= 0, Reflect.deleteProperty(n3(t2 + 8), m(t2 + 16));
            }, "syscall/js.valueIndex": (t2) => {
              t2 >>>= 0, o(t2 + 24, Reflect.get(n3(t2 + 8), s2(t2 + 16)));
            }, "syscall/js.valueSetIndex": (t2) => {
              t2 >>>= 0, Reflect.set(n3(t2 + 8), s2(t2 + 16), n3(t2 + 24));
            }, "syscall/js.valueCall": (t2) => {
              t2 >>>= 0;
              try {
                const e3 = n3(t2 + 8), l2 = Reflect.get(e3, m(t2 + 16)), c = u2(t2 + 32), g2 = Reflect.apply(l2, e3, c);
                t2 = this._inst.exports.getsp() >>> 0, o(t2 + 56, g2), this.mem.setUint8(t2 + 64, 1);
              } catch (e3) {
                t2 = this._inst.exports.getsp() >>> 0, o(t2 + 56, e3), this.mem.setUint8(t2 + 64, 0);
              }
            }, "syscall/js.valueInvoke": (t2) => {
              t2 >>>= 0;
              try {
                const e3 = n3(t2 + 8), l2 = u2(t2 + 16), c = Reflect.apply(e3, void 0, l2);
                t2 = this._inst.exports.getsp() >>> 0, o(t2 + 40, c), this.mem.setUint8(t2 + 48, 1);
              } catch (e3) {
                t2 = this._inst.exports.getsp() >>> 0, o(t2 + 40, e3), this.mem.setUint8(t2 + 48, 0);
              }
            }, "syscall/js.valueNew": (t2) => {
              t2 >>>= 0;
              try {
                const e3 = n3(t2 + 8), l2 = u2(t2 + 16), c = Reflect.construct(e3, l2);
                t2 = this._inst.exports.getsp() >>> 0, o(t2 + 40, c), this.mem.setUint8(t2 + 48, 1);
              } catch (e3) {
                t2 = this._inst.exports.getsp() >>> 0, o(t2 + 40, e3), this.mem.setUint8(t2 + 48, 0);
              }
            }, "syscall/js.valueLength": (t2) => {
              t2 >>>= 0, a(t2 + 16, parseInt(n3(t2 + 8).length));
            }, "syscall/js.valuePrepareString": (t2) => {
              t2 >>>= 0;
              const e3 = f.encode(String(n3(t2 + 8)));
              o(t2 + 16, e3), a(t2 + 24, e3.length);
            }, "syscall/js.valueLoadString": (t2) => {
              t2 >>>= 0;
              const e3 = n3(t2 + 8);
              h(t2 + 16).set(e3);
            }, "syscall/js.valueInstanceOf": (t2) => {
              t2 >>>= 0, this.mem.setUint8(t2 + 24, n3(t2 + 8) instanceof n3(t2 + 16) ? 1 : 0);
            }, "syscall/js.copyBytesToGo": (t2) => {
              t2 >>>= 0;
              const e3 = h(t2 + 8), l2 = n3(t2 + 32);
              if (!(l2 instanceof Uint8Array || l2 instanceof Uint8ClampedArray)) {
                this.mem.setUint8(t2 + 48, 0);
                return;
              }
              const c = l2.subarray(0, e3.length);
              e3.set(c), a(t2 + 40, c.length), this.mem.setUint8(t2 + 48, 1);
            }, "syscall/js.copyBytesToJS": (t2) => {
              t2 >>>= 0;
              const e3 = n3(t2 + 8), l2 = h(t2 + 16);
              if (!(e3 instanceof Uint8Array || e3 instanceof Uint8ClampedArray)) {
                this.mem.setUint8(t2 + 48, 0);
                return;
              }
              const c = l2.subarray(0, e3.length);
              e3.set(c), a(t2 + 40, c.length), this.mem.setUint8(t2 + 48, 1);
            }, debug: (t2) => {
              console.log(t2);
            } } };
          }
          async run(a) {
            if (!(a instanceof WebAssembly.Instance)) throw new Error("Go.run: WebAssembly.Instance expected");
            this._inst = a, this.mem = new DataView(this._inst.exports.mem.buffer), this._values = [NaN, 0, null, true, false, globalThis2, this], this._goRefCounts = new Array(this._values.length).fill(1 / 0), this._ids = /* @__PURE__ */ new Map([[0, 1], [null, 2], [true, 3], [false, 4], [globalThis2, 5], [this, 6]]), this._idPool = [], this.exited = false;
            let i2 = 4096;
            const s2 = (d) => {
              const w3 = i2, t2 = f.encode(d + "\0");
              return new Uint8Array(this.mem.buffer, i2, t2.length).set(t2), i2 += t2.length, i2 % 8 !== 0 && (i2 += 8 - i2 % 8), w3;
            }, n3 = this.argv.length, o = [];
            this.argv.forEach((d) => {
              o.push(s2(d));
            }), o.push(0), Object.keys(this.env).sort().forEach((d) => {
              o.push(s2(`${d}=${this.env[d]}`));
            }), o.push(0);
            const u2 = i2;
            if (o.forEach((d) => {
              this.mem.setUint32(i2, d, true), this.mem.setUint32(i2 + 4, 0, true), i2 += 8;
            }), i2 >= 12288) throw new Error("total length of command line and environment variables exceeds limit");
            this._inst.exports.run(n3, u2), this.exited && this._resolveExitPromise(), await this._exitPromise;
          }
          _resume() {
            if (this.exited) throw new Error("Go program has already exited");
            this._inst.exports.resume(), this.exited && this._resolveExitPromise();
          }
          _makeFuncWrapper(a) {
            const i2 = this;
            return function() {
              const s2 = { id: a, this: this, args: arguments };
              return i2._pendingEvent = s2, i2._resume(), s2.result;
            };
          }
        };
      })(), onmessage = ({ data: r2 }) => {
        let f = new TextDecoder(), y2 = globalThis2.fs, a = "";
        y2.writeSync = (h, u2) => {
          if (h === 1) postMessage(u2);
          else if (h === 2) {
            a += f.decode(u2);
            let m = a.split(`
`);
            m.length > 1 && console.log(m.slice(0, -1).join(`
`)), a = m[m.length - 1];
          } else throw new Error("Bad write");
          return u2.length;
        };
        let i2 = [], s2, n3 = 0;
        onmessage = ({ data: h }) => (h.length > 0 && (i2.push(h), s2 && s2()), o), y2.read = (h, u2, m, d, w3, t2) => {
          if (h !== 0 || m !== 0 || d !== u2.length || w3 !== null) throw new Error("Bad read");
          if (i2.length === 0) {
            s2 = () => y2.read(h, u2, m, d, w3, t2);
            return;
          }
          let e3 = i2[0], l2 = Math.max(0, Math.min(d, e3.length - n3));
          u2.set(e3.subarray(n3, n3 + l2), m), n3 += l2, n3 === e3.length && (i2.shift(), n3 = 0), t2(null, l2);
        };
        let o = new globalThis2.Go();
        return o.argv = ["", "--service=0.27.0"], tryToInstantiateModule(r2, o).then((h) => {
          postMessage(null), o.run(h);
        }, (h) => {
          postMessage(h);
        }), o;
      };
      async function tryToInstantiateModule(r2, f) {
        if (r2 instanceof WebAssembly.Module) return WebAssembly.instantiate(r2, f.importObject);
        const y2 = await fetch(r2);
        if (!y2.ok) throw new Error(`Failed to download ${JSON.stringify(r2)}`);
        if ("instantiateStreaming" in WebAssembly && /^application\/wasm($|;)/i.test(y2.headers.get("Content-Type") || "")) return (await WebAssembly.instantiateStreaming(y2, f.importObject)).instance;
        const a = await y2.arrayBuffer();
        return (await WebAssembly.instantiate(a, f.importObject)).instance;
      }
      return (r2) => onmessage(r2);
    })((T) => i.onmessage({ data: T })), U;
    i = { onmessage: null, postMessage: (T) => setTimeout(() => {
      try {
        U = w2({ data: T });
      } catch (j) {
        u(j);
      }
    }), terminate() {
      if (U) for (let T of U._scheduledTimeouts.values()) clearTimeout(T);
    } };
  }
  let g, s, p = new Promise((w2, U) => {
    g = w2, s = U;
  });
  i.onmessage = ({ data: w2 }) => {
    i.onmessage = ({ data: U }) => B2(U), w2 ? s(w2) : g();
  }, i.postMessage(t || new URL(e2, location.href).toString());
  let { readFromStdout: B2, service: F } = We({ writeToStdin(w2) {
    i.postMessage(w2);
  }, isSync: false, hasFS: false, esbuild: Se });
  await p, Oe = () => {
    i.terminate(), ue = void 0, Oe = void 0, Ee = void 0;
  }, Ee = { build: (w2) => new Promise((U, T) => {
    l.then(T), F.buildOrContext({ callName: "build", refs: null, options: w2, isTTY: false, defaultWD: "/", callback: (j, L) => j ? T(j) : U(L) });
  }), context: (w2) => new Promise((U, T) => {
    l.then(T), F.buildOrContext({ callName: "context", refs: null, options: w2, isTTY: false, defaultWD: "/", callback: (j, L) => j ? T(j) : U(L) });
  }), transform: (w2, U) => new Promise((T, j) => {
    l.then(j), F.transform({ callName: "transform", refs: null, input: w2, options: U || {}, isTTY: false, fs: { readFile(L, S) {
      S(new Error("Internal error"), null);
    }, writeFile(L, S) {
      S(null);
    } }, callback: (L, S) => L ? j(L) : T(S) });
  }), formatMessages: (w2, U) => new Promise((T, j) => {
    l.then(j), F.formatMessages({ callName: "formatMessages", refs: null, messages: w2, options: U, callback: (L, S) => L ? j(L) : T(S) });
  }), analyzeMetafile: (w2, U) => new Promise((T, j) => {
    l.then(j), F.analyzeMetafile({ callName: "analyzeMetafile", refs: null, metafile: typeof w2 == "string" ? w2 : JSON.stringify(w2), options: U, callback: (L, S) => L ? j(L) : T(S) });
  }) };
};
var Rt = Se;

// src/http-resolver.js
var RESOLVE_EXTENSIONS = ["tsx", "ts", "jsx", "js", "css", "json"];
function inferLoader(url, contentType) {
  if (contentType?.includes("text/css")) return "css";
  if (contentType?.includes("javascript")) return "js";
  const ext = url.split(".").pop();
  if (RESOLVE_EXTENSIONS.includes(ext)) return ext;
  if (ext === "mjs" || ext === "cjs") return "js";
  return "text";
}
var httpPlugin = {
  name: "http",
  setup(build2) {
    build2.onResolve({ filter: /^https?:\/\// }, (args) => ({
      path: args.path,
      namespace: "http-url"
    }));
    build2.onResolve({ filter: /.*/, namespace: "http-url" }, (args) => ({
      path: new URL(args.path, args.importer).toString(),
      namespace: "http-url"
    }));
    build2.onLoad(
      { filter: /.*/, namespace: "http-url" },
      async (args) => {
        const url = args.path;
        const res = await fetch(url);
        const text2 = await res.text();
        if (!res.ok) throw new Error(`GET ${url} failed: status ${res.status}`);
        return {
          contents: text2,
          loader: inferLoader(url, res.headers.get("content-type"))
        };
      }
    );
  }
};

// node_modules/.deno/zimmerframe@1.1.4/node_modules/zimmerframe/src/walk.js
function walk(node, state, visitors6) {
  const universal = visitors6._;
  let stopped = false;
  function default_visitor(_2, { next: next2, state: state2 }) {
    next2(state2);
  }
  function visit(node2, path, state2) {
    if (stopped) return;
    if (!node2.type) return;
    let result;
    const mutations = {};
    const context = {
      path,
      state: state2,
      next: (next_state = state2) => {
        path.push(node2);
        for (const key2 in node2) {
          if (key2 === "type") continue;
          const child_node = node2[key2];
          if (child_node && typeof child_node === "object") {
            if (Array.isArray(child_node)) {
              const array_mutations = {};
              const len = child_node.length;
              let mutated = false;
              for (let i = 0; i < len; i++) {
                const node3 = child_node[i];
                if (node3 && typeof node3 === "object") {
                  const result2 = visit(node3, path, next_state);
                  if (result2) {
                    array_mutations[i] = result2;
                    mutated = true;
                  }
                }
              }
              if (mutated) {
                mutations[key2] = child_node.map(
                  (node3, i) => array_mutations[i] ?? node3
                );
              }
            } else {
              const result2 = visit(
                /** @type {T} */
                child_node,
                path,
                next_state
              );
              if (result2) {
                mutations[key2] = result2;
              }
            }
          }
        }
        path.pop();
        if (Object.keys(mutations).length > 0) {
          return apply_mutations(node2, mutations);
        }
      },
      stop: () => {
        stopped = true;
      },
      visit: (next_node, next_state = state2) => {
        path.push(node2);
        const result2 = visit(next_node, path, next_state) ?? next_node;
        path.pop();
        return result2;
      }
    };
    let visitor = (
      /** @type {Visitor<T, U, T>} */
      visitors6[
        /** @type {T['type']} */
        node2.type
      ] ?? default_visitor
    );
    if (universal) {
      let inner_result;
      result = universal(node2, {
        ...context,
        /** @param {U} next_state */
        next: (next_state = state2) => {
          state2 = next_state;
          inner_result = visitor(node2, {
            ...context,
            state: next_state
          });
          return inner_result;
        }
      });
      if (!result && inner_result) {
        result = inner_result;
      }
    } else {
      result = visitor(node2, context);
    }
    if (!result) {
      if (Object.keys(mutations).length > 0) {
        result = apply_mutations(node2, mutations);
      }
    }
    if (result) {
      return result;
    }
  }
  return visit(node, [], state) ?? node;
}
function apply_mutations(node, mutations) {
  const obj = {};
  const descriptors = Object.getOwnPropertyDescriptors(node);
  for (const key2 in descriptors) {
    Object.defineProperty(obj, key2, descriptors[key2]);
  }
  for (const key2 in mutations) {
    obj[key2] = mutations[key2];
  }
  return (
    /** @type {T} */
    obj
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/patterns.js
var regex_whitespace = /\s/;
var regex_whitespaces = /\s+/;
var regex_starts_with_newline = /^\r?\n/;
var regex_starts_with_whitespace = /^\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]+/;
var regex_ends_with_whitespace = /\s$/;
var regex_ends_with_whitespaces = /[ \t\r\n]+$/;
var regex_not_whitespace = /[^ \t\r\n]/;
var regex_whitespaces_strict = /[ \t\n\r\f]+/g;
var regex_only_whitespaces = /^[ \t\n\r\f]+$/;
var regex_not_newline_characters = /[^\n]/g;
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
var regex_invalid_identifier_chars = /(^[^a-zA-Z_$]|[^a-zA-Z0-9_$])/g;
var regex_starts_with_vowel = /^[aeiou]/;
var regex_heading_tags = /^h[1-6]$/;
var regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
var regex_bidirectional_control_characters = /[\u202a\u202b\u202c\u202d\u202e\u2066\u2067\u2068\u2069]+/g;
var regex_js_prefix = /^\W*javascript:/i;
var regex_redundant_img_alt = /\b(image|picture|photo)\b/i;

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_IS_CONTROLLED = 1 << 2;
var EACH_IS_ANIMATED = 1 << 3;
var EACH_ITEM_IMMUTABLE = 1 << 4;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_BINDABLE = 1 << 3;
var PROPS_IS_LAZY_INITIAL = 1 << 4;
var TRANSITION_IN = 1;
var TRANSITION_OUT = 1 << 1;
var TRANSITION_GLOBAL = 1 << 2;
var TEMPLATE_FRAGMENT = 1;
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var TEMPLATE_USE_SVG = 1 << 2;
var TEMPLATE_USE_MATHML = 1 << 3;
var HYDRATION_START = "[";
var HYDRATION_START_ELSE = "[!";
var HYDRATION_END = "]";
var ELEMENT_IS_NAMESPACED = 1;
var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
var ELEMENT_IS_INPUT = 1 << 2;
var UNINITIALIZED = Symbol();
var FILENAME = Symbol("filename");
var HMR = Symbol("hmr");
var NAMESPACE_SVG = "http://www.w3.org/2000/svg";
var NAMESPACE_MATHML = "http://www.w3.org/1998/Math/MathML";
var IGNORABLE_RUNTIME_WARNINGS = (
  /** @type {const} */
  [
    "await_waterfall",
    "await_reactivity_loss",
    "state_snapshot_uncloneable",
    "binding_property_non_reactive",
    "hydration_attribute_changed",
    "hydration_html_changed",
    "ownership_invalid_binding",
    "ownership_invalid_mutation"
  ]
);

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/utils/fuzzymatch.js
function fuzzymatch(name, names) {
  if (names.length === 0) return null;
  const set2 = new FuzzySet(names);
  const matches = set2.get(name);
  return matches && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null) return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  return 1 - distance / Math.max(str1.length, str2.length);
}
function levenshtein(str1, str2) {
  const current2 = [];
  let prev = 0;
  let value = 0;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current2[j], current2[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current2[j];
      current2[j] = value;
    }
  }
  return (
    /** @type {number} */
    current2.pop()
  );
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b) {
  return b[0] - a[0];
}
var FuzzySet = class {
  /** @type {Record<string, string>} */
  exact_set = {};
  /** @type {Record<string, [number, number][]>} */
  match_dict = {};
  /** @type {Record<string, number[]>} */
  items = {};
  /** @param {string[]} arr */
  constructor(arr) {
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  /** @param {string} value */
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index, gram_count]);
      } else {
        this.match_dict[gram] = [[index, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  /** @param {string} value */
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return (
        /** @type {MatchTuple[]} */
        [[1, result]]
      );
    }
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      const results = this.__get(value, gram_size);
      if (results.length > 0) return results;
    }
    return null;
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   * @returns {MatchTuple[]}
   */
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index in matches) {
            matches[index] += gram_count * other_gram_count;
          } else {
            matches[index] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] === results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// node_modules/.deno/locate-character@3.0.0/node_modules/locate-character/src/index.js
function rangeContains(range, index) {
  return range.start <= index && index < range.end;
}
function getLocator(source2, options = {}) {
  const { offsetLine = 0, offsetColumn = 0 } = options;
  let start = 0;
  const ranges = source2.split("\n").map((line, i2) => {
    const end = start + line.length + 1;
    const range = { start, end, line: i2 };
    start = end;
    return range;
  });
  let i = 0;
  function locator2(search, index) {
    if (typeof search === "string") {
      search = source2.indexOf(search, index ?? 0);
    }
    if (search === -1) return void 0;
    let range = ranges[i];
    const d = search >= range.end ? 1 : -1;
    while (range) {
      if (rangeContains(range, search)) {
        return {
          line: offsetLine + range.line,
          column: offsetColumn + search - range.start,
          character: search
        };
      }
      i += d;
      range = ranges[i];
    }
  }
  return locator2;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/utils.js
var regex_return_characters = /\r/g;
function hash(str2) {
  str2 = str2.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str2.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str2.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}
var VOID_ELEMENT_NAMES = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function is_void(name) {
  return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
var RESERVED_WORDS = [
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
];
function is_reserved(word) {
  return RESERVED_WORDS.includes(word);
}
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
var DELEGATED_EVENTS = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function can_delegate_event(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
var DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback"
];
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
var ATTRIBUTE_ALIASES = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function normalize_attribute(name) {
  name = name.toLowerCase();
  return ATTRIBUTE_ALIASES[name] ?? name;
}
var DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject",
  "noValidate",
  "allowFullscreen",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
function is_dom_property(name) {
  return DOM_PROPERTIES.includes(name);
}
var NON_STATIC_PROPERTIES = ["autofocus", "muted", "defaultValue", "defaultChecked"];
function cannot_be_set_statically(name) {
  return NON_STATIC_PROPERTIES.includes(name);
}
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
var CONTENT_EDITABLE_BINDINGS = ["textContent", "innerHTML", "innerText"];
function is_content_editable_binding(name) {
  return CONTENT_EDITABLE_BINDINGS.includes(name);
}
var LOAD_ERROR_ELEMENTS = [
  "body",
  "embed",
  "iframe",
  "img",
  "link",
  "object",
  "script",
  "style",
  "track"
];
function is_load_error_element(name) {
  return LOAD_ERROR_ELEMENTS.includes(name);
}
var SVG_ELEMENTS = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "discard",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hatch",
  "hatchpath",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "mesh",
  "meshgradient",
  "meshpatch",
  "meshrow",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "solidcolor",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "unknown",
  "use",
  "view",
  "vkern"
];
function is_svg(name) {
  return SVG_ELEMENTS.includes(name);
}
var MATHML_ELEMENTS = [
  "annotation",
  "annotation-xml",
  "maction",
  "math",
  "merror",
  "mfrac",
  "mi",
  "mmultiscripts",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mprescripts",
  "mroot",
  "mrow",
  "ms",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
];
function is_mathml(name) {
  return MATHML_ELEMENTS.includes(name);
}
var STATE_CREATION_RUNES = (
  /** @type {const} */
  [
    "$state",
    "$state.raw",
    "$derived",
    "$derived.by"
  ]
);
var RUNES = (
  /** @type {const} */
  [
    ...STATE_CREATION_RUNES,
    "$state.eager",
    "$state.snapshot",
    "$props",
    "$props.id",
    "$bindable",
    "$effect",
    "$effect.pre",
    "$effect.tracking",
    "$effect.root",
    "$effect.pending",
    "$inspect",
    "$inspect().with",
    "$inspect.trace",
    "$host"
  ]
);
function is_rune(name) {
  return RUNES.includes(
    /** @type {RuneName} */
    name
  );
}
function is_state_creation_rune(name) {
  return STATE_CREATION_RUNES.includes(
    /** @type {StateCreationRuneName} */
    name
  );
}
function sanitize_location(location2) {
  return (
    /** @type {T} */
    location2?.replace(/\//g, "/\u200B")
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/state.js
var warnings = [];
var filename;
var UNKNOWN_FILENAME = "(unknown)";
var component_name = "<unknown>";
var source;
var dev;
var runes = false;
var locator = getLocator("", { offsetLine: 1 });
function set_source(value) {
  source = value;
  locator = getLocator(source, { offsetLine: 1 });
}
function locate_node(node) {
  const loc = (
    /** @type {Location} */
    locator(
      /** @type {number} */
      node.start
    )
  );
  return `${sanitize_location(filename)}:${loc?.line}:${loc.column}`;
}
var warning_filter;
var ignore_stack = [];
var ignore_map = /* @__PURE__ */ new Map();
function push_ignore(ignores) {
  const next2 = /* @__PURE__ */ new Set([...ignore_stack.at(-1) || [], ...ignores]);
  ignore_stack.push(next2);
}
function pop_ignore() {
  ignore_stack.pop();
}
function is_ignored(node, code) {
  return dev && !!ignore_map.get(node)?.some((codes3) => codes3.has(code));
}
function reset(state) {
  dev = false;
  runes = false;
  component_name = UNKNOWN_FILENAME;
  source = "";
  locator = () => void 0;
  filename = (state.filename ?? UNKNOWN_FILENAME).replace(/\\/g, "/");
  warning_filter = state.warning ?? (() => true);
  warnings = [];
}
function adjust(state) {
  const root_dir = state.rootDir?.replace(/\\/g, "/");
  dev = state.dev;
  runes = state.runes;
  component_name = state.component_name ?? UNKNOWN_FILENAME;
  if (typeof root_dir === "string" && filename.startsWith(root_dir)) {
    filename = filename.replace(root_dir, "").replace(/^[/\\]/, "");
  }
  ignore_stack = [];
  ignore_map.clear();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/compile_diagnostic.js
var regex_tabs = /^\t+/;
function tabs_to_spaces(str2) {
  return str2.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source2, line, column) {
  const lines = source2.split("\n");
  const frame_start = Math.max(0, line - 2);
  const frame_end = Math.min(line + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str2, i) => {
    const is_error_line = frame_start + i === line;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (is_error_line) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str2.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str2)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str2)}`;
  }).join("\n");
}
var CompileDiagnostic = class {
  name = "CompileDiagnostic";
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    this.code = code;
    this.message = message;
    if (filename !== UNKNOWN_FILENAME) {
      this.filename = filename;
    }
    if (position) {
      this.position = position;
      this.start = locator(position[0]);
      this.end = locator(position[1]);
      if (this.start && this.end) {
        this.frame = get_code_frame(source, this.start.line - 1, this.end.column);
      }
    }
  }
  toString() {
    let out = `${this.code}: ${this.message}`;
    if (this.filename) {
      out += `
${this.filename}`;
      if (this.start) {
        out += `:${this.start.line}:${this.start.column}`;
      }
    }
    if (this.frame) {
      out += `
${this.frame}`;
    }
    return out;
  }
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      filename: this.filename,
      start: this.start,
      end: this.end,
      position: this.position,
      frame: this.frame
    };
  }
};

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/warnings.js
var InternalCompileWarning = class extends CompileDiagnostic {
  name = "CompileWarning";
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(code, message, position);
  }
};
function w(node, code, message) {
  let stack = ignore_stack;
  if (node) {
    stack = ignore_map.get(node) ?? ignore_stack;
  }
  if (stack && stack.at(-1)?.has(code)) return;
  const warning = new InternalCompileWarning(code, message, node && node.start !== void 0 ? [node.start, node.end ?? node.start] : void 0);
  if (!warning_filter(warning)) return;
  warnings.push(warning);
}
var codes = [
  "a11y_accesskey",
  "a11y_aria_activedescendant_has_tabindex",
  "a11y_aria_attributes",
  "a11y_autocomplete_valid",
  "a11y_autofocus",
  "a11y_click_events_have_key_events",
  "a11y_consider_explicit_label",
  "a11y_distracting_elements",
  "a11y_figcaption_index",
  "a11y_figcaption_parent",
  "a11y_hidden",
  "a11y_img_redundant_alt",
  "a11y_incorrect_aria_attribute_type",
  "a11y_incorrect_aria_attribute_type_boolean",
  "a11y_incorrect_aria_attribute_type_id",
  "a11y_incorrect_aria_attribute_type_idlist",
  "a11y_incorrect_aria_attribute_type_integer",
  "a11y_incorrect_aria_attribute_type_token",
  "a11y_incorrect_aria_attribute_type_tokenlist",
  "a11y_incorrect_aria_attribute_type_tristate",
  "a11y_interactive_supports_focus",
  "a11y_invalid_attribute",
  "a11y_label_has_associated_control",
  "a11y_media_has_caption",
  "a11y_misplaced_role",
  "a11y_misplaced_scope",
  "a11y_missing_attribute",
  "a11y_missing_content",
  "a11y_mouse_events_have_key_events",
  "a11y_no_abstract_role",
  "a11y_no_interactive_element_to_noninteractive_role",
  "a11y_no_noninteractive_element_interactions",
  "a11y_no_noninteractive_element_to_interactive_role",
  "a11y_no_noninteractive_tabindex",
  "a11y_no_redundant_roles",
  "a11y_no_static_element_interactions",
  "a11y_positive_tabindex",
  "a11y_role_has_required_aria_props",
  "a11y_role_supports_aria_props",
  "a11y_role_supports_aria_props_implicit",
  "a11y_unknown_aria_attribute",
  "a11y_unknown_role",
  "bidirectional_control_characters",
  "legacy_code",
  "unknown_code",
  "options_deprecated_accessors",
  "options_deprecated_immutable",
  "options_missing_custom_element",
  "options_removed_enable_sourcemap",
  "options_removed_hydratable",
  "options_removed_loop_guard_timeout",
  "options_renamed_ssr_dom",
  "custom_element_props_identifier",
  "export_let_unused",
  "legacy_component_creation",
  "non_reactive_update",
  "perf_avoid_inline_class",
  "perf_avoid_nested_class",
  "reactive_declaration_invalid_placement",
  "reactive_declaration_module_script_dependency",
  "state_referenced_locally",
  "store_rune_conflict",
  "css_unused_selector",
  "attribute_avoid_is",
  "attribute_global_event_reference",
  "attribute_illegal_colon",
  "attribute_invalid_property_name",
  "attribute_quoted",
  "bind_invalid_each_rest",
  "block_empty",
  "component_name_lowercase",
  "element_implicitly_closed",
  "element_invalid_self_closing_tag",
  "event_directive_deprecated",
  "node_invalid_placement_ssr",
  "script_context_deprecated",
  "script_unknown_attribute",
  "slot_element_deprecated",
  "svelte_component_deprecated",
  "svelte_element_invalid_this",
  "svelte_self_deprecated"
];
function a11y_accesskey(node) {
  w(node, "a11y_accesskey", `Avoid using accesskey
https://svelte.dev/e/a11y_accesskey`);
}
function a11y_aria_activedescendant_has_tabindex(node) {
  w(node, "a11y_aria_activedescendant_has_tabindex", `An element with an aria-activedescendant attribute should have a tabindex value
https://svelte.dev/e/a11y_aria_activedescendant_has_tabindex`);
}
function a11y_aria_attributes(node, name) {
  w(node, "a11y_aria_attributes", `\`<${name}>\` should not have aria-* attributes
https://svelte.dev/e/a11y_aria_attributes`);
}
function a11y_autocomplete_valid(node, value, type) {
  w(node, "a11y_autocomplete_valid", `'${value}' is an invalid value for 'autocomplete' on \`<input type="${type}">\`
https://svelte.dev/e/a11y_autocomplete_valid`);
}
function a11y_autofocus(node) {
  w(node, "a11y_autofocus", `Avoid using autofocus
https://svelte.dev/e/a11y_autofocus`);
}
function a11y_click_events_have_key_events(node) {
  w(node, "a11y_click_events_have_key_events", `Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as \`<button type="button">\` or \`<a>\` might be more appropriate
https://svelte.dev/e/a11y_click_events_have_key_events`);
}
function a11y_consider_explicit_label(node) {
  w(node, "a11y_consider_explicit_label", `Buttons and links should either contain text or have an \`aria-label\`, \`aria-labelledby\` or \`title\` attribute
https://svelte.dev/e/a11y_consider_explicit_label`);
}
function a11y_distracting_elements(node, name) {
  w(node, "a11y_distracting_elements", `Avoid \`<${name}>\` elements
https://svelte.dev/e/a11y_distracting_elements`);
}
function a11y_figcaption_index(node) {
  w(node, "a11y_figcaption_index", `\`<figcaption>\` must be first or last child of \`<figure>\`
https://svelte.dev/e/a11y_figcaption_index`);
}
function a11y_figcaption_parent(node) {
  w(node, "a11y_figcaption_parent", `\`<figcaption>\` must be an immediate child of \`<figure>\`
https://svelte.dev/e/a11y_figcaption_parent`);
}
function a11y_hidden(node, name) {
  w(node, "a11y_hidden", `\`<${name}>\` element should not be hidden
https://svelte.dev/e/a11y_hidden`);
}
function a11y_img_redundant_alt(node) {
  w(node, "a11y_img_redundant_alt", `Screenreaders already announce \`<img>\` elements as an image
https://svelte.dev/e/a11y_img_redundant_alt`);
}
function a11y_incorrect_aria_attribute_type(node, attribute, type) {
  w(node, "a11y_incorrect_aria_attribute_type", `The value of '${attribute}' must be a ${type}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type`);
}
function a11y_incorrect_aria_attribute_type_boolean(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_boolean", `The value of '${attribute}' must be either 'true' or 'false'. It cannot be empty
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_boolean`);
}
function a11y_incorrect_aria_attribute_type_idlist(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_idlist", `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_idlist`);
}
function a11y_incorrect_aria_attribute_type_integer(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_integer", `The value of '${attribute}' must be an integer
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_integer`);
}
function a11y_incorrect_aria_attribute_type_token(node, attribute, values) {
  w(node, "a11y_incorrect_aria_attribute_type_token", `The value of '${attribute}' must be exactly one of ${values}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_token`);
}
function a11y_incorrect_aria_attribute_type_tokenlist(node, attribute, values) {
  w(node, "a11y_incorrect_aria_attribute_type_tokenlist", `The value of '${attribute}' must be a space-separated list of one or more of ${values}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_tokenlist`);
}
function a11y_incorrect_aria_attribute_type_tristate(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_tristate", `The value of '${attribute}' must be exactly one of true, false, or mixed
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_tristate`);
}
function a11y_interactive_supports_focus(node, role) {
  w(node, "a11y_interactive_supports_focus", `Elements with the '${role}' interactive role must have a tabindex value
https://svelte.dev/e/a11y_interactive_supports_focus`);
}
function a11y_invalid_attribute(node, href_value, href_attribute) {
  w(node, "a11y_invalid_attribute", `'${href_value}' is not a valid ${href_attribute} attribute
https://svelte.dev/e/a11y_invalid_attribute`);
}
function a11y_label_has_associated_control(node) {
  w(node, "a11y_label_has_associated_control", `A form label must be associated with a control
https://svelte.dev/e/a11y_label_has_associated_control`);
}
function a11y_media_has_caption(node) {
  w(node, "a11y_media_has_caption", `\`<video>\` elements must have a \`<track kind="captions">\`
https://svelte.dev/e/a11y_media_has_caption`);
}
function a11y_misplaced_role(node, name) {
  w(node, "a11y_misplaced_role", `\`<${name}>\` should not have role attribute
https://svelte.dev/e/a11y_misplaced_role`);
}
function a11y_misplaced_scope(node) {
  w(node, "a11y_misplaced_scope", `The scope attribute should only be used with \`<th>\` elements
https://svelte.dev/e/a11y_misplaced_scope`);
}
function a11y_missing_attribute(node, name, article, sequence2) {
  w(node, "a11y_missing_attribute", `\`<${name}>\` element should have ${article} ${sequence2} attribute
https://svelte.dev/e/a11y_missing_attribute`);
}
function a11y_missing_content(node, name) {
  w(node, "a11y_missing_content", `\`<${name}>\` element should contain text
https://svelte.dev/e/a11y_missing_content`);
}
function a11y_mouse_events_have_key_events(node, event, accompanied_by) {
  w(node, "a11y_mouse_events_have_key_events", `'${event}' event must be accompanied by '${accompanied_by}' event
https://svelte.dev/e/a11y_mouse_events_have_key_events`);
}
function a11y_no_abstract_role(node, role) {
  w(node, "a11y_no_abstract_role", `Abstract role '${role}' is forbidden
https://svelte.dev/e/a11y_no_abstract_role`);
}
function a11y_no_interactive_element_to_noninteractive_role(node, element2, role) {
  w(node, "a11y_no_interactive_element_to_noninteractive_role", `\`<${element2}>\` cannot have role '${role}'
https://svelte.dev/e/a11y_no_interactive_element_to_noninteractive_role`);
}
function a11y_no_noninteractive_element_interactions(node, element2) {
  w(node, "a11y_no_noninteractive_element_interactions", `Non-interactive element \`<${element2}>\` should not be assigned mouse or keyboard event listeners
https://svelte.dev/e/a11y_no_noninteractive_element_interactions`);
}
function a11y_no_noninteractive_element_to_interactive_role(node, element2, role) {
  w(node, "a11y_no_noninteractive_element_to_interactive_role", `Non-interactive element \`<${element2}>\` cannot have interactive role '${role}'
https://svelte.dev/e/a11y_no_noninteractive_element_to_interactive_role`);
}
function a11y_no_noninteractive_tabindex(node) {
  w(node, "a11y_no_noninteractive_tabindex", `noninteractive element cannot have nonnegative tabIndex value
https://svelte.dev/e/a11y_no_noninteractive_tabindex`);
}
function a11y_no_redundant_roles(node, role) {
  w(node, "a11y_no_redundant_roles", `Redundant role '${role}'
https://svelte.dev/e/a11y_no_redundant_roles`);
}
function a11y_no_static_element_interactions(node, element2, handler) {
  w(node, "a11y_no_static_element_interactions", `\`<${element2}>\` with a ${handler} handler must have an ARIA role
https://svelte.dev/e/a11y_no_static_element_interactions`);
}
function a11y_positive_tabindex(node) {
  w(node, "a11y_positive_tabindex", `Avoid tabindex values above zero
https://svelte.dev/e/a11y_positive_tabindex`);
}
function a11y_role_has_required_aria_props(node, role, props) {
  w(node, "a11y_role_has_required_aria_props", `Elements with the ARIA role "${role}" must have the following attributes defined: ${props}
https://svelte.dev/e/a11y_role_has_required_aria_props`);
}
function a11y_role_supports_aria_props(node, attribute, role) {
  w(node, "a11y_role_supports_aria_props", `The attribute '${attribute}' is not supported by the role '${role}'
https://svelte.dev/e/a11y_role_supports_aria_props`);
}
function a11y_role_supports_aria_props_implicit(node, attribute, role, name) {
  w(node, "a11y_role_supports_aria_props_implicit", `The attribute '${attribute}' is not supported by the role '${role}'. This role is implicit on the element \`<${name}>\`
https://svelte.dev/e/a11y_role_supports_aria_props_implicit`);
}
function a11y_unknown_aria_attribute(node, attribute, suggestion) {
  w(node, "a11y_unknown_aria_attribute", `${suggestion ? `Unknown aria attribute 'aria-${attribute}'. Did you mean '${suggestion}'?` : `Unknown aria attribute 'aria-${attribute}'`}
https://svelte.dev/e/a11y_unknown_aria_attribute`);
}
function a11y_unknown_role(node, role, suggestion) {
  w(node, "a11y_unknown_role", `${suggestion ? `Unknown role '${role}'. Did you mean '${suggestion}'?` : `Unknown role '${role}'`}
https://svelte.dev/e/a11y_unknown_role`);
}
function bidirectional_control_characters(node) {
  w(node, "bidirectional_control_characters", `A bidirectional control character was detected in your code. These characters can be used to alter the visual direction of your code and could have unintended consequences
https://svelte.dev/e/bidirectional_control_characters`);
}
function legacy_code(node, code, suggestion) {
  w(node, "legacy_code", `\`${code}\` is no longer valid \u2014 please use \`${suggestion}\` instead
https://svelte.dev/e/legacy_code`);
}
function unknown_code(node, code, suggestion) {
  w(node, "unknown_code", `${suggestion ? `\`${code}\` is not a recognised code (did you mean \`${suggestion}\`?)` : `\`${code}\` is not a recognised code`}
https://svelte.dev/e/unknown_code`);
}
function options_deprecated_accessors(node) {
  w(node, "options_deprecated_accessors", `The \`accessors\` option has been deprecated. It will have no effect in runes mode
https://svelte.dev/e/options_deprecated_accessors`);
}
function options_deprecated_immutable(node) {
  w(node, "options_deprecated_immutable", `The \`immutable\` option has been deprecated. It will have no effect in runes mode
https://svelte.dev/e/options_deprecated_immutable`);
}
function options_missing_custom_element(node) {
  w(node, "options_missing_custom_element", `The \`customElement\` option is used when generating a custom element. Did you forget the \`customElement: true\` compile option?
https://svelte.dev/e/options_missing_custom_element`);
}
function options_removed_enable_sourcemap(node) {
  w(node, "options_removed_enable_sourcemap", `The \`enableSourcemap\` option has been removed. Source maps are always generated now, and tooling can choose to ignore them
https://svelte.dev/e/options_removed_enable_sourcemap`);
}
function options_removed_hydratable(node) {
  w(node, "options_removed_hydratable", `The \`hydratable\` option has been removed. Svelte components are always hydratable now
https://svelte.dev/e/options_removed_hydratable`);
}
function options_removed_loop_guard_timeout(node) {
  w(node, "options_removed_loop_guard_timeout", `The \`loopGuardTimeout\` option has been removed
https://svelte.dev/e/options_removed_loop_guard_timeout`);
}
function options_renamed_ssr_dom(node) {
  w(node, "options_renamed_ssr_dom", `\`generate: "dom"\` and \`generate: "ssr"\` options have been renamed to "client" and "server" respectively
https://svelte.dev/e/options_renamed_ssr_dom`);
}
function custom_element_props_identifier(node) {
  w(node, "custom_element_props_identifier", `Using a rest element or a non-destructured declaration with \`$props()\` means that Svelte can't infer what properties to expose when creating a custom element. Consider destructuring all the props or explicitly specifying the \`customElement.props\` option.
https://svelte.dev/e/custom_element_props_identifier`);
}
function export_let_unused(node, name) {
  w(node, "export_let_unused", `Component has unused export property '${name}'. If it is for external reference only, please consider using \`export const ${name}\`
https://svelte.dev/e/export_let_unused`);
}
function legacy_component_creation(node) {
  w(node, "legacy_component_creation", `Svelte 5 components are no longer classes. Instantiate them using \`mount\` or \`hydrate\` (imported from 'svelte') instead.
https://svelte.dev/e/legacy_component_creation`);
}
function non_reactive_update(node, name) {
  w(node, "non_reactive_update", `\`${name}\` is updated, but is not declared with \`$state(...)\`. Changing its value will not correctly trigger updates
https://svelte.dev/e/non_reactive_update`);
}
function perf_avoid_inline_class(node) {
  w(node, "perf_avoid_inline_class", `Avoid 'new class' \u2014 instead, declare the class at the top level scope
https://svelte.dev/e/perf_avoid_inline_class`);
}
function perf_avoid_nested_class(node) {
  w(node, "perf_avoid_nested_class", `Avoid declaring classes below the top level scope
https://svelte.dev/e/perf_avoid_nested_class`);
}
function reactive_declaration_invalid_placement(node) {
  w(node, "reactive_declaration_invalid_placement", `Reactive declarations only exist at the top level of the instance script
https://svelte.dev/e/reactive_declaration_invalid_placement`);
}
function reactive_declaration_module_script_dependency(node) {
  w(node, "reactive_declaration_module_script_dependency", `Reassignments of module-level declarations will not cause reactive statements to update
https://svelte.dev/e/reactive_declaration_module_script_dependency`);
}
function state_referenced_locally(node, name, type) {
  w(node, "state_referenced_locally", `This reference only captures the initial value of \`${name}\`. Did you mean to reference it inside a ${type} instead?
https://svelte.dev/e/state_referenced_locally`);
}
function store_rune_conflict(node, name) {
  w(node, "store_rune_conflict", `It looks like you're using the \`$${name}\` rune, but there is a local binding called \`${name}\`. Referencing a local variable with a \`$\` prefix will create a store subscription. Please rename \`${name}\` to avoid the ambiguity
https://svelte.dev/e/store_rune_conflict`);
}
function css_unused_selector(node, name) {
  w(node, "css_unused_selector", `Unused CSS selector "${name}"
https://svelte.dev/e/css_unused_selector`);
}
function attribute_avoid_is(node) {
  w(node, "attribute_avoid_is", `The "is" attribute is not supported cross-browser and should be avoided
https://svelte.dev/e/attribute_avoid_is`);
}
function attribute_global_event_reference(node, name) {
  w(node, "attribute_global_event_reference", `You are referencing \`globalThis.${name}\`. Did you forget to declare a variable with that name?
https://svelte.dev/e/attribute_global_event_reference`);
}
function attribute_illegal_colon(node) {
  w(node, "attribute_illegal_colon", `Attributes should not contain ':' characters to prevent ambiguity with Svelte directives
https://svelte.dev/e/attribute_illegal_colon`);
}
function attribute_invalid_property_name(node, wrong, right) {
  w(node, "attribute_invalid_property_name", `'${wrong}' is not a valid HTML attribute. Did you mean '${right}'?
https://svelte.dev/e/attribute_invalid_property_name`);
}
function attribute_quoted(node) {
  w(node, "attribute_quoted", `Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes
https://svelte.dev/e/attribute_quoted`);
}
function bind_invalid_each_rest(node, name) {
  w(node, "bind_invalid_each_rest", `The rest operator (...) will create a new object and binding '${name}' with the original object will not work
https://svelte.dev/e/bind_invalid_each_rest`);
}
function block_empty(node) {
  w(node, "block_empty", `Empty block
https://svelte.dev/e/block_empty`);
}
function component_name_lowercase(node, name) {
  w(node, "component_name_lowercase", `\`<${name}>\` will be treated as an HTML element unless it begins with a capital letter
https://svelte.dev/e/component_name_lowercase`);
}
function element_implicitly_closed(node, tag2, closing) {
  w(node, "element_implicitly_closed", `This element is implicitly closed by the following \`${tag2}\`, which can cause an unexpected DOM structure. Add an explicit \`${closing}\` to avoid surprises.
https://svelte.dev/e/element_implicitly_closed`);
}
function element_invalid_self_closing_tag(node, name) {
  w(node, "element_invalid_self_closing_tag", `Self-closing HTML tags for non-void elements are ambiguous \u2014 use \`<${name} ...></${name}>\` rather than \`<${name} ... />\`
https://svelte.dev/e/element_invalid_self_closing_tag`);
}
function event_directive_deprecated(node, name) {
  w(node, "event_directive_deprecated", `Using \`on:${name}\` to listen to the ${name} event is deprecated. Use the event attribute \`on${name}\` instead
https://svelte.dev/e/event_directive_deprecated`);
}
function node_invalid_placement_ssr(node, message) {
  w(node, "node_invalid_placement_ssr", `${message}. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a \`hydration_mismatch\` warning
https://svelte.dev/e/node_invalid_placement_ssr`);
}
function script_context_deprecated(node) {
  w(node, "script_context_deprecated", `\`context="module"\` is deprecated, use the \`module\` attribute instead
https://svelte.dev/e/script_context_deprecated`);
}
function script_unknown_attribute(node) {
  w(node, "script_unknown_attribute", `Unrecognized attribute \u2014 should be one of \`generics\`, \`lang\` or \`module\`. If this exists for a preprocessor, ensure that the preprocessor removes it
https://svelte.dev/e/script_unknown_attribute`);
}
function slot_element_deprecated(node) {
  w(node, "slot_element_deprecated", `Using \`<slot>\` to render parent content is deprecated. Use \`{@render ...}\` tags instead
https://svelte.dev/e/slot_element_deprecated`);
}
function svelte_component_deprecated(node) {
  w(node, "svelte_component_deprecated", `\`<svelte:component>\` is deprecated in runes mode \u2014 components are dynamic by default
https://svelte.dev/e/svelte_component_deprecated`);
}
function svelte_element_invalid_this(node) {
  w(node, "svelte_element_invalid_this", `\`this\` should be an \`{expression}\`. Using a string attribute value will cause an error in future versions of Svelte
https://svelte.dev/e/svelte_element_invalid_this`);
}
function svelte_self_deprecated(node, name, basename) {
  w(node, "svelte_self_deprecated", `\`<svelte:self>\` is deprecated \u2014 use self-imports (e.g. \`import ${name} from './${basename}'\`) instead
https://svelte.dev/e/svelte_self_deprecated`);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/extract_svelte_ignore.js
var regex_svelte_ignore = /^\s*svelte-ignore\s/;
var replacements = {
  "non-top-level-reactive-declaration": "reactive_declaration_invalid_placement",
  "module-script-reactive-declaration": "reactive_declaration_module_script",
  "empty-block": "block_empty",
  "avoid-is": "attribute_avoid_is",
  "invalid-html-attribute": "attribute_invalid_property_name",
  "a11y-structure": "a11y_figcaption_parent",
  "illegal-attribute-character": "attribute_illegal_colon",
  "invalid-rest-eachblock-binding": "bind_invalid_each_rest",
  "unused-export-let": "export_let_unused"
};
var codes2 = codes.concat(IGNORABLE_RUNTIME_WARNINGS);
function extract_svelte_ignore(offset2, text2, runes2) {
  const match = regex_svelte_ignore.exec(text2);
  if (!match) return [];
  let length = match[0].length;
  offset2 += length;
  const ignores = [];
  if (runes2) {
    for (const match2 of text2.slice(length).matchAll(/([\w$-]+)(,)?/gm)) {
      const code = match2[1];
      if (codes2.includes(code)) {
        ignores.push(code);
      } else {
        const replacement = replacements[code] ?? code.replace(/-/g, "_");
        const start = offset2 + /** @type {number} */
        match2.index;
        const end = start + code.length;
        if (codes2.includes(replacement)) {
          legacy_code({ start, end }, code, replacement);
        } else {
          const suggestion = fuzzymatch(code, codes2);
          unknown_code({ start, end }, code, suggestion);
        }
      }
      if (!match2[2]) {
        break;
      }
    }
  } else {
    for (const match2 of text2.slice(length).matchAll(/[\w$-]+/gm)) {
      const code = match2[0];
      ignores.push(code);
      if (!codes2.includes(code)) {
        const replacement = replacements[code] ?? code.replace(/-/g, "_");
        if (codes2.includes(replacement)) {
          ignores.push(replacement);
        }
      }
    }
  }
  return ignores;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/legacy.js
function remove_surrounding_whitespace_nodes(nodes) {
  const first = nodes.at(0);
  const last = nodes.at(-1);
  if (first?.type === "Text") {
    if (!regex_not_whitespace.test(first.data)) {
      nodes.shift();
    } else {
      first.data = first.data.replace(regex_starts_with_whitespaces, "");
    }
  }
  if (last?.type === "Text") {
    if (!regex_not_whitespace.test(last.data)) {
      nodes.pop();
    } else {
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
  }
}
function convert(source2, ast) {
  const root = (
    /** @type {AST.SvelteNode | Legacy.LegacySvelteNode} */
    ast
  );
  return (
    /** @type {Legacy.LegacyRoot} */
    walk(root, null, {
      _(node, { next: next2 }) {
        delete node.metadata;
        next2();
      },
      // @ts-ignore
      Root(node, { visit }) {
        const { instance, module, options } = node;
        if (
          /** @type {any} */
          options?.__raw__
        ) {
          let idx = node.fragment.nodes.findIndex(
            (node2) => (
              /** @type {any} */
              options.end <= node2.start
            )
          );
          if (idx === -1) {
            idx = node.fragment.nodes.length;
          }
          node.fragment.nodes.splice(
            idx,
            0,
            /** @type {any} */
            options.__raw__
          );
        }
        let start = null;
        let end = null;
        if (node.fragment.nodes.length > 0) {
          const first = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(0)
          );
          const last = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(-1)
          );
          start = first.start;
          end = last.end;
          while (/\s/.test(source2[start])) start += 1;
          while (/\s/.test(source2[end - 1])) end -= 1;
        }
        if (instance) {
          delete instance.attributes;
        }
        if (module) {
          delete module.attributes;
        }
        return {
          html: {
            type: "Fragment",
            start,
            end,
            children: node.fragment.nodes.map((child) => visit(child))
          },
          instance,
          module,
          css: ast.css ? visit(ast.css) : void 0
        };
      },
      AnimateDirective(node) {
        return { ...node, type: "Animation" };
      },
      // @ts-ignore
      AwaitBlock(node, { visit }) {
        let pendingblock = {
          type: "PendingBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: node.pending?.nodes.map((child) => visit(child)) ?? [],
          skip: true
        };
        let thenblock = {
          type: "ThenBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: node.then?.nodes.map((child) => visit(child)) ?? [],
          skip: true
        };
        let catchblock = {
          type: "CatchBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: node.catch?.nodes.map((child) => visit(child)) ?? [],
          skip: true
        };
        if (node.pending) {
          const first = node.pending.nodes.at(0);
          const last = node.pending.nodes.at(-1);
          pendingblock.start = first?.start ?? source2.indexOf("}", node.expression.end) + 1;
          pendingblock.end = last?.end ?? pendingblock.start;
          pendingblock.skip = false;
        }
        if (node.then) {
          const first = node.then.nodes.at(0);
          const last = node.then.nodes.at(-1);
          thenblock.start = pendingblock.end ?? first?.start ?? source2.indexOf("}", node.expression.end) + 1;
          thenblock.end = last?.end ?? source2.lastIndexOf("}", pendingblock.end ?? node.expression.end) + 1;
          thenblock.skip = false;
        }
        if (node.catch) {
          const first = node.catch.nodes.at(0);
          const last = node.catch.nodes.at(-1);
          catchblock.start = thenblock.end ?? pendingblock.end ?? first?.start ?? source2.indexOf("}", node.expression.end) + 1;
          catchblock.end = last?.end ?? source2.lastIndexOf("}", thenblock.end ?? pendingblock.end ?? node.expression.end) + 1;
          catchblock.skip = false;
        }
        return {
          type: "AwaitBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          value: node.value,
          error: node.error,
          pending: pendingblock,
          then: thenblock,
          catch: catchblock
        };
      },
      BindDirective(node) {
        return { ...node, type: "Binding" };
      },
      ClassDirective(node) {
        return { ...node, type: "Class" };
      },
      Comment(node) {
        return {
          ...node,
          ignores: extract_svelte_ignore(node.start, node.data, false)
        };
      },
      ComplexSelector(node, { next: next2 }) {
        next2();
        const children = [];
        for (const child of node.children) {
          if (child.combinator) {
            children.push(child.combinator);
          }
          children.push(...child.selectors);
        }
        return {
          type: "Selector",
          start: node.start,
          end: node.end,
          children
        };
      },
      Component(node, { visit }) {
        return {
          type: "InlineComponent",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      // @ts-ignore
      ConstTag(node) {
        if (
          /** @type {Legacy.LegacyConstTag} */
          node.expression !== void 0
        ) {
          return node;
        }
        const modern_node = (
          /** @type {AST.ConstTag} */
          node
        );
        const { id: left } = { ...modern_node.declaration.declarations[0] };
        delete left.typeAnnotation;
        return {
          type: "ConstTag",
          start: modern_node.start,
          end: node.end,
          expression: {
            type: "AssignmentExpression",
            start: (modern_node.declaration.start ?? 0) + "const ".length,
            end: modern_node.declaration.end ?? 0,
            operator: "=",
            left,
            right: modern_node.declaration.declarations[0].init
          }
        };
      },
      // @ts-ignore
      KeyBlock(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "KeyBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      // @ts-ignore
      EachBlock(node, { visit }) {
        let elseblock = void 0;
        if (node.fallback) {
          const first = node.fallback.nodes.at(0);
          const end = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start = first?.start ?? end;
          remove_surrounding_whitespace_nodes(node.fallback.nodes);
          elseblock = {
            type: "ElseBlock",
            start,
            end,
            children: node.fallback.nodes.map((child) => visit(child))
          };
        }
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "EachBlock",
          start: node.start,
          end: node.end,
          children: node.body.nodes.map((child) => visit(child)),
          context: node.context,
          expression: node.expression,
          index: node.index,
          key: node.key,
          else: elseblock
        };
      },
      ExpressionTag(node, { path }) {
        const parent = path.at(-1);
        if (parent?.type === "Attribute") {
          if (source2[parent.start] === "{") {
            return {
              type: "AttributeShorthand",
              start: node.start,
              end: node.end,
              expression: node.expression
            };
          }
        }
        return {
          type: "MustacheTag",
          start: node.start,
          end: node.end,
          expression: node.expression
        };
      },
      HtmlTag(node) {
        return { ...node, type: "RawMustacheTag" };
      },
      // @ts-ignore
      IfBlock(node, { visit }) {
        let elseblock = void 0;
        if (node.alternate) {
          let nodes = node.alternate.nodes;
          if (nodes.length === 1 && nodes[0].type === "IfBlock" && nodes[0].elseif) {
            nodes = nodes[0].consequent.nodes;
          }
          const end = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start2 = nodes.at(0)?.start ?? end;
          remove_surrounding_whitespace_nodes(node.alternate.nodes);
          elseblock = {
            type: "ElseBlock",
            start: start2,
            end,
            children: node.alternate.nodes.map(
              (child) => (
                /** @type {Legacy.LegacyElementLike} */
                visit(child)
              )
            )
          };
        }
        const start = node.elseif ? node.consequent.nodes[0]?.start ?? source2.lastIndexOf(
          "{",
          /** @type {number} */
          node.end - 1
        ) : node.start;
        remove_surrounding_whitespace_nodes(node.consequent.nodes);
        return {
          type: "IfBlock",
          start,
          end: node.end,
          expression: node.test,
          children: node.consequent.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          ),
          else: elseblock,
          elseif: node.elseif ? true : void 0
        };
      },
      OnDirective(node) {
        return { ...node, type: "EventHandler" };
      },
      // @ts-expect-error
      SnippetBlock(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "SnippetBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          parameters: node.parameters,
          children: node.body.nodes.map((child) => visit(child)),
          typeParams: node.typeParams
        };
      },
      // @ts-expect-error
      SvelteBoundary(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "SvelteBoundary",
          name: "svelte:boundary",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      RegularElement(node, { visit }) {
        return {
          type: "Element",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map((child) => visit(child)),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      SlotElement(node, { visit }) {
        return {
          type: "Slot",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      Attribute(node, { visit, next: next2, path }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path.push(node);
          const value = (
            /** @type {Legacy.LegacyAttribute['value']} */
            [visit(node.value)]
          );
          path.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      StyleDirective(node, { visit, next: next2, path }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path.push(node);
          const value = (
            /** @type {Legacy.LegacyStyleDirective['value']} */
            [visit(node.value)]
          );
          path.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      SpreadAttribute(node) {
        return { ...node, type: "Spread" };
      },
      // @ts-ignore
      StyleSheet(node, context) {
        return {
          ...node,
          ...context.next(),
          type: "Style"
        };
      },
      SvelteBody(node, { visit }) {
        return {
          type: "Body",
          name: "svelte:body",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteComponent(node, { visit }) {
        return {
          type: "InlineComponent",
          name: "svelte:component",
          start: node.start,
          end: node.end,
          expression: node.expression,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteDocument(node, { visit }) {
        return {
          type: "Document",
          name: "svelte:document",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteElement(node, { visit }) {
        let tag2 = node.tag;
        if (tag2.type === "Literal" && typeof tag2.value === "string" && source2[
          /** @type {number} */
          node.tag.start - 1
        ] !== "{") {
          tag2 = tag2.value;
        }
        return {
          type: "Element",
          name: "svelte:element",
          start: node.start,
          end: node.end,
          tag: tag2,
          attributes: node.attributes.map((child) => visit(child)),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      SvelteFragment(node, { visit }) {
        return {
          type: "SlotTemplate",
          name: "svelte:fragment",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (a) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(a)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteHead(node, { visit }) {
        return {
          type: "Head",
          name: "svelte:head",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteOptions(node, { visit }) {
        return {
          type: "Options",
          name: "svelte:options",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          )
        };
      },
      SvelteSelf(node, { visit }) {
        return {
          type: "InlineComponent",
          name: "svelte:self",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteWindow(node, { visit }) {
        return {
          type: "Window",
          name: "svelte:window",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      Text(node, { path }) {
        const parent = path.at(-1);
        if (parent?.type === "RegularElement" && parent.name === "style") {
          return (
            /** @type {AST.Text} */
            {
              type: "Text",
              start: node.start,
              end: node.end,
              data: node.data
            }
          );
        }
      },
      TitleElement(node, { visit }) {
        return {
          type: "Title",
          name: "title",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      TransitionDirective(node) {
        return { ...node, type: "Transition" };
      },
      UseDirective(node) {
        return { ...node, type: "Action" };
      },
      LetDirective(node) {
        return { ...node, type: "Let" };
      }
    })
  );
}

// node_modules/.deno/acorn@8.15.0/node_modules/acorn/dist/acorn.mjs
var acorn_exports = {};
__export(acorn_exports, {
  Node: () => Node,
  Parser: () => Parser,
  Position: () => Position,
  SourceLocation: () => SourceLocation,
  TokContext: () => TokContext,
  Token: () => Token,
  TokenType: () => TokenType,
  defaultOptions: () => defaultOptions,
  getLineInfo: () => getLineInfo,
  isIdentifierChar: () => isIdentifierChar,
  isIdentifierStart: () => isIdentifierStart,
  isNewLine: () => isNewLine,
  keywordTypes: () => keywords,
  lineBreak: () => lineBreak,
  lineBreakG: () => lineBreakG,
  nonASCIIwhitespace: () => nonASCIIwhitespace,
  parse: () => parse3,
  parseExpressionAt: () => parseExpressionAt2,
  tokContexts: () => types,
  tokTypes: () => types$1,
  tokenizer: () => tokenizer2,
  version: () => version
});
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
  if (options === void 0) options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0) end = code.length;
  for (var i = from; i < end; i++) {
    var next2 = code.charCodeAt(i);
    if (isNewLine(next2)) {
      return i < end - 1 && next2 === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || (function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
});
var isArray = Array.isArray || (function(obj) {
  return toString.call(obj) === "[object Array]";
});
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array2) {
  return function(block2, text2, start, end, startLoc, endLoc) {
    var comment = {
      type: block2 ? "Block" : "Line",
      value: text2,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_CLASS_FIELD_INIT = 512;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next2 = this.input.charAt(end);
      return next2 === ";" || next2 === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt2 = this.parseStatement(null, true, exports);
    node.body.push(stmt2);
  }
  if (this.inModule) {
    for (var i = 0, list3 = Object.keys(this.undefinedExports); i < list3.length; i += 1) {
      var name = list3[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next2 + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next2, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next2 + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length;
  if (lineBreak.test(this.input.slice(this.pos, next2))) {
    return false;
  }
  if (isAwaitUsing) {
    var awaitEndPos = next2 + 5, after;
    if (this.input.slice(next2, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
      return false;
    }
    skipWhiteSpace.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
      return false;
    }
  }
  if (isFor) {
    var ofEndPos = next2 + 2, after$1;
    if (this.input.slice(next2, ofEndPos) === "of") {
      if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
        return false;
      }
    }
  }
  var ch = this.input.charCodeAt(next2);
  return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
      if (usingKind) {
        if (topLevel && this.options.sourceType === "script") {
          this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
        }
        if (usingKind === "await using") {
          if (!this.canAwait) {
            this.raise(this.start, "Await using cannot appear outside of async function");
          }
          this.next();
        }
        this.next();
        this.parseVar(node, false, usingKind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node, init$1, awaitAt);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") {
      this.next();
    }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node, init$2, awaitAt);
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init3 = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init3.start === initPos && !containsEsc && init3.type === "Identifier" && init3.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init3.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init3, false, refDestructuringErrors);
    this.checkLValPattern(init3);
    return this.parseForIn(node, init3);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init3);
};
pp$8.parseForAfterInit = function(node, init3, awaitAt) {
  if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init3.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    return this.parseForIn(node, init3);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init3);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list3 = this.labels; i$1 < list3.length; i$1 += 1) {
    var label = list3[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node === void 0) node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node.body.push(stmt2);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init3) {
  node.init = init3;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init3) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init3.type === "VariableDeclaration" && init3.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init3.kind !== "var" || init3.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init3.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init3;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method2, isGenerator, isAsync, allowsDirectSuper) {
  var key2 = method2.key;
  if (method2.kind === "constructor") {
    if (isGenerator) {
      this.raise(key2.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key2.start, "Constructor can't be an async method");
    }
  } else if (method2.static && checkKeyName(method2, "prototype")) {
    this.raise(key2.start, "Classes may not have a static property named prototype");
  }
  var value = method2.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method2.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method2.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method2.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method2, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node.body.push(stmt2);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name = element2.key.name;
  var curr = privateNameMap[name];
  var next2 = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next2 = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key2 = node.key;
  return !computed && (key2.type === "Identifier" && key2.name === name || key2.type === "Literal" && key2.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16) {
      node.attributes = [];
    }
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
    } else {
      for (var i = 0, list3 = node.specifiers; i < list3.length; i += 1) {
        var spec = list3[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
      if (this.options.ecmaVersion >= 16) {
        node.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration2 = this.parseMaybeAssign();
    this.semicolon();
    return declaration2;
  }
};
pp$8.checkExport = function(exports, name, pos) {
  if (!exports) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list3 = pat.properties; i < list3.length; i += 1) {
      var prop2 = list3[i];
      this.checkPatternExport(exports, prop2);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list3 = decls; i < list3.length; i += 1) {
    var decl = list3[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list3 = node.properties; i < list3.length; i += 1) {
          var prop2 = list3[i];
          this.toAssignable(prop2, isBinding);
          if (prop2.type === "RestElement" && (prop2.argument.type === "ArrayPattern" || prop2.argument.type === "ObjectPattern")) {
            this.raise(prop2.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest2 = this.parseRestBinding();
      this.parseBindingListItem(rest2);
      elts.push(rest2);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list3 = expr.properties; i < list3.length; i += 1) {
        var prop2 = list3[i];
        this.checkLValInnerPattern(prop2, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update2, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update2 = type.updateContext) {
    update2.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop2, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop2.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop2.computed || prop2.method || prop2.shorthand)) {
    return;
  }
  var key2 = prop2.key;
  var name;
  switch (key2.type) {
    case "Identifier":
      name = key2.name;
      break;
    case "Literal":
      name = String(key2.value);
      break;
    default:
      return;
  }
  var kind = prop2.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key2.start;
          }
        } else {
          this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key2.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical3 = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical3 || coalesce);
      if (logical3 && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical3) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical3 ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update2 = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update2, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update2) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update2 ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base = element2;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta2 = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta2.name = "import";
    node.meta = this.finishNode(meta2, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta2 = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta2.name = "new";
    node.meta = this.finishNode(meta2, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop2) {
  return !prop2.computed && prop2.key.type === "Identifier" && prop2.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop2 = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop2, propHash, refDestructuringErrors);
    }
    node.properties.push(prop2);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop2 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop2.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop2, "RestElement");
    }
    prop2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop2, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop2.method = false;
    prop2.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop2);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop2)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop2);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop2, "Property");
};
pp$5.parseGetterSetter = function(prop2) {
  var kind = prop2.key.name;
  this.parsePropertyName(prop2);
  prop2.value = this.parseMethod(false);
  prop2.kind = kind;
  var paramCount = prop2.kind === "get" ? 0 : 1;
  if (prop2.value.params.length !== paramCount) {
    var start = prop2.value.start;
    if (prop2.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop2.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop2.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop2.method = true;
    prop2.value = this.parseMethod(isGenerator, isAsync);
    prop2.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop2.computed && prop2.key.type === "Identifier" && (prop2.key.name === "get" || prop2.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop2);
  } else if (this.options.ecmaVersion >= 6 && !prop2.computed && prop2.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop2.key);
    if (prop2.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else {
      prop2.value = this.copyNode(prop2.key);
    }
    prop2.kind = "init";
    prop2.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop2) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop2.computed = true;
      prop2.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop2.key;
    } else {
      prop2.computed = false;
    }
  }
  return prop2.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list3 = params; i < list3.length; i += 1) {
    var param = list3[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list3 = node.params; i < list3.length; i += 1) {
    var param = list3[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err2 = new SyntaxError(message);
  err2.pos = pos;
  err2.loc = loc;
  err2.raisedAt = this.pos;
  throw err2;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop2 in node) {
    newNode[prop2] = node[prop2];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list3 = [9, 10, 11, 12, 13, 14]; i < list3.length; i += 1) {
  ecmaVersion = list3[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list3;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base) {
  this.parent = parent;
  this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset2(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at2(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
    return c;
  }
  var next2 = s.charCodeAt(i + 1);
  return next2 >= 56320 && next2 <= 57343 ? (c << 10) + next2 - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c = s.charCodeAt(i), next2;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next2 = s.charCodeAt(i + 1)) < 56320 || next2 > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i = 0, list3 = chs; i < list3.length; i += 1) {
    var ch = list3[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _2 in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list3 = state.backReferenceNames; i < list3.length; i += 1) {
    var name = list3[i];
    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(
          45
          /* - */
        );
        if (addModifiers || hasHyphen) {
          for (var i = 0; i < addModifiers.length; i++) {
            var modifier = addModifiers.charAt(i);
            if (addModifiers.indexOf(modifier, i + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers2 = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers2 += codePointToString(ch);
    state.advance();
  }
  return modifiers2;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i = 0, list3 = known; i < list3.length; i += 1) {
          var altID = list3[i];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next2 = this.input.charCodeAt(this.pos + 1);
  return next2 <= 56319 || next2 >= 57344 ? code : (code << 10) + next2 - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 >= 48 && next2 <= 57) {
    return this.readNumber(true);
  }
  var next22 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next2 === 42) {
    ++size;
    tokentype = types$1.starstar;
    next2 = this.input.charCodeAt(this.pos + 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code) {
    if (this.options.ecmaVersion >= 12) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code) {
    if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next2 === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next2 === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next2 === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 46) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 < 48 || next22 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next2 === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      return this.readToken_dot();
    // Punctuation tokens.
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 120 || next2 === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next2 === 111 || next2 === 79) {
          return this.readRadixNumber(8);
        }
        if (next2 === 98 || next2 === 66) {
          return this.readRadixNumber(2);
        }
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    // Quotes produce strings.
    case 34:
    case 39:
      return this.readString(code);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str2 = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str2);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e2) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e2 = len == null ? Infinity : len; i < e2; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str2, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str2, 8);
  }
  return parseFloat(str2.replace(/_/g, ""));
}
function stringToBigInt(str2) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str2.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next2 = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next2 === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next2 = this.input.charCodeAt(this.pos);
  }
  if ((next2 === 69 || next2 === 101) && !octal) {
    next2 = this.input.charCodeAt(++this.pos);
    if (next2 === 43 || next2 === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote2) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote2) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err2) {
    if (err2 === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err2;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      // fall through
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      // fall through
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    // 'n' -> '\n'
    case 114:
      return "\r";
    // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'
    case 117:
      return codePointToString(this.readCodePoint());
    // 'u'
    case 116:
      return "	";
    // 't' -> '\t'
    case 98:
      return "\b";
    // 'b' -> '\b'
    case 118:
      return "\v";
    // 'v' -> '\u000b'
    case 102:
      return "\f";
    // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.15.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options) {
  return Parser.parse(input, options);
}
function parseExpressionAt2(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options);
}
function tokenizer2(input, options) {
  return Parser.tokenizer(input, options);
}

// node_modules/.deno/@sveltejs+acorn-typescript@1.0.7/node_modules/@sveltejs/acorn-typescript/index.js
var startsExpr2 = true;
function kwLike(_name, options = {}) {
  return new TokenType("name", options);
}
var acornTypeScriptMap = /* @__PURE__ */ new WeakMap();
var keywordTypeValues = Object.values(keywords);
function generateAcornTypeScript(_acorn) {
  const acorn = _acorn.Parser.acorn || _acorn;
  let acornTypeScript = acornTypeScriptMap.get(acorn);
  if (!acornTypeScript) {
    let tokenIsLiteralPropertyName = function(token) {
      return token === types$1.name || token === types$1.string || token === types$1.num || keywordTypeValues.includes(token) || tsKwTokenTypeValues.includes(token);
    }, tokenIsKeywordOrIdentifier = function(token) {
      return token === types$1.name || keywordTypeValues.includes(token) || tsKwTokenTypeValues.includes(token);
    }, tokenIsIdentifier = function(token) {
      return token === types$1.name || tsKwTokenTypeValues.includes(token);
    }, tokenIsTSDeclarationStart = function(token) {
      return token === tsKwTokenType.abstract || token === tsKwTokenType.declare || token === tsKwTokenType.enum || token === tsKwTokenType.module || token === tsKwTokenType.namespace || token === tsKwTokenType.interface || token === tsKwTokenType.type;
    }, tokenIsTSTypeOperator = function(token) {
      return token === tsKwTokenType.keyof || token === tsKwTokenType.readonly || token === tsKwTokenType.unique;
    }, tokenIsTemplate = function(token) {
      return token === types$1.invalidTemplate;
    };
    const tsKwTokenType = generateTsKwTokenType();
    const tsKwTokenTypeValues = Object.values(tsKwTokenType);
    const tsTokenType = generateTsTokenType();
    const tsTokenContext = generateTsTokenContext();
    const tsKeywordsRegExp = new RegExp(`^(?:${Object.keys(tsKwTokenType).join("|")})$`);
    tsTokenType.jsxTagStart.updateContext = function() {
      this.context.push(tsTokenContext.tc_expr);
      this.context.push(tsTokenContext.tc_oTag);
      this.exprAllowed = false;
    };
    tsTokenType.jsxTagEnd.updateContext = function(prevType) {
      let out = this.context.pop();
      if (out === tsTokenContext.tc_oTag && prevType === types$1.slash || out === tsTokenContext.tc_cTag) {
        this.context.pop();
        this.exprAllowed = this.curContext() === tsTokenContext.tc_expr;
      } else {
        this.exprAllowed = true;
      }
    };
    acornTypeScript = {
      tokTypes: {
        ...tsKwTokenType,
        ...tsTokenType
      },
      tokContexts: {
        ...tsTokenContext
      },
      keywordsRegExp: tsKeywordsRegExp,
      tokenIsLiteralPropertyName,
      tokenIsKeywordOrIdentifier,
      tokenIsIdentifier,
      tokenIsTSDeclarationStart,
      tokenIsTSTypeOperator,
      tokenIsTemplate
    };
  }
  return acornTypeScript;
}
function generateTsTokenContext() {
  return {
    tc_oTag: new TokContext("<tag", false, false),
    tc_cTag: new TokContext("</tag", false, false),
    tc_expr: new TokContext("<tag>...</tag>", true, true)
  };
}
function generateTsTokenType() {
  return {
    // @ts-expect-error
    at: new TokenType("@"),
    // @ts-expect-error
    jsxName: new TokenType("jsxName"),
    // @ts-expect-error
    jsxText: new TokenType("jsxText", { beforeExpr: true }),
    // @ts-expect-error
    jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
    // @ts-expect-error
    jsxTagEnd: new TokenType("jsxTagEnd")
  };
}
function generateTsKwTokenType() {
  return {
    assert: kwLike("assert", { startsExpr: startsExpr2 }),
    asserts: kwLike("asserts", { startsExpr: startsExpr2 }),
    global: kwLike("global", { startsExpr: startsExpr2 }),
    keyof: kwLike("keyof", { startsExpr: startsExpr2 }),
    readonly: kwLike("readonly", { startsExpr: startsExpr2 }),
    unique: kwLike("unique", { startsExpr: startsExpr2 }),
    abstract: kwLike("abstract", { startsExpr: startsExpr2 }),
    declare: kwLike("declare", { startsExpr: startsExpr2 }),
    enum: kwLike("enum", { startsExpr: startsExpr2 }),
    module: kwLike("module", { startsExpr: startsExpr2 }),
    namespace: kwLike("namespace", { startsExpr: startsExpr2 }),
    interface: kwLike("interface", { startsExpr: startsExpr2 }),
    type: kwLike("type", { startsExpr: startsExpr2 })
  };
}
var TS_SCOPE_OTHER = 512;
var TS_SCOPE_TS_MODULE = 1024;
var BIND_KIND_VALUE = 1;
var BIND_KIND_TYPE = 2;
var BIND_SCOPE_VAR = 4;
var BIND_SCOPE_LEXICAL = 8;
var BIND_SCOPE_FUNCTION = 16;
var BIND_FLAGS_NONE = 64;
var BIND_FLAGS_CLASS = 128;
var BIND_FLAGS_TS_ENUM = 256;
var BIND_FLAGS_TS_CONST_ENUM = 512;
var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
var BIND_LEXICAL2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
var BIND_VAR2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
var BIND_FUNCTION2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
var BIND_NONE2 = 0 | 0 | 0 | BIND_FLAGS_NONE;
var BIND_OUTSIDE2 = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
var CLASS_ELEMENT_FLAG_STATIC = 4;
var CLASS_ELEMENT_KIND_GETTER = 2;
var CLASS_ELEMENT_KIND_SETTER = 1;
var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
var skipWhiteSpaceToLineBreak = new RegExp(
  // Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or
  // possessive quantifiers, so we use a trick to prevent backtracking
  // when the look-ahead for line terminator fails.
  "(?=(" + // Capture the whitespace and comments that should be skipped inside
  // a look-ahead assertion, and then re-match the group as a unit.
  skipWhiteSpaceInLine.source + "))\\1" + // Look-ahead for either line terminator, start of multi-line comment,
  // or end of string.
  /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
  "y"
  // sticky
);
var DestructuringErrors3 = class {
  constructor() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  }
};
function isPrivateNameConflicted2(privateNameMap, element2) {
  const name = element2.key.name;
  const curr = privateNameMap[name];
  let next2 = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next2 = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName2(node, name) {
  const { computed, key: key2 } = node;
  return !computed && (key2.type === "Identifier" && key2.name === name || key2.type === "Literal" && key2.value === name);
}
var TypeScriptError = {
  AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  CannotFindName: ({ name }) => `Cannot find name '${name}'.`,
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: (
    // `Accessibility modifier already seen: ${modifier}` would be more helpful.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (() => `Accessibility modifier already seen.`)
  ),
  DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`,
  // `token` matches the terminology used by typescript:
  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915
  EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  IncompatibleModifiers: ({ modifiers: modifiers2 }) => `'${modifiers2[0]}' modifier cannot be used with '${modifiers2[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
  PrivateMethodsHasAccessibility: ({ modifier }) => `Private methods cannot have an accessibility modifier ('${modifier}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  GenericsEndWithComma: `Trailing comma is not allowed at the end of generics.`,
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations."
};
var DecoratorsError = {
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  TrailingDecorator: "Decorators must be attached to a class element.",
  SpreadElementDecorator: `Decorators can't be used with SpreadElement`
};
function generateParseDecorators(Parse, acornTypeScript, acorn) {
  const { tokTypes: tt2 } = acorn;
  const { tokTypes: tokTypes2 } = acornTypeScript;
  return class ParseDecorators extends Parse {
    takeDecorators(node) {
      const decorators = this.decoratorStack[this.decoratorStack.length - 1];
      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.decoratorStack[this.decoratorStack.length - 1] = [];
      }
    }
    parseDecorators(allowExport) {
      const currentContextDecorators = this.decoratorStack[this.decoratorStack.length - 1];
      while (this.match(tokTypes2.at)) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }
      if (this.match(tt2._export)) {
        if (!allowExport) {
          this.unexpected();
        }
      } else if (!this.canHaveLeadingDecorator()) {
        this.raise(this.start, DecoratorsError.UnexpectedLeadingDecorator);
      }
    }
    parseDecorator() {
      const node = this.startNode();
      this.next();
      this.decoratorStack.push([]);
      const startPos = this.start;
      const startLoc = this.startLoc;
      let expr;
      if (this.match(tt2.parenL)) {
        const startPos2 = this.start;
        const startLoc2 = this.startLoc;
        this.next();
        expr = this.parseExpression();
        this.expect(tt2.parenR);
        if (this.options.preserveParens) {
          let par = this.startNodeAt(startPos2, startLoc2);
          par.expression = expr;
          expr = this.finishNode(par, "ParenthesizedExpression");
        }
      } else {
        expr = this.parseIdent(false);
        while (this.eat(tt2.dot)) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.object = expr;
          node2.property = this.parseIdent(true);
          node2.computed = false;
          expr = this.finishNode(node2, "MemberExpression");
        }
      }
      node.expression = this.parseMaybeDecoratorArguments(expr);
      this.decoratorStack.pop();
      return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(tt2.parenL)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseExprList(tt2.parenR, false);
        return this.finishNode(node, "CallExpression");
      }
      return expr;
    }
  };
}
var xhtml_default = {
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};
var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;
function getQualifiedJSXName(object4) {
  if (!object4) return object4;
  if (object4.type === "JSXIdentifier") return object4.name;
  if (object4.type === "JSXNamespacedName") return object4.namespace.name + ":" + object4.name.name;
  if (object4.type === "JSXMemberExpression")
    return getQualifiedJSXName(object4.object) + "." + getQualifiedJSXName(object4.property);
}
function generateJsxParser(acorn, acornTypeScript, Parser4, jsxOptions) {
  const tt2 = acorn.tokTypes;
  const tok = acornTypeScript.tokTypes;
  const isNewLine2 = acorn.isNewLine;
  const isIdentifierChar2 = acorn.isIdentifierChar;
  const options = Object.assign(
    {
      allowNamespaces: true,
      allowNamespacedObjects: true
    },
    jsxOptions || {}
  );
  return class JsxParser extends Parser4 {
    // Reads inline JSX contents token.
    jsx_readToken() {
      let out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated JSX contents");
        let ch = this.input.charCodeAt(this.pos);
        switch (ch) {
          case 60:
          // '<'
          case 123:
            if (this.pos === this.start) {
              if (ch === 60 && this.exprAllowed) {
                ++this.pos;
                return this.finishToken(tok.jsxTagStart);
              }
              return this.getTokenFromCode(ch);
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(tok.jsxText, out);
          case 38:
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readEntity();
            chunkStart = this.pos;
            break;
          case 62:
          // '>'
          case 125:
            this.raise(
              this.pos,
              "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
            );
          default:
            if (isNewLine2(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(true);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
        }
      }
    }
    jsx_readNewLine(normalizeCRLF) {
      let ch = this.input.charCodeAt(this.pos);
      let out;
      ++this.pos;
      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      return out;
    }
    jsx_readString(quote2) {
      let out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
        let ch = this.input.charCodeAt(this.pos);
        if (ch === quote2) break;
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readEntity();
          chunkStart = this.pos;
        } else if (isNewLine2(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readNewLine(false);
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(tt2.string, out);
    }
    jsx_readEntity() {
      let str2 = "", count = 0, entity;
      let ch = this.input[this.pos];
      if (ch !== "&") this.raise(this.pos, "Entity must start with an ampersand");
      let startPos = ++this.pos;
      while (this.pos < this.input.length && count++ < 10) {
        ch = this.input[this.pos++];
        if (ch === ";") {
          if (str2[0] === "#") {
            if (str2[1] === "x") {
              str2 = str2.substr(2);
              if (hexNumber.test(str2)) entity = String.fromCharCode(parseInt(str2, 16));
            } else {
              str2 = str2.substr(1);
              if (decimalNumber.test(str2)) entity = String.fromCharCode(parseInt(str2, 10));
            }
          } else {
            entity = xhtml_default[str2];
          }
          break;
        }
        str2 += ch;
      }
      if (!entity) {
        this.pos = startPos;
        return "&";
      }
      return entity;
    }
    // Read a JSX identifier (valid tag or attribute name).
    //
    // Optimized version since JSX identifiers can't contain
    // escape characters and so can be read as single slice.
    // Also assumes that first character was already checked
    // by isIdentifierStart in readToken.
    jsx_readWord() {
      let ch, start = this.pos;
      do {
        ch = this.input.charCodeAt(++this.pos);
      } while (isIdentifierChar2(ch) || ch === 45);
      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
    }
    // Parse next token as JSX identifier
    jsx_parseIdentifier() {
      let node = this.startNode();
      if (this.type === tok.jsxName) node.name = this.value;
      else if (this.type.keyword) node.name = this.type.keyword;
      else this.unexpected();
      this.next();
      return this.finishNode(node, "JSXIdentifier");
    }
    // Parse namespaced identifier.
    jsx_parseNamespacedName() {
      let startPos = this.start, startLoc = this.startLoc;
      let name = this.jsx_parseIdentifier();
      if (!options.allowNamespaces || !this.eat(tt2.colon)) return name;
      var node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsx_parseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    }
    // Parses element name in any form - namespaced, member
    // or single identifier.
    jsx_parseElementName() {
      if (this.type === tok.jsxTagEnd) return "";
      let startPos = this.start, startLoc = this.startLoc;
      let node = this.jsx_parseNamespacedName();
      if (this.type === tt2.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
        this.unexpected();
      }
      while (this.eat(tt2.dot)) {
        let newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsx_parseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node;
    }
    // Parses any type of JSX attribute value.
    jsx_parseAttributeValue() {
      switch (this.type) {
        case tt2.braceL:
          let node = this.jsx_parseExpressionContainer();
          if (node.expression.type === "JSXEmptyExpression")
            this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
          return node;
        case tok.jsxTagStart:
        case tt2.string:
          return this.parseExprAtom();
        default:
          this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
      }
    }
    // JSXEmptyExpression is unique type since it doesn't actually parse anything,
    // and so it should start at the end of last read token (left brace) and finish
    // at the beginning of the next one (right brace).
    jsx_parseEmptyExpression() {
      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
    }
    // Parses JSX expression enclosed into curly brackets.
    jsx_parseExpressionContainer() {
      let node = this.startNode();
      this.next();
      node.expression = this.type === tt2.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
      this.expect(tt2.braceR);
      return this.finishNode(node, "JSXExpressionContainer");
    }
    // Parses following JSX attribute name-value pair.
    jsx_parseAttribute() {
      let node = this.startNode();
      if (this.eat(tt2.braceL)) {
        this.expect(tt2.ellipsis);
        node.argument = this.parseMaybeAssign();
        this.expect(tt2.braceR);
        return this.finishNode(node, "JSXSpreadAttribute");
      }
      node.name = this.jsx_parseNamespacedName();
      node.value = this.eat(tt2.eq) ? this.jsx_parseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    }
    // Parses JSX opening tag starting after '<'.
    jsx_parseOpeningElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      node.attributes = [];
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      while (this.type !== tt2.slash && this.type !== tok.jsxTagEnd)
        node.attributes.push(this.jsx_parseAttribute());
      node.selfClosing = this.eat(tt2.slash);
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
    }
    // Parses JSX closing tag starting after '</'.
    jsx_parseClosingElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
    }
    // Parses entire JSX element, including it's opening tag
    // (starting after '<'), attributes, contents and closing tag.
    jsx_parseElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let children = [];
      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents: for (; ; ) {
          switch (this.type) {
            case tok.jsxTagStart:
              startPos = this.start;
              startLoc = this.startLoc;
              this.next();
              if (this.eat(tt2.slash)) {
                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                break contents;
              }
              children.push(this.jsx_parseElementAt(startPos, startLoc));
              break;
            case tok.jsxText:
              children.push(this.parseExprAtom());
              break;
            case tt2.braceL:
              children.push(this.jsx_parseExpressionContainer());
              break;
            default:
              this.unexpected();
          }
        }
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(
            closingElement.start,
            "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
          );
        }
      }
      let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
      node["opening" + fragmentOrElement] = openingElement;
      node["closing" + fragmentOrElement] = closingElement;
      node.children = children;
      if (this.type === tt2.relational && this.value === "<") {
        this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
      }
      return this.finishNode(node, "JSX" + fragmentOrElement);
    }
    // Parse JSX text
    jsx_parseText() {
      let node = this.parseLiteral(this.value);
      node.type = "JSXText";
      return node;
    }
    // Parses entire JSX element from current position.
    jsx_parseElement() {
      let startPos = this.start, startLoc = this.startLoc;
      this.next();
      return this.jsx_parseElementAt(startPos, startLoc);
    }
  };
}
function generateParseImportAssertions(Parse, acornTypeScript, acorn) {
  const { tokTypes: tokTypes2 } = acornTypeScript;
  const { tokTypes: tt2 } = acorn;
  return class ImportAttributes extends Parse {
    parseMaybeImportAttributes(node) {
      if (this.type === tt2._with || this.type === tokTypes2.assert) {
        this.next();
        const attributes = this.parseImportAttributes();
        if (attributes) {
          node.attributes = attributes;
        }
      }
    }
    parseImportAttributes() {
      this.expect(tt2.braceL);
      const attrs = this.parseWithEntries();
      this.expect(tt2.braceR);
      return attrs;
    }
    parseWithEntries() {
      const attrs = [];
      const attrNames = /* @__PURE__ */ new Set();
      do {
        if (this.type === tt2.braceR) {
          break;
        }
        const node = this.startNode();
        let withionKeyNode;
        if (this.type === tt2.string) {
          withionKeyNode = this.parseLiteral(this.value);
        } else {
          withionKeyNode = this.parseIdent(true);
        }
        this.next();
        node.key = withionKeyNode;
        if (attrNames.has(node.key.name)) {
          this.raise(this.pos, "Duplicated key in attributes");
        }
        attrNames.add(node.key.name);
        if (this.type !== tt2.string) {
          this.raise(this.pos, "Only string is supported as an attribute value");
        }
        node.value = this.parseLiteral(this.value);
        attrs.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(tt2.comma));
      return attrs;
    }
  };
}
var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function assert(x2) {
  if (!x2) {
    throw new Error("Assert fail");
  }
}
function tsIsClassAccessor(modifier) {
  return modifier === "accessor";
}
function tsIsVarianceAnnotations(modifier) {
  return modifier === "in" || modifier === "out";
}
var FUNC_STATEMENT2 = 1;
var FUNC_HANGING_STATEMENT2 = 2;
var FUNC_NULLABLE_ID2 = 4;
var acornScope = {
  SCOPE_TOP: 1,
  SCOPE_FUNCTION: 2,
  SCOPE_ASYNC: 4,
  SCOPE_GENERATOR: 8,
  SCOPE_ARROW: 16,
  SCOPE_SIMPLE_CATCH: 32,
  SCOPE_SUPER: 64,
  SCOPE_DIRECT_SUPER: 128,
  SCOPE_CLASS_STATIC_BLOCK: 256,
  SCOPE_VAR: 256,
  BIND_NONE: 0,
  // Not a binding
  BIND_VAR: 1,
  // Var-style binding
  BIND_LEXICAL: 2,
  // Let- or const-style binding
  BIND_FUNCTION: 3,
  // Function declaration
  BIND_SIMPLE_CATCH: 4,
  // Simple (identifier pattern) catch binding
  BIND_OUTSIDE: 5,
  // Special case for function names as bound inside the
  BIND_TS_TYPE: 6,
  BIND_TS_INTERFACE: 7,
  BIND_TS_NAMESPACE: 8,
  BIND_FLAGS_TS_EXPORT_ONLY: 1024,
  BIND_FLAGS_TS_IMPORT: 4096,
  BIND_FLAGS_TS_ENUM: 256,
  BIND_FLAGS_TS_CONST_ENUM: 512,
  BIND_FLAGS_CLASS: 128
  // function
};
function functionFlags2(async, generator) {
  return acornScope.SCOPE_FUNCTION | (async ? acornScope.SCOPE_ASYNC : 0) | (generator ? acornScope.SCOPE_GENERATOR : 0);
}
function isPossiblyLiteralEnum(expression) {
  if (expression.type !== "MemberExpression") return false;
  const { computed, property } = expression;
  if (computed && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
    return false;
  }
  return isUncomputedMemberExpressionChain(expression.object);
}
function isUncomputedMemberExpressionChain(expression) {
  if (expression.type === "Identifier") return true;
  if (expression.type !== "MemberExpression") return false;
  if (expression.computed) return false;
  return isUncomputedMemberExpressionChain(expression.object);
}
function tsIsAccessModifier(modifier) {
  return modifier === "private" || modifier === "public" || modifier === "protected";
}
function tokenCanStartExpression(token) {
  return Boolean(token.startsExpr);
}
function nonNull(x2) {
  if (x2 == null) {
    throw new Error(`Unexpected ${x2} value.`);
  }
  return x2;
}
function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return void 0;
  }
}
function tsPlugin(options) {
  const { dts = false } = options || {};
  const disallowAmbiguousJSXLike = !!options?.jsx;
  return function(Parser4) {
    const _acorn = Parser4.acorn || acorn_exports;
    const acornTypeScript = generateAcornTypeScript(_acorn);
    const tt2 = _acorn.tokTypes;
    const keywordTypes2 = _acorn.keywordTypes;
    const isIdentifierStart2 = _acorn.isIdentifierStart;
    const lineBreak2 = _acorn.lineBreak;
    const isNewLine2 = _acorn.isNewLine;
    const tokContexts = _acorn.tokContexts;
    const isIdentifierChar2 = _acorn.isIdentifierChar;
    const {
      tokTypes: tokTypes2,
      tokContexts: tsTokContexts,
      keywordsRegExp,
      tokenIsLiteralPropertyName,
      tokenIsTemplate,
      tokenIsTSDeclarationStart,
      tokenIsIdentifier,
      tokenIsKeywordOrIdentifier,
      tokenIsTSTypeOperator
    } = acornTypeScript;
    function nextLineBreak2(code, from, end = code.length) {
      for (let i = from; i < end; i++) {
        let next2 = code.charCodeAt(i);
        if (isNewLine2(next2))
          return i < end - 1 && next2 === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
      }
      return -1;
    }
    Parser4 = generateParseDecorators(Parser4, acornTypeScript, _acorn);
    if (options?.jsx) {
      Parser4 = generateJsxParser(
        _acorn,
        acornTypeScript,
        Parser4,
        typeof options.jsx === "boolean" ? {} : options.jsx
      );
    }
    Parser4 = generateParseImportAssertions(Parser4, acornTypeScript, _acorn);
    class TypeScriptParser extends Parser4 {
      constructor(options2, input, startPos) {
        super(options2, input, startPos);
        this.preValue = null;
        this.preToken = null;
        this.isLookahead = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.inType = false;
        this.inDisallowConditionalTypesContext = false;
        this.maybeInArrowParameters = false;
        this.shouldParseArrowReturnType = void 0;
        this.shouldParseAsyncArrowReturnType = void 0;
        this.decoratorStack = [[]];
        this.importsStack = [[]];
        this.importOrExportOuterKind = void 0;
        this.tsParseConstModifier = (node) => {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["const"],
            // for better error recovery
            disallowedModifiers: ["in", "out"],
            errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
          });
        };
        this.ecmaVersion = this.options.ecmaVersion;
      }
      // support in Class static
      static get acornTypeScript() {
        return acornTypeScript;
      }
      // support in runtime, get acornTypeScript be this
      get acornTypeScript() {
        return acornTypeScript;
      }
      getTokenFromCodeInType(code) {
        if (code === 62) {
          return this.finishOp(tt2.relational, 1);
        }
        if (code === 60) {
          return this.finishOp(tt2.relational, 1);
        }
        return super.getTokenFromCode(code);
      }
      readToken(code) {
        if (!this.inType) {
          let context = this.curContext();
          if (context === tsTokContexts.tc_expr) return this.jsx_readToken();
          if (context === tsTokContexts.tc_oTag || context === tsTokContexts.tc_cTag) {
            if (isIdentifierStart2(code)) return this.jsx_readWord();
            if (code == 62) {
              ++this.pos;
              return this.finishToken(tokTypes2.jsxTagEnd);
            }
            if ((code === 34 || code === 39) && context == tsTokContexts.tc_oTag)
              return this.jsx_readString(code);
          }
          if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            if (options?.jsx) {
              return this.finishToken(tokTypes2.jsxTagStart);
            } else {
              return this.finishToken(tt2.relational, "<");
            }
          }
        }
        return super.readToken(code);
      }
      getTokenFromCode(code) {
        if (this.inType) {
          return this.getTokenFromCodeInType(code);
        }
        if (code === 64) {
          ++this.pos;
          return this.finishToken(tokTypes2.at);
        }
        return super.getTokenFromCode(code);
      }
      isAbstractClass() {
        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt2._class;
      }
      finishNode(node, type) {
        if (node.type !== "" && node.end !== 0) {
          return node;
        }
        return super.finishNode(node, type);
      }
      // tryParse will clone parser state.
      // It is expensive and should be used with cautions
      tryParse(fn, oldState = this.cloneCurLookaheadState()) {
        const abortSignal = { node: null };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.getCurLookaheadState();
          this.setLookaheadState(oldState);
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        refExpressionErrors.optionalParametersLoc = resultError?.loc ?? this.startLoc;
      }
      // used after we have finished parsing types
      reScan_lt_gt() {
        if (this.type === tt2.relational) {
          this.pos -= 1;
          this.readToken_lt_gt(this.fullCharCodeAtPos());
        }
      }
      reScan_lt() {
        const { type } = this;
        if (type === tt2.bitShift) {
          this.pos -= 2;
          this.finishOp(tt2.relational, 1);
          return tt2.relational;
        }
        return type;
      }
      resetEndLocation(node, endPos = this.lastTokEnd, endLoc = this.lastTokEndLoc) {
        node.end = endPos;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = endPos;
      }
      startNodeAtNode(type) {
        return super.startNodeAt(type.start, type.loc.start);
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.pos);
      }
      tsHasSomeModifiers(member2, modifiers2) {
        return modifiers2.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member2.accessibility === modifier;
          }
          return !!member2[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual("static") && this.lookaheadCharCode() === 123;
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if (node?.type === "TSTypeCastExpression") {
            this.raise(node.typeAnnotation.start, TypeScriptError.UnexpectedTypeAnnotation);
          }
        });
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.potentialArrowAt;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.type);
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(tt2.colon) ? this.tsParseTypeOrTypePredicateAnnotation(tt2.colon) : void 0;
      }
      tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit) {
        if (!this.tsMatchLeftRelational()) {
          return void 0;
        }
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        this.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(tt2.arrow);
          return node;
        });
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) {
          return void 0;
        }
        return super.parseArrowExpression(
          res,
          /* params are already set */
          null,
          /* async */
          true,
          /* forInit */
          forInit
        );
      }
      // Used when parsing type arguments from ES productions, where the first token
      // has been created without state.inType. Thus we need to rescan the lt token.
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== tt2.relational) {
          return void 0;
        }
        return this.tsParseTypeArguments();
      }
      tsInNoContext(cb) {
        const oldContext = this.context;
        this.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.context = oldContext;
        }
      }
      tsTryParseTypeAnnotation() {
        return this.match(tt2.colon) ? this.tsParseTypeAnnotation() : void 0;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar2(nextCh) || // check if `nextCh is between 0xd800 - 0xdbff,
          // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function
          // returns true
          (nextCh & 64512) === 55296);
        }
        return false;
      }
      isAbstractConstructorSignature() {
        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt2._new;
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace2.lastIndex = pos;
        return skipWhiteSpace2.test(this.input) ? skipWhiteSpace2.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      compareLookaheadState(state, state2) {
        for (const key2 of Object.keys(state)) {
          if (state[key2] !== state2[key2]) return false;
        }
        return true;
      }
      createLookaheadState() {
        this.value = null;
        this.context = [this.curContext()];
      }
      getCurLookaheadState() {
        return {
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokStartLoc: this.lastTokStartLoc,
          pos: this.pos,
          value: this.value,
          type: this.type,
          start: this.start,
          end: this.end,
          context: this.context,
          startLoc: this.startLoc,
          lastTokEndLoc: this.lastTokEndLoc,
          curLine: this.curLine,
          lineStart: this.lineStart,
          curPosition: this.curPosition,
          containsEsc: this.containsEsc
        };
      }
      cloneCurLookaheadState() {
        return {
          pos: this.pos,
          value: this.value,
          type: this.type,
          start: this.start,
          end: this.end,
          context: this.context && this.context.slice(),
          startLoc: this.startLoc,
          lastTokEndLoc: this.lastTokEndLoc,
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokStartLoc: this.lastTokStartLoc,
          curLine: this.curLine,
          lineStart: this.lineStart,
          curPosition: this.curPosition,
          containsEsc: this.containsEsc
        };
      }
      setLookaheadState(state) {
        this.pos = state.pos;
        this.value = state.value;
        this.endLoc = state.endLoc;
        this.lastTokEnd = state.lastTokEnd;
        this.lastTokStart = state.lastTokStart;
        this.lastTokStartLoc = state.lastTokStartLoc;
        this.type = state.type;
        this.start = state.start;
        this.end = state.end;
        this.context = state.context;
        this.startLoc = state.startLoc;
        this.lastTokEndLoc = state.lastTokEndLoc;
        this.curLine = state.curLine;
        this.lineStart = state.lineStart;
        this.curPosition = state.curPosition;
        this.containsEsc = state.containsEsc;
      }
      // Utilities
      tsLookAhead(f) {
        const state = this.getCurLookaheadState();
        const res = f();
        this.setLookaheadState(state);
        return res;
      }
      lookahead(number) {
        const oldState = this.getCurLookaheadState();
        this.createLookaheadState();
        this.isLookahead = true;
        if (number !== void 0) {
          for (let i = 0; i < number; i++) {
            this.nextToken();
          }
        } else {
          this.nextToken();
        }
        this.isLookahead = false;
        const curState = this.getCurLookaheadState();
        this.setLookaheadState(oldState);
        return curState;
      }
      readWord() {
        let word = this.readWord1();
        let type = tt2.name;
        if (this.keywords.test(word)) {
          type = keywordTypes2[word];
        } else if (new RegExp(keywordsRegExp).test(word)) {
          type = tokTypes2[word];
        }
        return this.finishToken(type, word);
      }
      skipBlockComment() {
        let startLoc;
        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
        let start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
        this.pos = end + 2;
        if (this.options.locations) {
          for (let nextBreak, pos = start; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.isLookahead) return;
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      }
      skipLineComment(startSkip) {
        let start = this.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
        let ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine2(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.isLookahead) return;
        if (this.options.onComment)
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
      }
      finishToken(type, val) {
        this.preValue = this.value;
        this.preToken = this.type;
        this.end = this.pos;
        if (this.options.locations) this.endLoc = this.curPosition();
        let prevType = this.type;
        this.type = type;
        this.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      resetStartLocation(node, start, startLoc) {
        node.start = start;
        node.loc.start = startLoc;
        if (this.options.ranges) node.range[0] = start;
      }
      isLineTerminator() {
        return this.eat(tt2.semi) || super.canInsertSemicolon();
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      addExtra(node, key2, value, enumerable = true) {
        if (!node) return;
        const extra = node.extra = node.extra || {};
        if (enumerable) {
          extra[key2] = value;
        } else {
          Object.defineProperty(extra, key2, { enumerable, value });
        }
      }
      /**
       * Test if current token is a literal property name
       * https://tc39.es/ecma262/#prod-LiteralPropertyName
       * LiteralPropertyName:
       *   IdentifierName
       *   StringLiteral
       *   NumericLiteral
       *   BigIntLiteral
       */
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.type);
      }
      hasPrecedingLineBreak() {
        return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      }
      createIdentifier(node, name) {
        node.name = name;
        return this.finishNode(node, "Identifier");
      }
      /**
       * Reset the start location of node to the start location of locationNode
       */
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
      }
      // This is used in flow and typescript plugin
      // Determine whether a parameter is a this param
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
      isLookaheadContextual(name) {
        const next2 = this.nextTokenStart();
        return this.isUnparsedContextual(next2, name);
      }
      /**
       * ts type isContextual
       * @param {TokenType} type
       * @param {TokenType} token
       * @returns {boolean}
       * */
      ts_type_isContextual(type, token) {
        return type === token && !this.containsEsc;
      }
      /**
       * ts isContextual
       * @param {TokenType} token
       * @returns {boolean}
       * */
      ts_isContextual(token) {
        return this.type === token && !this.containsEsc;
      }
      ts_isContextualWithState(state, token) {
        return state.type === token && !state.containsEsc;
      }
      isContextualWithState(keyword, state) {
        return state.type === tt2.name && state.value === keyword && !state.containsEsc;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(tt2.plusMin)) {
          return this.ts_isContextual(tokTypes2.readonly);
        }
        if (this.ts_isContextual(tokTypes2.readonly)) {
          this.next();
        }
        if (!this.match(tt2.bracketL)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(tt2._in);
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(tt2.colon);
      }
      /**
       * Whether current token matches given type
       *
       * @param {TokenType} type
       * @returns {boolean}
       * @memberof Tokenizer
       */
      match(type) {
        return this.type === type;
      }
      matchJsx(type) {
        return this.type === acornTypeScript.tokTypes[type];
      }
      ts_eatWithState(type, nextCount, state) {
        const targetType = state.type;
        if (type === targetType) {
          for (let i = 0; i < nextCount; i++) {
            this.next();
          }
          return true;
        } else {
          return false;
        }
      }
      ts_eatContextualWithState(name, nextCount, state) {
        if (keywordsRegExp.test(name)) {
          if (this.ts_isContextualWithState(state, tokTypes2[name])) {
            for (let i = 0; i < nextCount; i++) {
              this.next();
            }
            return true;
          }
          return false;
        } else {
          if (!this.isContextualWithState(name, state)) return false;
          for (let i = 0; i < nextCount; i++) {
            this.next();
          }
          return true;
        }
      }
      canHaveLeadingDecorator() {
        return this.match(tt2._class);
      }
      eatContextual(name) {
        if (keywordsRegExp.test(name)) {
          if (this.ts_isContextual(tokTypes2[name])) {
            this.next();
            return true;
          }
          return false;
        } else {
          return super.eatContextual(name);
        }
      }
      tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual("require");
        this.expect(tt2.parenL);
        if (!this.match(tt2.string)) {
          this.unexpected();
        }
        node.expression = this.parseExprAtom();
        this.expect(tt2.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsParseEntityName(allowReservedWords = true) {
        let entity = this.parseIdent(allowReservedWords);
        while (this.eat(tt2.dot)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdent(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(tt2.string) ? this.parseLiteral(this.value) : this.parseIdent(
          /* liberal */
          true
        );
        if (this.eat(tt2.eq)) {
          node.initializer = this.parseMaybeAssign();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const) node.const = true;
        if (properties.declare) node.declare = true;
        this.expectContextual("enum");
        node.id = this.parseIdent();
        this.checkLValSimple(node.id);
        this.expect(tt2.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(tt2.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.enterScope(TS_SCOPE_OTHER);
        this.expect(tt2.braceL);
        node.body = [];
        while (this.type !== tt2.braceR) {
          let stmt2 = this.parseStatement(null, true);
          node.body.push(stmt2);
        }
        this.next();
        super.exitScope();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.ts_isContextual(tokTypes2.global)) {
          node.global = true;
          node.id = this.parseIdent();
        } else if (this.match(tt2.string)) {
          node.id = this.parseLiteral(this.value);
        } else {
          this.unexpected();
        }
        if (this.match(tt2.braceL)) {
          this.enterScope(TS_SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          super.exitScope();
        } else {
          super.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let starttype = this.type;
        let kind;
        if (this.isContextual("let")) {
          starttype = tt2._var;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          if (starttype === tt2._function) {
            nany.declare = true;
            return this.parseFunctionStatement(
              nany,
              /* async */
              false,
              /* declarationPosition */
              true
            );
          }
          if (starttype === tt2._class) {
            nany.declare = true;
            return this.parseClass(nany, true);
          }
          if (starttype === tokTypes2.enum) {
            return this.tsParseEnumDeclaration(nany, { declare: true });
          }
          if (starttype === tokTypes2.global) {
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          }
          if (starttype === tt2._const || starttype === tt2._var) {
            if (!this.match(tt2._const) || !this.isLookaheadContextual("enum")) {
              nany.declare = true;
              return this.parseVarStatement(nany, kind || this.value, true);
            }
            this.expect(tt2._const);
            return this.tsParseEnumDeclaration(nany, {
              const: true,
              declare: true
            });
          }
          if (starttype === tokTypes2.interface) {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: true
            });
            if (result) return result;
          }
          if (tokenIsIdentifier(starttype)) {
            return this.tsParseDeclaration(
              nany,
              this.value,
              /* next */
              true
            );
          }
        });
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(tt2.braceR);
          case "HeritageClauseElement":
            return this.match(tt2.braceL);
          case "TupleElementTypes":
            return this.match(tt2.bracketR);
          case "TypeParametersOrArguments":
            return this.tsMatchRightRelational();
        }
      }
      /**
       * If !expectSuccess, returns undefined instead of failing to parse.
       * If expectSuccess, parseElement should always return a defined value.
       */
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element2 = parseElement();
          if (element2 == null) {
            return void 0;
          }
          result.push(element2);
          if (this.eat(tt2.comma)) {
            trailingCommaPos = this.lastTokStart;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(tt2.comma);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(
          this.tsParseDelimitedListWorker(
            kind,
            parseElement,
            /* expectSuccess */
            true,
            refTrailingCommaPos
          )
        );
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(tt2.bracketL);
          } else {
            this.expect(tt2.relational);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(tt2.bracketR);
        } else {
          this.expect(tt2.relational);
        }
        return result;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdent();
        return typeName.name;
      }
      tsEatThenParseType(token) {
        return !this.match(token) ? void 0 : this.tsNextThenParseType();
      }
      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }
      tsDoThenParseType(cb) {
        return this.tsInType(() => {
          cb();
          return this.tsParseType();
        });
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.type) || this.match(tt2._this)) {
          this.next();
          return true;
        }
        if (this.match(tt2.braceL)) {
          try {
            this.parseObj(true);
            return true;
          } catch {
            return false;
          }
        }
        if (this.match(tt2.bracketL)) {
          this.next();
          try {
            this.parseBindingList(tt2.bracketR, true, true);
            return true;
          } catch {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(tt2.parenR) || this.match(tt2.ellipsis)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(tt2.colon) || this.match(tt2.comma) || this.match(tt2.question) || this.match(tt2.eq)) {
            return true;
          }
          if (this.match(tt2.parenR)) {
            this.next();
            if (this.match(tt2.arrow)) {
              return true;
            }
          }
        }
        return false;
      }
      tsIsStartOfFunctionType() {
        if (this.tsMatchLeftRelational()) {
          return true;
        }
        return this.match(tt2.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsParseBindingListForSignature() {
        return super.parseBindingList(tt2.parenR, true, true).map((pattern) => {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            this.raise(
              pattern.start,
              TypeScriptError.UnsupportedSignatureParameterKind({ type: pattern.type })
            );
          }
          return pattern;
        });
      }
      tsParseTypePredicateAsserts() {
        if (this.type !== tokTypes2.asserts) {
          return false;
        }
        const containsEsc = this.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.type) && !this.match(tt2._this)) {
          return false;
        }
        if (containsEsc) {
          this.raise(this.lastTokStart, "Escape sequence in keyword asserts");
        }
        return true;
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(tt2.colon);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(
          /* eatColon */
          false
        );
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseTypePredicatePrefix() {
        const id2 = this.parseIdent();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id2;
        }
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(tt2._this)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(
                /* eatColon */
                false,
                t
              );
            }
            node.parameterName = this.parseIdent();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(
            /* eatColon */
            false
          );
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
      // but here it's always false, because this is only used for types.
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === tt2.arrow;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(tt2.parenL);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsTryNextParseConstantContext() {
        if (this.lookahead().type !== tt2._const) return null;
        this.next();
        const typeReference = this.tsParseTypeReference();
        if (typeReference.typeParameters || typeReference.typeArguments) {
          this.raise(
            typeReference.typeName.start,
            TypeScriptError.CannotFindName({
              name: "const"
            })
          );
        }
        return typeReference;
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(tt2.arrow, node));
        return this.finishNode(node, type);
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(node.start, TypeScriptError.UnexpectedReadonly);
        }
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsParseConstraintForInferType() {
        if (this.eat(tt2._extends)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.inDisallowConditionalTypesContext || !this.match(tt2.question)) {
            return constraint;
          }
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual("infer");
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        node.literal = (() => {
          switch (this.type) {
            case tt2.num:
            // we don't need bigint type here
            // case tt.bigint:
            case tt2.string:
            case tt2._true:
            case tt2._false:
              return this.parseExprAtom();
            default:
              this.unexpected();
          }
        })();
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(tt2._import);
        this.expect(tt2.parenL);
        if (!this.match(tt2.string)) {
          this.raise(this.start, TypeScriptError.UnsupportedImportTypeArgument);
        }
        node.argument = this.parseExprAtom();
        this.expect(tt2.parenR);
        if (this.eat(tt2.dot)) {
          node.qualifier = this.tsParseEntityName();
        }
        if (this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(tt2._typeof);
        if (this.match(tt2._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName();
        }
        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(tt2._in);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(tt2.braceL);
        if (this.match(tt2.plusMin)) {
          node.readonly = this.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }
        this.expect(tt2.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
        this.expect(tt2.bracketR);
        if (this.match(tt2.plusMin)) {
          node.optional = this.value;
          this.next();
          this.expect(tt2.question);
        } else if (this.eat(tt2.question)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(tt2.braceR);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseTupleElementType() {
        const startLoc = this.startLoc;
        const startPos = this["start"];
        const rest2 = this.eat(tt2.ellipsis);
        let type = this.tsParseType();
        const optional = this.eat(tt2.question);
        const labeled2 = this.eat(tt2.colon);
        if (labeled2) {
          const labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;
          if (type.type === "TSTypeReference" && !type.typeArguments && type.typeName.type === "Identifier") {
            labeledNode.label = type.typeName;
          } else {
            this.raise(type.start, TypeScriptError.InvalidTupleMemberLabel);
            labeledNode.label = type;
          }
          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest2) {
          const restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList(
          "TupleElementTypes",
          this.tsParseTupleElementType.bind(this),
          /* bracket */
          true,
          /* skipFirstToken */
          false
        );
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const { type } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(elementNode.start, TypeScriptError.OptionalTypeBeforeRequired);
          }
          seenOptionalElement ||= type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
          if (type === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
          }
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = this.parseTemplate({ isTagged: false });
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName();
        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsMatchLeftRelational() {
        return this.match(tt2.relational) && this.value === "<";
      }
      tsMatchRightRelational() {
        return this.match(tt2.relational) && this.value === ">";
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(tt2.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(tt2.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseNonArrayType() {
        switch (this.type) {
          case tt2.string:
          case tt2.num:
          // we don't need bigint type here
          // case tt.bigint:
          case tt2._true:
          case tt2._false:
            return this.tsParseLiteralTypeNode();
          case tt2.plusMin:
            if (this.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== tt2.num) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case tt2._this:
            return this.tsParseThisTypeOrThisTypePredicate();
          case tt2._typeof:
            return this.tsParseTypeQuery();
          case tt2._import:
            return this.tsParseImportType();
          case tt2.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case tt2.bracketL:
            return this.tsParseTupleType();
          case tt2.parenL:
            return this.tsParseParenthesizedType();
          // parse template string here
          case tt2.backQuote:
          case tt2.dollarBraceL:
            return this.tsParseTemplateLiteralType();
          default: {
            const { type } = this;
            if (tokenIsIdentifier(type) || type === tt2._void || type === tt2._null) {
              const nodeType = type === tt2._void ? "TSVoidKeyword" : type === tt2._null ? "TSNullKeyword" : keywordTypeFromName(this.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(tt2.bracketL)) {
          if (this.match(tt2.bracketR)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(tt2.bracketR);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(tt2.bracketR);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.type) && !this.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual("infer") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          "TSIntersectionType",
          this.tsParseTypeOperatorOrHigher.bind(this),
          tt2.bitwiseAND
        );
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          "TSUnionType",
          this.tsParseIntersectionTypeOrHigher.bind(this),
          tt2.bitwiseOR
        );
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(tt2._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType(
            "TSConstructorType",
            /* abstract */
            true
          );
        }
        return this.tsParseUnionTypeOrHigher();
      }
      /** Be sure to be in a type context before calling this, using `tsInType`. */
      tsParseType() {
        assert(this.inType);
        const type = this.tsParseNonConditionalType();
        if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(tt2._extends)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(
          () => this.tsParseNonConditionalType()
        );
        this.expect(tt2.question);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(tt2.colon);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.type)) {
          this.next();
          return this.match(tt2.colon);
        }
        return false;
      }
      /**
       * Runs `cb` in a type context.
       * This should be called one token *before* the first type token,
       * so that the call to `next()` is run in type context.
       */
      tsInType(cb) {
        const oldInType = this.inType;
        this.inType = true;
        try {
          return cb();
        } finally {
          this.inType = oldInType;
        }
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(tt2.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return void 0;
        }
        this.expect(tt2.bracketL);
        const id2 = this.parseIdent();
        id2.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id2);
        this.expect(tt2.bracketR);
        node.parameters = [id2];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      // for better error recover
      tsParseNoneModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: [],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
        });
      }
      tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(tt2._extends);
        node.default = this.tsEatThenParseType(tt2.eq);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.tsMatchLeftRelational() || this.matchJsx("jsxTagStart")) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = { value: -1 };
        node.params = this.tsParseBracketedList(
          "TypeParametersOrArguments",
          this.tsParseTypeParameter.bind(this, parseModifiers),
          /* bracket */
          false,
          /* skipFirstToken */
          true,
          refTrailingCommaPos
        );
        if (node.params.length === 0) {
          this.raise(this.start, TypeScriptError.EmptyTypeParameters);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.tsMatchLeftRelational()) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsTryParse(f) {
        const state = this.getCurLookaheadState();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        } else {
          this.setLookaheadState(state);
          return void 0;
        }
      }
      tsTokenCanFollowModifier() {
        return (this.match(tt2.bracketL) || this.match(tt2.braceL) || this.match(tt2.star) || this.match(tt2.ellipsis) || this.match(tt2.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next(true);
        return this.tsTokenCanFollowModifier();
      }
      /** Parses a modifier matching one the given modifier names. */
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        const modifier = this.value;
        if (allowedModifiers.indexOf(modifier) !== -1 && !this.containsEsc) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiersByMap({
        modified,
        map
      }) {
        for (const key2 of Object.keys(map)) {
          modified[key2] = map[key2];
        }
      }
      /** Parses a list of modifiers, in any order.
       *  If you need a specific order, you must call this function multiple times:
       *    this.tsParseModifiers({ modified: node, allowedModifiers: ['public'] });
       *    this.tsParseModifiers({ modified: node, allowedModifiers: ["abstract", "readonly"] });
       */
      tsParseModifiers({
        modified,
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TypeScriptError.InvalidModifierOnTypeMember
      }) {
        const modifiedMap = {};
        const enforceOrder = (loc, modifier, before2, after) => {
          if (modifier === before2 && modified[after]) {
            this.raise(
              loc.column,
              TypeScriptError.InvalidModifiersOrder({ orderedModifiers: [before2, after] })
            );
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(
              loc.column,
              TypeScriptError.IncompatibleModifiers({ modifiers: [mod1, mod2] })
            );
          }
        };
        for (; ; ) {
          const startLoc = this.startLoc;
          const modifier = this.tsParseModifier(
            allowedModifiers.concat(disallowedModifiers ?? []),
            stopOnStartOfClassStaticBlock
          );
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(this.start, TypeScriptError.DuplicateAccessibilityModifier());
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              enforceOrder(startLoc, modifier, modifier, "accessor");
              modifiedMap.accessibility = modifier;
              modified["accessibility"] = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              enforceOrder(startLoc, modifier, "in", "out");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else if (tsIsClassAccessor(modifier)) {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              incompatible(startLoc, modifier, "accessor", "readonly");
              incompatible(startLoc, modifier, "accessor", "static");
              incompatible(startLoc, modifier, "accessor", "override");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else if (modifier === "const") {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          }
          if (disallowedModifiers?.includes(modifier)) {
            this.raise(this.start, errorTemplate);
          }
        }
        return modifiedMap;
      }
      tsParseInOutModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["in", "out"],
          disallowedModifiers: [
            "public",
            "private",
            "protected",
            "readonly",
            "declare",
            "abstract",
            "override"
          ],
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameter
        });
      }
      // Handle type assertions
      parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit) {
        if (!options?.jsx && this.tsMatchLeftRelational()) {
          return this.tsParseTypeAssertion();
        } else {
          return super.parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit);
        }
      }
      tsParseTypeAssertion() {
        if (disallowAmbiguousJSXLike) {
          this.raise(this.start, TypeScriptError.ReservedTypeAssertion);
        }
        const result = this.tryParse(() => {
          const node = this.startNode();
          const _const = this.tsTryNextParseConstantContext();
          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(tt2.relational);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        });
        if (result.error) {
          return this.tsParseTypeParameters(this.tsParseConstModifier);
        } else {
          return result.node;
        }
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(
          () => (
            // Temporarily remove a JSX parsing context, which makes us scan different tokens.
            this.tsInNoContext(() => {
              this.expect(tt2.relational);
              return this.tsParseDelimitedList(
                "TypeParametersOrArguments",
                this.tsParseType.bind(this)
              );
            })
          )
        );
        if (node.params.length === 0) {
          this.raise(this.start, TypeScriptError.EmptyTypeArguments);
        }
        this.exprAllowed = false;
        this.expect(tt2.relational);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsParseHeritageClause(token) {
        const originalStart = this.start;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          node.expression = this.tsParseEntityName();
          if (this.tsMatchLeftRelational()) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(originalStart, TypeScriptError.EmptyHeritageClauseType({ token }));
        }
        return delimitedList;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(tt2.comma) && !this.isLineTerminator()) {
          this.expect(tt2.semi);
        }
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse(
          (abort) => (
            // @ts-expect-error todo(flow->ts)
            f() || abort()
          )
        );
        if (result.aborted || !result.node) return void 0;
        if (result.error) this.setLookaheadState(result.failState);
        return result.node;
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(tt2.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(tt2.question)) node.optional = true;
        const nodeAny = node;
        if (this.match(tt2.parenL) || this.tsMatchLeftRelational()) {
          if (readonly) {
            this.raise(node.start, TypeScriptError.ReadonlyForMethodSignature);
          }
          const method2 = nodeAny;
          if (method2.kind && this.tsMatchLeftRelational()) {
            this.raise(this.start, TypeScriptError.AccesorCannotHaveTypeParameters);
          }
          this.tsFillSignature(tt2.colon, method2);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method2.kind === "get") {
            if (method2[paramsKey].length > 0) {
              this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
              if (this.isThisParam(method2[paramsKey][0])) {
                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
              }
            }
          } else if (method2.kind === "set") {
            if (method2[paramsKey].length !== 1) {
              this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
            } else {
              const firstParameter = method2[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveOptionalParameter);
              }
              if (firstParameter.type === "RestElement") {
                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveRestParameter);
              }
            }
            if (method2[returnTypeKey]) {
              this.raise(
                method2[returnTypeKey].start,
                TypeScriptError.SetAccesorCannotHaveReturnType
              );
            }
          } else {
            method2.kind = "method";
          }
          return this.finishNode(method2, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(tt2.parenL) || this.tsMatchLeftRelational()) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(tt2._new)) {
          const id2 = this.startNode();
          this.next();
          if (this.match(tt2.parenL) || this.tsMatchLeftRelational()) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id2, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["readonly"],
          disallowedModifiers: [
            "declare",
            "abstract",
            "private",
            "protected",
            "public",
            "static",
            "override"
          ]
        });
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        this.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          this.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseObjectTypeMembers() {
        this.expect(tt2.braceL);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(tt2.braceR);
        return members;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual("interface");
        if (properties.declare) node.declare = true;
        if (tokenIsIdentifier(this.type)) {
          node.id = this.parseIdent();
          this.checkLValSimple(node.id, acornScope.BIND_TS_INTERFACE);
        } else {
          node.id = null;
          this.raise(this.start, TypeScriptError.MissingInterfaceName);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (this.eat(tt2._extends)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseAbstractDeclaration(node) {
        if (this.match(tt2._class)) {
          node.abstract = true;
          return this.parseClass(node, true);
        } else if (this.ts_isContextual(tokTypes2.interface)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(node.start);
        }
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.type);
      }
      tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare": {
            const declaration2 = this.tsTryParseDeclare(node);
            if (declaration2) {
              declaration2.declare = true;
              return declaration2;
            }
            break;
          }
          case "global":
            if (this.match(tt2.braceL)) {
              this.enterScope(TS_SCOPE_TS_MODULE);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              super.exitScope();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(
              node,
              expr.name,
              /* next */
              false
            );
        }
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(
          /* allowReservedWords */
          false
        );
      }
      tsIsExportDefaultSpecifier() {
        const { type } = this;
        const isAsync = this.isAsyncFunction();
        const isLet = this.isLet();
        if (tokenIsIdentifier(type)) {
          if (isAsync && !this.containsEsc || isLet) {
            return false;
          }
          if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
            const ahead = this.lookahead();
            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt2.braceL) {
              return false;
            }
          }
        } else if (!this.match(tt2._default)) {
          return false;
        }
        const next2 = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next2, "from");
        if (this.input.charCodeAt(next2) === 44 || tokenIsIdentifier(this.type) && hasFrom) {
          return true;
        }
        if (this.match(tt2._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next2 + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.isAmbientContext;
        this.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.isAmbientContext = oldIsAmbientContext;
        }
      }
      tsCheckLineTerminator(next2) {
        if (next2) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdent();
        if (!nested) {
          this.checkLValSimple(node.id, acornScope.BIND_TS_NAMESPACE);
        }
        if (this.eat(tt2.dot)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.enterScope(TS_SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          super.exitScope();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      checkLValSimple(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
        if (expr.type === "TSNonNullExpression" || expr.type === "TSAsExpression") {
          expr = expr.expression;
        }
        return super.checkLValSimple(expr, bindingType, checkClashes);
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdent();
        this.checkLValSimple(node.id, acornScope.BIND_TS_TYPE);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(
            this.tsParseInOutModifiers.bind(this)
          );
          this.expect(tt2.eq);
          if (this.ts_isContextual(tokTypes2.interface) && this.lookahead().type !== tt2.dot) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.
      tsParseDeclaration(node, value, next2) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next2) && (this.match(tt2._class) || tokenIsIdentifier(this.type))) {
              return this.tsParseAbstractDeclaration(node);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next2)) {
              if (this.match(tt2.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next2) && tokenIsIdentifier(this.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next2) && tokenIsIdentifier(this.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      // Note: this won't be called unless the keyword is allowed in
      // `shouldParseExportDeclaration`.
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(
          this.startNode(),
          this.value,
          /* next */
          true
        );
      }
      tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdent();
        this.checkLValSimple(node.id, acornScope.BIND_LEXICAL);
        super.expect(tt2.eq);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(moduleReference.start, TypeScriptError.ImportAliasHasImportType);
        }
        node.moduleReference = moduleReference;
        super.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        const { type } = this;
        if (tokenIsIdentifier(type)) {
          if (this.isContextual("async") || this.isContextual("let")) {
            return false;
          }
          if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {
            const ahead = this.lookahead();
            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt2.braceL) {
              return false;
            }
          }
        } else if (!this.match(tt2._default)) {
          return false;
        }
        const next2 = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next2, "from");
        if (this.input.charCodeAt(next2) === 44 || tokenIsIdentifier(this.type) && hasFrom) {
          return true;
        }
        if (this.match(tt2._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next2 + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseTemplate({ isTagged = false } = {}) {
        let node = this.startNode();
        this.next();
        node.expressions = [];
        let curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === tt2.eof) this.raise(this.pos, "Unterminated template literal");
          this.expect(tt2.dollarBraceL);
          node.expressions.push(this.inType ? this.tsParseType() : this.parseExpression());
          this.expect(tt2.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      }
      parseFunction(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.ecmaVersion >= 9 || this.ecmaVersion >= 6 && !isAsync) {
          if (this.type === tt2.star && statement & FUNC_HANGING_STATEMENT2) {
            this.unexpected();
          }
          node.generator = this.eat(tt2.star);
        }
        if (this.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT2) {
          node.id = statement & FUNC_NULLABLE_ID2 && this.type !== tt2.name ? null : this.parseIdent();
        }
        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        this.maybeInArrowParameters = false;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT2)) {
          node.id = this.type === tt2.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        const isDeclaration = statement & FUNC_STATEMENT2;
        this.parseFunctionBody(node, allowExpressionBody, false, forInit, {
          isFunctionDeclaration: isDeclaration
        });
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        if (statement & FUNC_STATEMENT2 && node.id && !(statement & FUNC_HANGING_STATEMENT2)) {
          if (node.body) {
            this.checkLValSimple(
              node.id,
              this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? acornScope.BIND_VAR : acornScope.BIND_LEXICAL : acornScope.BIND_FUNCTION
            );
          } else {
            this.checkLValSimple(node.id, acornScope.BIND_NONE);
          }
        }
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      }
      parseFunctionBody(node, isArrowFunction = false, isMethod = false, forInit = false, tsConfig) {
        if (this.match(tt2.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt2.colon);
        }
        const bodilessType = tsConfig?.isFunctionDeclaration ? "TSDeclareFunction" : tsConfig?.isClassMethod ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(tt2.braceL) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.isAmbientContext) {
          this.raise(node.start, TypeScriptError.DeclareFunctionHasImplementation);
          if (node.declare) {
            super.parseFunctionBody(node, isArrowFunction, isMethod, false);
            return this.finishNode(node, bodilessType);
          }
        }
        super.parseFunctionBody(node, isArrowFunction, isMethod, forInit);
        return node;
      }
      parseNew() {
        if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        let node = this.startNode();
        let meta2 = this.parseIdent(true);
        if (this.ecmaVersion >= 6 && this.eat(tt2.dot)) {
          node.meta = meta2;
          let containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target")
            this.raiseRecoverable(
              node.property.start,
              "The only valid meta property for new is 'new.target'"
            );
          if (containsEsc)
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          if (!this["allowNewDotTarget"])
            this.raiseRecoverable(
              node.start,
              "'new.target' can only be used in functions and class static block"
            );
          return this.finishNode(node, "MetaProperty");
        }
        let startPos = this.start, startLoc = this.startLoc, isImport = this.type === tt2._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        const { callee } = node;
        if (callee.type === "TSInstantiationExpression" && !callee.extra?.parenthesized) {
          node.typeArguments = callee.typeArguments;
          node.callee = callee.expression;
        }
        if (this.eat(tt2.parenL))
          node.arguments = this.parseExprList(tt2.parenR, this.ecmaVersion >= 8, false);
        else node.arguments = [];
        return this.finishNode(node, "NewExpression");
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        if (tt2._in.binop > minPrec && !this.hasPrecedingLineBreak()) {
          let nodeType;
          if (this.isContextual("as")) {
            nodeType = "TSAsExpression";
          }
          if (this.isContextual("satisfies")) {
            nodeType = "TSSatisfiesExpression";
          }
          if (nodeType) {
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;
            const _const = this.tsTryNextParseConstantContext();
            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }
            this.finishNode(node, nodeType);
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit);
      }
      parseImportSpecifiers() {
        let nodes = [], first = true;
        if (acornTypeScript.tokenIsIdentifier(this.type)) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(tt2.comma)) return nodes;
        }
        if (this.type === tt2.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(tt2.braceL);
        while (!this.eat(tt2.braceR)) {
          if (!first) {
            this.expect(tt2.comma);
            if (this.afterTrailingComma(tt2.braceR)) break;
          } else first = false;
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      }
      /**
       * @param {Node} node this may be ImportDeclaration |
       * TsImportEqualsDeclaration
       * @returns AnyImport
       * */
      parseImport(node) {
        let enterHead = this.lookahead();
        node.importKind = "value";
        this.importOrExportOuterKind = "value";
        if (tokenIsIdentifier(enterHead.type) || this.match(tt2.star) || this.match(tt2.braceL)) {
          let ahead = this.lookahead(2);
          if (
            // import type, { a } from "b";
            ahead.type !== tt2.comma && // import type from "a";
            !this.isContextualWithState("from", ahead) && // import type = require("a");
            ahead.type !== tt2.eq && this.ts_eatContextualWithState("type", 1, enterHead)
          ) {
            this.importOrExportOuterKind = "type";
            node.importKind = "type";
            enterHead = this.lookahead();
            ahead = this.lookahead(2);
          }
          if (tokenIsIdentifier(enterHead.type) && ahead.type === tt2.eq) {
            this.next();
            const importNode = this.tsParseImportEqualsDeclaration(node);
            this.importOrExportOuterKind = "value";
            return importNode;
          }
        }
        this.next();
        if (this.type === tt2.string) {
          node.specifiers = [];
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === tt2.string ? this.parseExprAtom() : this.unexpected();
        }
        this.parseMaybeImportAttributes(node);
        this.semicolon();
        this.finishNode(node, "ImportDeclaration");
        this.importOrExportOuterKind = "value";
        if (node.importKind === "type" && node.specifiers.length > 1 && node.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(node.start, TypeScriptError.TypeImportCannotSpecifyDefaultAndNamed);
        }
        return node;
      }
      parseExportDefaultDeclaration() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true);
        }
        if (this.match(tokTypes2.interface)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultDeclaration();
      }
      parseExportAllDeclaration(node, exports) {
        if (this.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== tt2.string) this.unexpected();
        node.source = this.parseExprAtom();
        this.parseMaybeImportAttributes(node);
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      parseDynamicImport(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.eat(tt2.comma)) {
          const expr = this.parseExpression();
          node.arguments = [expr];
        }
        if (!this.eat(tt2.parenR)) {
          const errorPos = this.start;
          if (this.eat(tt2.comma) && this.eat(tt2.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      }
      parseExport(node, exports) {
        let enterHead = this.lookahead();
        if (this.ts_eatWithState(tt2._import, 2, enterHead)) {
          if (this.ts_isContextual(tokTypes2.type) && this.lookaheadCharCode() !== 61) {
            node.importKind = "type";
            this.importOrExportOuterKind = "type";
            this.next();
          } else {
            node.importKind = "value";
            this.importOrExportOuterKind = "value";
          }
          const exportEqualsNode = this.tsParseImportEqualsDeclaration(
            node,
            /* isExport */
            true
          );
          this.importOrExportOuterKind = void 0;
          return exportEqualsNode;
        } else if (this.ts_eatWithState(tt2.eq, 2, enterHead)) {
          const assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          this.importOrExportOuterKind = void 0;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.ts_eatContextualWithState("as", 2, enterHead)) {
          const decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdent();
          this.semicolon();
          this.importOrExportOuterKind = void 0;
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          const lookahead2 = this.lookahead(2).type;
          if (this.ts_isContextualWithState(enterHead, tokTypes2.type) && (lookahead2 === tt2.braceL || // export type { ... }
          lookahead2 === tt2.star)) {
            this.next();
            this.importOrExportOuterKind = "type";
            node.exportKind = "type";
          } else {
            this.importOrExportOuterKind = "value";
            node.exportKind = "value";
          }
          this.next();
          if (this.eat(tt2.star)) {
            return this.parseExportAllDeclaration(node, exports);
          }
          if (this.eat(tt2._default)) {
            this.checkExport(exports, "default", this.lastTokStart);
            node.declaration = this.parseExportDefaultDeclaration();
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseExportDeclaration(node);
            if (node.declaration.type === "VariableDeclaration")
              this.checkVariableExport(exports, node.declaration.declarations);
            else this.checkExport(exports, node.declaration.id, node.declaration.id.start);
            node.specifiers = [];
            node.source = null;
          } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports);
            if (this.eatContextual("from")) {
              if (this.type !== tt2.string) this.unexpected();
              node.source = this.parseExprAtom();
              this.parseMaybeImportAttributes(node);
            } else {
              for (let spec of node.specifiers) {
                this.checkUnreserved(spec.local);
                this.checkLocalExport(spec.local);
                if (spec.local.type === "Literal") {
                  this.raise(
                    spec.local.start,
                    "A string literal cannot be used as an exported binding without `from`."
                  );
                }
              }
              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration");
        }
      }
      checkExport(exports, name, _2) {
        if (!exports) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        exports[name] = true;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        const node = super.parseMaybeDefault(startPos, startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, TypeScriptError.TypeAnnotationAfterAssign);
        }
        return node;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(
          node.expression,
          node.typeAnnotation.end,
          node.typeAnnotation.loc?.end
        );
        return node.expression;
      }
      toAssignableList(exprList, isBinding) {
        if (!exprList) exprList = [];
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if (expr?.type === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        return super.toAssignableList(exprList, isBinding);
      }
      reportReservedArrowTypeParam(node) {
        if (node.params.length === 1 && !node.extra?.trailingComma && disallowAmbiguousJSXLike) {
          this.raise(node.start, TypeScriptError.ReservedArrowTypeParam);
        }
      }
      parseExprAtom(refDestructuringErrors, forInit, forNew) {
        if (this.type === tokTypes2.jsxText) {
          return this.jsx_parseText();
        } else if (this.type === tokTypes2.jsxTagStart) {
          return this.jsx_parseElement();
        } else if (this.type === tokTypes2.at) {
          this.parseDecorators();
          return this.parseExprAtom();
        } else if (tokenIsIdentifier(this.type)) {
          let canBeArrow = this.potentialArrowAt === this.start;
          let startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          let id2 = this.parseIdent(false);
          if (this.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(tt2._function)) {
            this.overrideContext(tokContexts.f_expr);
            return this.parseFunction(
              this.startNodeAt(startPos, startLoc),
              0,
              false,
              true,
              forInit
            );
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(tt2.arrow))
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                [id2],
                false,
                forInit
              );
            if (this.ecmaVersion >= 8 && id2.name === "async" && this.type === tt2.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id2 = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(tt2.arrow)) this.unexpected();
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                [id2],
                true,
                forInit
              );
            }
          }
          return id2;
        } else {
          return super.parseExprAtom(refDestructuringErrors, forInit, forNew);
        }
      }
      parseExprAtomDefault() {
        if (tokenIsIdentifier(this.type)) {
          const canBeArrow = this["potentialArrowAt"] === this.start;
          const containsEsc = this.containsEsc;
          const id2 = this.parseIdent();
          if (!containsEsc && id2.name === "async" && !this.canInsertSemicolon()) {
            const { type } = this;
            if (type === tt2._function) {
              this.next();
              return this.parseFunction(this.startNodeAtNode(id2), void 0, true, true);
            } else if (tokenIsIdentifier(type)) {
              if (this.lookaheadCharCode() === 61) {
                const paramId = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(tt2.arrow)) this.unexpected();
                return this.parseArrowExpression(this.startNodeAtNode(id2), [paramId], true);
              } else {
                return id2;
              }
            }
          }
          if (canBeArrow && this.match(tt2.arrow) && !this.canInsertSemicolon()) {
            this.next();
            return this.parseArrowExpression(this.startNodeAtNode(id2), [id2], false);
          }
          return id2;
        } else {
          this.unexpected();
        }
      }
      parseIdentNode() {
        let node = this.startNode();
        if (tokenIsKeywordOrIdentifier(this.type) && // Taken from super-class method
        !((this.type.keyword === "class" || this.type.keyword === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))) {
          node.name = this.value;
        } else {
          return super.parseIdentNode();
        }
        return node;
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const { isAmbientContext } = this;
        this.next();
        super.parseVar(node, false, kind, allowMissingInitializer || isAmbientContext);
        this.semicolon();
        const declaration2 = this.finishNode(node, "VariableDeclaration");
        if (!isAmbientContext) return declaration2;
        for (const { id: id2, init: init3 } of declaration2.declarations) {
          if (!init3) continue;
          if (kind !== "const" || !!id2.typeAnnotation) {
            this.raise(init3.start, TypeScriptError.InitializerNotAllowedInAmbientContext);
          } else if (init3.type !== "StringLiteral" && init3.type !== "BooleanLiteral" && init3.type !== "NumericLiteral" && init3.type !== "BigIntLiteral" && (init3.type !== "TemplateLiteral" || init3.expressions.length > 0) && !isPossiblyLiteralEnum(init3)) {
            this.raise(
              init3.start,
              TypeScriptError.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference
            );
          }
        }
        return declaration2;
      }
      parseStatement(context, topLevel, exports) {
        if (this.match(tokTypes2.at)) {
          this.parseDecorators(true);
        }
        if (this.match(tt2._const) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(tt2._const);
          return this.tsParseEnumDeclaration(node, { const: true });
        }
        if (this.ts_isContextual(tokTypes2.enum)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.ts_isContextual(tokTypes2.interface)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatement(context, topLevel, exports);
      }
      // NOTE: unused function
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(tt2.question);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(tt2.parenL)) {
          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasReadonly);
        }
        if (methodOrProp.declare && this.match(tt2.parenL)) {
          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasDeclare);
        }
      }
      // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`
      // is that e.g. `type()` is valid JS, so we must try parsing that first.
      // If it's really a type, we will parse `type` as the statement, and can correct it here
      // by parsing the rest.
      parseExpressionStatement(node, expr) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
        return decl || super.parseExpressionStatement(node, expr);
      }
      shouldParseExportStatement() {
        if (this.tsIsDeclarationStart()) return true;
        if (this.match(tokTypes2.at)) {
          return true;
        }
        return super.shouldParseExportStatement();
      }
      parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors) {
        if (this.eat(tt2.question)) {
          let node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(tt2.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeConditional(forInit, refDestructuringErrors) {
        let startPos = this.start, startLoc = this.startLoc;
        let expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        if (!this.maybeInArrowParameters || !this.match(tt2.question)) {
          return this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors);
        }
        const result = this.tryParse(
          () => this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors)
        );
        if (!result.node) {
          if (result.error) {
            this.setOptionalParametersError(refDestructuringErrors, result.error);
          }
          return expr;
        }
        if (result.error) this.setLookaheadState(result.failState);
        return result.node;
      }
      parseParenItem(node) {
        const startPos = this.start;
        const startLoc = this.startLoc;
        node = super.parseParenItem(node);
        if (this.eat(tt2.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(tt2.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.isAmbientContext && this.ts_isContextual(tokTypes2.declare)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startPos = this.start;
        const startLoc = this.startLoc;
        const isDeclare = this.eatContextual("declare");
        if (isDeclare && (this.ts_isContextual(tokTypes2.declare) || !this.shouldParseExportStatement())) {
          this.raise(this.start, TypeScriptError.ExpectedAmbientAfterExportDeclare);
        }
        const isIdentifier = tokenIsIdentifier(this.type);
        const declaration2 = isIdentifier && this.tsTryParseExportDeclaration() || this.parseStatement(null);
        if (!declaration2) return null;
        if (declaration2.type === "TSInterfaceDeclaration" || declaration2.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare) {
          this.resetStartLocation(declaration2, startPos, startLoc);
          declaration2.declare = true;
        }
        return declaration2;
      }
      parseClassId(node, isStatement) {
        if (!isStatement && this.isContextual("implements")) {
          return;
        }
        super.parseClassId(node, isStatement);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.value === "!" && this.eat(tt2.prefix)) {
            node.definite = true;
          } else if (this.eat(tt2.question)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
      parseClassField(field) {
        const isPrivate = field.key.type === "PrivateIdentifier";
        if (isPrivate) {
          if (field.abstract) {
            this.raise(field.start, TypeScriptError.PrivateElementHasAbstract);
          }
          if (field.accessibility) {
            this.raise(
              field.start,
              TypeScriptError.PrivateElementHasAccessibility({
                modifier: field.accessibility
              })
            );
          }
          this.parseClassPropertyAnnotation(field);
        } else {
          this.parseClassPropertyAnnotation(field);
          if (this.isAmbientContext && !(field.readonly && !field.typeAnnotation) && this.match(tt2.eq)) {
            this.raise(this.start, TypeScriptError.DeclareClassFieldHasInitializer);
          }
          if (field.abstract && this.match(tt2.eq)) {
            const { key: key2 } = field;
            this.raise(
              this.start,
              TypeScriptError.AbstractPropertyHasInitializer({
                propertyName: key2.type === "Identifier" && !field.computed ? key2.name : `[${this.input.slice(key2.start, key2.end)}]`
              })
            );
          }
        }
        return super.parseClassField(field);
      }
      parseClassMethod(method2, isGenerator, isAsync, allowsDirectSuper) {
        const isConstructor = method2.kind === "constructor";
        const isPrivate = method2.key.type === "PrivateIdentifier";
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (isPrivate) {
          if (typeParameters) method2.typeParameters = typeParameters;
          if (method2.accessibility) {
            this.raise(
              method2.start,
              TypeScriptError.PrivateMethodsHasAccessibility({
                modifier: method2.accessibility
              })
            );
          }
        } else {
          if (typeParameters && isConstructor) {
            this.raise(typeParameters.start, TypeScriptError.ConstructorHasTypeParameters);
          }
        }
        const { declare = false, kind } = method2;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(method2.start, TypeScriptError.DeclareAccessor({ kind }));
        }
        if (typeParameters) method2.typeParameters = typeParameters;
        const key2 = method2.key;
        if (method2.kind === "constructor") {
          if (isGenerator) this.raise(key2.start, "Constructor can't be a generator");
          if (isAsync) this.raise(key2.start, "Constructor can't be an async method");
        } else if (method2.static && checkKeyName2(method2, "prototype")) {
          this.raise(key2.start, "Classes may not have a static property named prototype");
        }
        const value = method2.value = this.parseMethod(
          isGenerator,
          isAsync,
          allowsDirectSuper,
          true,
          method2
        );
        if (method2.kind === "get" && value["params"].length !== 0)
          this.raiseRecoverable(value.start, "getter should have no params");
        if (method2.kind === "set" && value["params"].length !== 1)
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        if (method2.kind === "set" && value["params"][0].type === "RestElement")
          this.raiseRecoverable(value["params"][0].start, "Setter cannot use rest params");
        return this.finishNode(method2, "MethodDefinition");
      }
      isClassMethod() {
        return this.match(tt2.relational);
      }
      parseClassElement(constructorAllowsSuper) {
        if (this.eat(tt2.semi)) return null;
        let node = this.startNode();
        let keyName = "";
        let isGenerator = false;
        let isAsync = false;
        let kind = "method";
        let isStatic = false;
        const modifiers2 = [
          "declare",
          "private",
          "public",
          "protected",
          "accessor",
          "override",
          "abstract",
          "readonly",
          "static"
        ];
        const modifierMap = this.tsParseModifiers({
          modified: node,
          allowedModifiers: modifiers2,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
        });
        isStatic = Boolean(modifierMap.static);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(node, modifiers2)) {
              this.raise(this.start, TypeScriptError.StaticBlockCannotHaveModifier);
            }
            if (this.ecmaVersion >= 13) {
              super.parseClassStaticBlock(node);
              return node;
            }
          } else {
            const idx = this.tsTryParseIndexSignature(node);
            if (idx) {
              if (node.abstract) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasAbstract);
              }
              if (node.accessibility) {
                this.raise(
                  node.start,
                  TypeScriptError.IndexSignatureHasAccessibility({
                    modifier: node.accessibility
                  })
                );
              }
              if (node.declare) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasDeclare);
              }
              if (node.override) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasOverride);
              }
              return idx;
            }
            if (!this.inAbstractClass && node.abstract) {
              this.raise(node.start, TypeScriptError.NonAbstractClassHasAbstractMethod);
            }
            if (node.override) {
              if (!constructorAllowsSuper) {
                this.raise(node.start, TypeScriptError.OverrideNotInSubClass);
              }
            }
            node.static = isStatic;
            if (isStatic) {
              if (!(this.isClassElementNameStart() || this.type === tt2.star)) {
                keyName = "static";
              }
            }
            if (!keyName && this.ecmaVersion >= 8 && this.eatContextual("async")) {
              if ((this.isClassElementNameStart() || this.type === tt2.star) && !this.canInsertSemicolon()) {
                isAsync = true;
              } else {
                keyName = "async";
              }
            }
            if (!keyName && (this.ecmaVersion >= 9 || !isAsync) && this.eat(tt2.star)) {
              isGenerator = true;
            }
            if (!keyName && !isAsync && !isGenerator) {
              const lastValue = this.value;
              if (this.eatContextual("get") || this.eatContextual("set")) {
                if (this.isClassElementNameStart()) {
                  kind = lastValue;
                } else {
                  keyName = lastValue;
                }
              }
            }
            if (keyName) {
              node.computed = false;
              node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
              node.key.name = keyName;
              this.finishNode(node.key, "Identifier");
            } else {
              this.parseClassElementName(node);
            }
            this.parsePostMemberNameModifiers(node);
            if (this.isClassMethod() || this.ecmaVersion < 13 || this.type === tt2.parenL || kind !== "method" || isGenerator || isAsync) {
              const isConstructor = !node.static && checkKeyName2(node, "constructor");
              const allowsDirectSuper = isConstructor && constructorAllowsSuper;
              if (isConstructor && kind !== "method")
                this.raise(node.key.start, "Constructor can't have get/set modifier");
              node.kind = isConstructor ? "constructor" : kind;
              this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
            } else {
              this.parseClassField(node);
            }
            return node;
          }
        };
        if (node.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
        return node;
      }
      isClassElementNameStart() {
        if (this.tsIsIdentifier()) {
          return true;
        }
        return super.isClassElementNameStart();
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.tsMatchLeftRelational() || this.match(tt2.bitShift))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual("implements")) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseFunctionParams(node) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node);
      }
      // `let x: number;`
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.value === "!" && this.eat(tt2.prefix)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      // parse the return type of an async arrow function - let foo = (async (): number => {});
      parseArrowExpression(node, params, isAsync, forInit) {
        if (this.match(tt2.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags2(isAsync, false) | acornScope.SCOPE_ARROW);
        this.initFunction(node);
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        if (this.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.maybeInArrowParameters = true;
        node.params = this.toAssignableList(params, true);
        this.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      parseMaybeAssignOrigin(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) return this.parseYield(forInit);
          else this.exprAllowed = false;
        }
        let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors3();
          ownDestructuringErrors = true;
        }
        let startPos = this.start, startLoc = this.startLoc;
        if (this.type === tt2.parenL || tokenIsIdentifier(this.type)) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        let left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
        if (this.type.isAssign) {
          let node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === tt2.eq) left = this.toAssignable(left, true, refDestructuringErrors);
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start)
            refDestructuringErrors.shorthandAssign = -1;
          if (!this.maybeInArrowParameters) {
            if (this.type === tt2.eq) this.checkLValPattern(left);
            else this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
        return left;
      }
      parseMaybeAssign(forInit, refExpressionErrors, afterLeftParse) {
        let state;
        let jsx;
        let typeCast;
        if (options?.jsx && (this.matchJsx("jsxTagStart") || this.tsMatchLeftRelational())) {
          state = this.cloneCurLookaheadState();
          jsx = this.tryParse(
            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),
            state
          );
          if (!jsx.error) return jsx.node;
          const context = this.context;
          const currentContext = context[context.length - 1];
          const lastCurrentContext = context[context.length - 2];
          if (currentContext === acornTypeScript.tokContexts.tc_oTag && lastCurrentContext === acornTypeScript.tokContexts.tc_expr) {
            context.pop();
            context.pop();
          } else if (currentContext === acornTypeScript.tokContexts.tc_oTag || currentContext === acornTypeScript.tokContexts.tc_expr) {
            context.pop();
          }
        }
        if (!jsx?.error && !this.tsMatchLeftRelational()) {
          return this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
        }
        if (!state || this.compareLookaheadState(state, this.getCurLookaheadState())) {
          state = this.cloneCurLookaheadState();
        }
        let typeParameters;
        const arrow2 = this.tryParse((abort) => {
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || expr.extra?.parenthesized) {
            abort();
          }
          if (typeParameters?.params.length !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow2.error && !arrow2.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow2.node;
        }
        if (!jsx) {
          assert(true);
          typeCast = this.tryParse(
            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),
            state
          );
          if (!typeCast.error) return typeCast.node;
        }
        if (jsx?.node) {
          this.setLookaheadState(jsx.failState);
          return jsx.node;
        }
        if (arrow2.node) {
          this.setLookaheadState(arrow2.failState);
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow2.node;
        }
        if (typeCast?.node) {
          this.setLookaheadState(typeCast.failState);
          return typeCast.node;
        }
        if (jsx?.thrown) throw jsx.error;
        if (arrow2.thrown) throw arrow2.error;
        if (typeCast?.thrown) throw typeCast.error;
        throw jsx?.error || arrow2.error || typeCast?.error;
      }
      parseAssignableListItem(allowModifiers) {
        const decorators = [];
        while (this.match(tokTypes2.at)) {
          decorators.push(this.parseDecorator());
        }
        const startPos = this.start;
        const startLoc = this.startLoc;
        let accessibility;
        let readonly = false;
        let override = false;
        if (allowModifiers !== void 0) {
          const modified = {};
          this.tsParseModifiers({
            modified,
            allowedModifiers: ["public", "private", "protected", "override", "readonly"]
          });
          accessibility = modified.accessibility;
          override = modified.override;
          readonly = modified.readonly;
          if (allowModifiers === false && (accessibility || readonly || override)) {
            this.raise(startLoc.column, TypeScriptError.UnexpectedParameterModifier);
          }
        }
        const left = this.parseMaybeDefault(startPos, startLoc);
        this.parseBindingListItem(left);
        const elt = this.parseMaybeDefault(left["start"], left["loc"], left);
        if (decorators.length) {
          elt.decorators = decorators;
        }
        if (accessibility || readonly || override) {
          const pp2 = this.startNodeAt(startPos, startLoc);
          if (accessibility) pp2.accessibility = accessibility;
          if (readonly) pp2.readonly = readonly;
          if (override) pp2.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp2.start, TypeScriptError.UnsupportedParameterPropertyKind);
          }
          pp2.parameter = elt;
          return this.finishNode(pp2, "TSParameterProperty");
        }
        return elt;
      }
      // AssignmentPattern
      checkLValInnerPattern(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
        switch (expr.type) {
          case "TSParameterProperty":
            this.checkLValInnerPattern(expr.parameter, bindingType, checkClashes);
            break;
          default: {
            super.checkLValInnerPattern(expr, bindingType, checkClashes);
            break;
          }
        }
      }
      // Allow type annotations inside of a parameter list.
      parseBindingListItem(param) {
        if (this.eat(tt2.question)) {
          if (param.type !== "Identifier" && !this.isAmbientContext && !this.inType) {
            this.raise(param.start, TypeScriptError.PatternIsOptional);
          }
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop2, i) => {
              return prop2.type !== "ObjectMethod" && (i === last || prop2.type !== "SpreadElement") && this.isAssignable(prop2);
            });
          }
          case "Property":
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every(
              (element2) => element2 === null || this.isAssignable(element2)
            );
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toAssignable(node, isBinding = false, refDestructuringErrors = new DestructuringErrors3()) {
        switch (node.type) {
          case "ParenthesizedExpression":
            return this.toAssignableParenthesizedExpression(
              node,
              isBinding,
              refDestructuringErrors
            );
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isBinding) {
            } else {
              this.raise(node.start, TypeScriptError.UnexpectedTypeCastInParameter);
            }
            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          case "MemberExpression":
            break;
          case "AssignmentExpression":
            if (!isBinding && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
            return super.toAssignable(node, isBinding, refDestructuringErrors);
          case "TSTypeCastExpression": {
            return this.typeCastToParameter(node);
          }
          default:
            return super.toAssignable(node, isBinding, refDestructuringErrors);
        }
        return node;
      }
      toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          default:
            return super.toAssignable(node, isBinding, refDestructuringErrors);
        }
      }
      parseBindingAtom() {
        switch (this.type) {
          case tt2._this:
            return this.parseIdent(
              /* liberal */
              true
            );
          default:
            return super.parseBindingAtom();
        }
      }
      shouldParseArrow(exprList) {
        let shouldParseArrowRes;
        if (this.match(tt2.colon)) {
          shouldParseArrowRes = exprList.every((expr) => this.isAssignable(expr, true));
        } else {
          shouldParseArrowRes = !this.canInsertSemicolon();
        }
        if (shouldParseArrowRes) {
          if (this.match(tt2.colon)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt2.colon);
              if (this.canInsertSemicolon() || !this.match(tt2.arrow)) abort();
              return returnType;
            });
            if (result.aborted) {
              this.shouldParseArrowReturnType = void 0;
              return false;
            }
            if (!result.thrown) {
              if (result.error) this.setLookaheadState(result.failState);
              this.shouldParseArrowReturnType = result.node;
            }
          }
          if (!this.match(tt2.arrow)) {
            this.shouldParseArrowReturnType = void 0;
            return false;
          }
          return true;
        }
        this.shouldParseArrowReturnType = void 0;
        return shouldParseArrowRes;
      }
      parseParenArrowList(startPos, startLoc, exprList, forInit) {
        const node = this.startNodeAt(startPos, startLoc);
        node.returnType = this.shouldParseArrowReturnType;
        this.shouldParseArrowReturnType = void 0;
        return this.parseArrowExpression(node, exprList, false, forInit);
      }
      parseParenAndDistinguishExpression(canBeArrow, forInit) {
        let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.ecmaVersion >= 8;
        if (this.ecmaVersion >= 6) {
          const oldMaybeInArrowParameters = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          this.next();
          let innerStartPos = this.start, innerStartLoc = this.startLoc;
          let exprList = [], first = true, lastIsComma = false;
          let refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== tt2.parenR) {
            first ? first = false : this.expect(tt2.comma);
            if (allowTrailingComma && this.afterTrailingComma(tt2.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === tt2.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === tt2.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(
                this.parseMaybeAssign(forInit, refDestructuringErrors, this.parseParenItem)
              );
            }
          }
          let innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(tt2.parenR);
          this.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(tt2.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
          if (spreadStart) this.unexpected(spreadStart);
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          let par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      }
      parseTaggedTemplateExpression(base, startPos, startLoc, optionalChainMember) {
        const node = this.startNodeAt(startPos, startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate({ isTagged: true });
        if (optionalChainMember) {
          this.raise(
            startPos,
            "Tagged Template Literals are not allowed in optionalChain."
          );
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      shouldParseAsyncArrow() {
        if (this.match(tt2.colon)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt2.colon);
            if (this.canInsertSemicolon() || !this.match(tt2.arrow)) abort();
            return returnType;
          });
          if (result.aborted) {
            this.shouldParseAsyncArrowReturnType = void 0;
            return false;
          }
          if (!result.thrown) {
            if (result.error) this.setLookaheadState(result.failState);
            this.shouldParseAsyncArrowReturnType = result.node;
            return !this.canInsertSemicolon() && this.eat(tt2.arrow);
          }
        } else {
          return !this.canInsertSemicolon() && this.eat(tt2.arrow);
        }
      }
      parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit) {
        const arrN = this.startNodeAt(startPos, startLoc);
        arrN.returnType = this.shouldParseAsyncArrowReturnType;
        this.shouldParseAsyncArrowReturnType = void 0;
        return this.parseArrowExpression(arrN, exprList, true, forInit);
      }
      parseExprList(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        let elts = [], first = true;
        while (!this.eat(close2)) {
          if (!first) {
            this.expect(tt2.comma);
            if (allowTrailingComma && this.afterTrailingComma(close2)) break;
          } else first = false;
          let elt;
          if (allowEmpty && this.type === tt2.comma) elt = null;
          else if (this.type === tt2.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (this.maybeInArrowParameters && this.match(tt2.colon)) {
              elt.typeAnnotation = this.tsParseTypeAnnotation();
            }
            if (refDestructuringErrors && this.type === tt2.comma && refDestructuringErrors.trailingComma < 0)
              refDestructuringErrors.trailingComma = this.start;
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem);
          }
          elts.push(elt);
        }
        return elts;
      }
      parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        let _optionalChained = optionalChained;
        if (!this.hasPrecedingLineBreak() && // NODE: replace bang
        this.value === "!" && this.match(tt2.prefix)) {
          this.exprAllowed = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          base = this.finishNode(nonNullExpression, "TSNonNullExpression");
          return base;
        }
        let isOptionalCall = false;
        if (this.match(tt2.questionDot) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            return base;
          }
          base.optional = true;
          _optionalChained = isOptionalCall = true;
          this.next();
        }
        if (this.tsMatchLeftRelational() || this.match(tt2.bitShift)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(
                startPos,
                startLoc,
                forInit
              );
              if (asyncArrowFn) {
                base = asyncArrowFn;
                return base;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return base;
            if (isOptionalCall && !this.match(tt2.parenL)) {
              missingParenErrorLoc = this.curPosition();
              return base;
            }
            if (tokenIsTemplate(this.type) || this.type === tt2.backQuote) {
              const result2 = this.parseTaggedTemplateExpression(
                base,
                startPos,
                startLoc,
                _optionalChained
              );
              result2.typeArguments = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(tt2.parenL)) {
              let refDestructuringErrors = new DestructuringErrors3();
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.callee = base;
              node2.arguments = this.parseExprList(
                tt2.parenR,
                this.ecmaVersion >= 8,
                false,
                refDestructuringErrors
              );
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              node2.typeArguments = typeArguments;
              if (_optionalChained) {
                node2.optional = isOptionalCall;
              }
              this.checkExpressionErrors(refDestructuringErrors, true);
              base = this.finishNode(node2, "CallExpression");
              return base;
            }
            const tokenType = this.type;
            if (
              // a<b>>c is not (a<b>)>c, but a<(b>>c)
              this.tsMatchRightRelational() || // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)
              tokenType === tt2.bitShift || // a<b>c is (a<b)>c
              tokenType !== tt2.parenL && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()
            ) {
              return;
            }
            const node = this.startNodeAt(startPos, startLoc);
            node.expression = base;
            node.typeArguments = typeArguments;
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(tt2.dot) || this.match(tt2.questionDot) && this.lookaheadCharCode() !== 40)) {
              this.raise(
                this.start,
                TypeScriptError.InvalidPropertyAccessAfterInstantiationExpression
              );
            }
            base = result;
            return base;
          }
        }
        let optionalSupported = this.ecmaVersion >= 11;
        let optional = optionalSupported && this.eat(tt2.questionDot);
        if (noCalls && optional)
          this.raise(
            this.lastTokStart,
            "Optional chaining cannot appear in the callee of new expressions"
          );
        let computed = this.eat(tt2.bracketL);
        if (computed || optional && this.type !== tt2.parenL && this.type !== tt2.backQuote || this.eat(tt2.dot)) {
          let node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(tt2.bracketR);
          } else if (this.type === tt2.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(tt2.parenL)) {
          const oldMaybeInArrowParameters = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          let refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          let exprList = this.parseExprList(
            tt2.parenR,
            this.ecmaVersion >= 8,
            false,
            refDestructuringErrors
          );
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0)
              this.raise(
                this.awaitIdentPos,
                "Cannot use 'await' as identifier inside an async function"
              );
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            base = this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            let node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = exprList;
            if (optionalSupported) {
              node.optional = optional;
            }
            base = this.finishNode(node, "CallExpression");
          }
          this.maybeInArrowParameters = oldMaybeInArrowParameters;
        } else if (this.type === tt2.backQuote) {
          if (optional || _optionalChained) {
            this.raise(
              this.start,
              "Optional chaining cannot appear in the tag of tagged template expressions"
            );
          }
          let node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node, "TaggedTemplateExpression");
        }
        return base;
      }
      parseGetterSetter(prop2) {
        prop2.kind = prop2.key.name;
        this.parsePropertyName(prop2);
        prop2.value = this.parseMethod(false);
        let paramCount = prop2.kind === "get" ? 0 : 1;
        const firstParam = prop2.value.params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        paramCount = hasContextParam ? paramCount + 1 : paramCount;
        if (prop2.value.params.length !== paramCount) {
          let start = prop2.value.start;
          if (prop2.kind === "get") this.raiseRecoverable(start, "getter should have no params");
          else this.raiseRecoverable(start, "setter should have exactly one param");
        } else {
          if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement")
            this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
        }
      }
      parseProperty(isPattern, refDestructuringErrors) {
        if (!isPattern) {
          let decorators = [];
          if (this.match(tokTypes2.at)) {
            while (this.match(tokTypes2.at)) {
              decorators.push(this.parseDecorator());
            }
          }
          const property = super.parseProperty(isPattern, refDestructuringErrors);
          if (property.type === "SpreadElement") {
            if (decorators.length)
              this.raise(property.start, DecoratorsError.SpreadElementDecorator);
          }
          if (decorators.length) {
            property.decorators = decorators;
            decorators = [];
          }
          return property;
        }
        return super.parseProperty(isPattern, refDestructuringErrors);
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        let simple = param.type === "Identifier";
        this.enterScope(simple ? acornScope.SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(
          param,
          simple ? acornScope.BIND_SIMPLE_CATCH : acornScope.BIND_LEXICAL
        );
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        this.expect(tt2.parenR);
        return param;
      }
      parseClass(node, isStatement) {
        const oldInAbstractClass = this.inAbstractClass;
        this.inAbstractClass = !!node.abstract;
        try {
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.strict;
          this.strict = true;
          this.parseClassId(node, isStatement);
          this.parseClassSuper(node);
          const privateNameMap = this.enterClassBody();
          const classBody = this.startNode();
          let hadConstructor = false;
          classBody.body = [];
          let decorators = [];
          this.expect(tt2.braceL);
          while (this.type !== tt2.braceR) {
            if (this.match(tokTypes2.at)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const element2 = this.parseClassElement(node.superClass !== null);
            if (decorators.length) {
              element2.decorators = decorators;
              this.resetStartLocationFromNode(element2, decorators[0]);
              decorators = [];
            }
            if (element2) {
              classBody.body.push(element2);
              if (element2.type === "MethodDefinition" && element2.kind === "constructor" && element2.value.type === "FunctionExpression") {
                if (hadConstructor) {
                  this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
                }
                hadConstructor = true;
                if (element2.decorators && element2.decorators.length > 0) {
                  this.raise(element2.start, DecoratorsError.DecoratorConstructor);
                }
              } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element2)) {
                this.raiseRecoverable(
                  element2.key.start,
                  `Identifier '#${element2.key.name}' has already been declared`
                );
              }
            }
          }
          this.strict = oldStrict;
          this.next();
          if (decorators.length) {
            this.raise(this.start, DecoratorsError.TrailingDecorator);
          }
          node.body = this.finishNode(classBody, "ClassBody");
          this.exitClassBody();
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        } finally {
          this.inAbstractClass = oldInAbstractClass;
        }
      }
      parseClassFunctionParams() {
        const typeParameters = this.tsTryParseTypeParameters();
        let params = this.parseBindingList(tt2.parenR, false, this.ecmaVersion >= 8, true);
        if (typeParameters) params.typeParameters = typeParameters;
        return params;
      }
      parseMethod(isGenerator, isAsync, allowDirectSuper, inClassScope, method2) {
        let node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.ecmaVersion >= 6) node.generator = isGenerator;
        if (this.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(
          functionFlags2(isAsync, node.generator) | acornScope.SCOPE_SUPER | (allowDirectSuper ? acornScope.SCOPE_DIRECT_SUPER : 0)
        );
        this.expect(tt2.parenL);
        node.params = this.parseClassFunctionParams();
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false, {
          isClassMethod: inClassScope
        });
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        if (method2 && method2.abstract) {
          const hasBody = !!node.body;
          if (hasBody) {
            const { key: key2 } = method2;
            this.raise(
              method2.start,
              TypeScriptError.AbstractMethodHasImplementation({
                methodName: key2.type === "Identifier" && !method2.computed ? key2.name : `[${this.input.slice(key2.start, key2.end)}]`
              })
            );
          }
        }
        return this.finishNode(node, "FunctionExpression");
      }
      static parse(input, options2) {
        if (options2.locations === false) {
          throw new Error(`You have to enable options.locations while using acorn-typescript`);
        } else {
          options2.locations = true;
        }
        const parser = new this(options2, input);
        if (dts) {
          parser.isAmbientContext = true;
        }
        return parser.parse();
      }
      static parseExpressionAt(input, pos, options2) {
        if (options2.locations === false) {
          throw new Error(`You have to enable options.locations while using acorn-typescript`);
        } else {
          options2.locations = true;
        }
        const parser = new this(options2, input, pos);
        if (dts) {
          parser.isAmbientContext = true;
        }
        parser.nextToken();
        return parser.parseExpression();
      }
      parseImportSpecifier() {
        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
        if (isMaybeTypeOnly) {
          let node = this.startNode();
          node.imported = this.parseModuleExportName();
          this.parseTypeOnlyImportExportSpecifier(
            node,
            /* isImport */
            true,
            this.importOrExportOuterKind === "type"
          );
          return this.finishNode(node, "ImportSpecifier");
        } else {
          const node = super.parseImportSpecifier();
          node.importKind = "value";
          return node;
        }
      }
      parseExportSpecifier(exports) {
        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
        const isString = this.match(tt2.string);
        if (!isString && isMaybeTypeOnly) {
          let node = this.startNode();
          node.local = this.parseModuleExportName();
          this.parseTypeOnlyImportExportSpecifier(
            node,
            /* isImport */
            false,
            this.importOrExportOuterKind === "type"
          );
          this.finishNode(node, "ExportSpecifier");
          this.checkExport(exports, node.exported, node.exported.start);
          return node;
        } else {
          const node = super.parseExportSpecifier(exports);
          node.exportKind = "value";
          return node;
        }
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.start;
        if (this.isContextual("as")) {
          const firstAs = this.parseIdent();
          if (this.isContextual("as")) {
            const secondAs = this.parseIdent();
            if (tokenIsKeywordOrIdentifier(this.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = super.parseIdent(true);
            if (!this.isContextual("as")) {
              this.checkUnreserved(leftOfAs);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(
            loc,
            isImport ? TypeScriptError.TypeModifierIsUsedInTypeImports : TypeScriptError.TypeModifierIsUsedInTypeExports
          );
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual("as")) {
          node[rightOfAsKey] = isImport ? this.parseIdent() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = this.copyNode(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkLValSimple(node[rightOfAsKey], acornScope.BIND_LEXICAL);
        }
      }
      raiseCommonCheck(pos, message, recoverable) {
        switch (message) {
          case "Comma is not permitted after the rest element": {
            if (this.isAmbientContext && this.match(tt2.comma) && this.lookaheadCharCode() === 41) {
              this.next();
              return;
            } else {
              return super.raise(pos, message);
            }
          }
        }
        return recoverable ? super.raiseRecoverable(pos, message) : super.raise(pos, message);
      }
      raiseRecoverable(pos, message) {
        return this.raiseCommonCheck(pos, message, true);
      }
      raise(pos, message) {
        return this.raiseCommonCheck(pos, message, true);
      }
      updateContext(prevType) {
        const { type } = this;
        if (type == tt2.braceL) {
          var curContext = this.curContext();
          if (curContext == tsTokContexts.tc_oTag) this.context.push(tokContexts.b_expr);
          else if (curContext == tsTokContexts.tc_expr) this.context.push(tokContexts.b_tmpl);
          else super.updateContext(prevType);
          this.exprAllowed = true;
        } else if (type === tt2.slash && prevType === tokTypes2.jsxTagStart) {
          this.context.length -= 2;
          this.context.push(tsTokContexts.tc_cTag);
          this.exprAllowed = false;
        } else {
          return super.updateContext(prevType);
        }
      }
      // Parses JSX opening tag starting after '<'.
      jsx_parseOpeningElementAt(startPos, startLoc) {
        let node = this.startNodeAt(startPos, startLoc);
        let nodeName = this.jsx_parseElementName();
        if (nodeName) node.name = nodeName;
        if (this.match(tt2.relational) || this.match(tt2.bitShift)) {
          const typeArguments = this.tsTryParseAndCatch(
            () => this.tsParseTypeArgumentsInExpression()
          );
          if (typeArguments) node.typeArguments = typeArguments;
        }
        node.attributes = [];
        while (this.type !== tt2.slash && this.type !== tokTypes2.jsxTagEnd)
          node.attributes.push(this.jsx_parseAttribute());
        node.selfClosing = this.eat(tt2.slash);
        this.expect(tokTypes2.jsxTagEnd);
        return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      enterScope(flags) {
        if (flags === TS_SCOPE_TS_MODULE) {
          this.importsStack.push([]);
        }
        super.enterScope(flags);
        const scope = super.currentScope();
        scope.types = [];
        scope.enums = [];
        scope.constEnums = [];
        scope.classes = [];
        scope.exportOnlyBindings = [];
      }
      exitScope() {
        const scope = super.currentScope();
        if (scope.flags === TS_SCOPE_TS_MODULE) {
          this.importsStack.pop();
        }
        super.exitScope();
      }
      hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].indexOf(name) > -1) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].indexOf(name) > -1) return true;
          }
        }
        return false;
      }
      maybeExportDefined(scope, name) {
        if (this.inModule && scope.flags & acornScope.SCOPE_TOP) {
          this.undefinedExports.delete(name);
        }
      }
      declareName(name, bindingType, pos) {
        if (bindingType & acornScope.BIND_FLAGS_TS_IMPORT) {
          if (this.hasImport(name, true)) {
            this.raise(pos, `Identifier '${name}' has already been declared.`);
          }
          this.importsStack[this.importsStack.length - 1].push(name);
          return;
        }
        const scope = this.currentScope();
        if (bindingType & acornScope.BIND_FLAGS_TS_EXPORT_ONLY) {
          this.maybeExportDefined(scope, name);
          scope.exportOnlyBindings.push(name);
          return;
        }
        if (bindingType === acornScope.BIND_TS_TYPE || bindingType === acornScope.BIND_TS_INTERFACE) {
          if (bindingType === acornScope.BIND_TS_TYPE && scope.types.includes(name)) {
            this.raise(pos, `type '${name}' has already been declared.`);
          }
          scope.types.push(name);
        } else {
          super.declareName(name, bindingType, pos);
        }
        if (bindingType & acornScope.BIND_FLAGS_TS_ENUM) scope.enums.push(name);
        if (bindingType & acornScope.BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
        if (bindingType & acornScope.BIND_FLAGS_CLASS) scope.classes.push(name);
      }
      checkLocalExport(id2) {
        const { name } = id2;
        if (this.hasImport(name)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          if (scope.types.indexOf(name) > -1 || scope.exportOnlyBindings.indexOf(name) > -1) return;
        }
        super.checkLocalExport(id2);
      }
    }
    return TypeScriptParser;
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/acorn.js
var ParserWithTS = Parser.extend(tsPlugin());
function parse4(source2, comments, typescript, is_script) {
  const parser = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(
    source2,
    /** @type {CommentWithLocation[]} */
    comments
  );
  const parse_statement = parser.prototype.parseStatement;
  if (is_script) {
    parser.prototype.parseStatement = function(...args) {
      const v = parse_statement.call(this, ...args);
      this.undefinedExports = {};
      return v;
    };
  }
  let ast;
  try {
    ast = parser.parse(source2, {
      onComment,
      sourceType: "module",
      ecmaVersion: 16,
      locations: true
    });
  } finally {
    if (is_script) {
      parser.prototype.parseStatement = parse_statement;
    }
  }
  add_comments(ast);
  return (
    /** @type {Program} */
    ast
  );
}
function parse_expression_at(source2, comments, typescript, index) {
  const parser = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(
    source2,
    /** @type {CommentWithLocation[]} */
    comments,
    index
  );
  const ast = parser.parseExpressionAt(source2, index, {
    onComment,
    sourceType: "module",
    ecmaVersion: 16,
    locations: true
  });
  add_comments(ast);
  return ast;
}
function get_comment_handlers(source2, comments, index = 0) {
  return {
    /**
     * @param {boolean} block
     * @param {string} value
     * @param {number} start
     * @param {number} end
     * @param {import('acorn').Position} [start_loc]
     * @param {import('acorn').Position} [end_loc]
     */
    onComment: (block2, value, start, end, start_loc, end_loc) => {
      if (block2 && /\n/.test(value)) {
        let a = start;
        while (a > 0 && source2[a - 1] !== "\n") a -= 1;
        let b = a;
        while (/[ \t]/.test(source2[b])) b += 1;
        const indentation = source2.slice(a, b);
        value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
      }
      comments.push({
        type: block2 ? "Block" : "Line",
        value,
        start,
        end,
        loc: {
          start: (
            /** @type {import('acorn').Position} */
            start_loc
          ),
          end: (
            /** @type {import('acorn').Position} */
            end_loc
          )
        }
      });
    },
    /** @param {acorn.Node & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }} ast */
    add_comments(ast) {
      if (comments.length === 0) return;
      comments = comments.filter((comment) => comment.start >= index).map(({ type, value, start, end }) => ({ type, value, start, end }));
      walk(ast, null, {
        _(node, { next: next2, path }) {
          let comment;
          while (comments[0] && comments[0].start < node.start) {
            comment = /** @type {CommentWithLocation} */
            comments.shift();
            (node.leadingComments ||= []).push(comment);
          }
          next2();
          if (comments[0]) {
            const parent = (
              /** @type {any} */
              path.at(-1)
            );
            if (parent === void 0 || node.end !== parent.end) {
              const slice = source2.slice(node.end, comments[0].start);
              const is_last_in_body = (parent?.type === "BlockStatement" || parent?.type === "Program") && parent.body.indexOf(node) === parent.body.length - 1 || parent?.type === "ArrayExpression" && parent.elements.indexOf(node) === parent.elements.length - 1 || parent?.type === "ObjectExpression" && parent.properties.indexOf(node) === parent.properties.length - 1;
              if (is_last_in_body) {
                let end = node.end;
                while (comments.length) {
                  const comment2 = comments[0];
                  if (parent && comment2.start >= parent.end) break;
                  (node.trailingComments ||= []).push(comment2);
                  comments.shift();
                  end = comment2.end;
                }
              } else if (node.end <= comments[0].start && /^[,) \t]*$/.test(slice)) {
                node.trailingComments = [
                  /** @type {CommentWithLocation} */
                  comments.shift()
                ];
              }
            }
          }
        }
      });
      if (comments.length > 0 && (comments[0].start >= ast.end || ast.type === "Program")) {
        (ast.trailingComments ||= []).push(...comments.splice(0));
      }
    }
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/errors.js
var InternalCompileError = class extends Error {
  message = "";
  // ensure this property is enumerable
  #diagnostic;
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(message);
    this.stack = "";
    this.#diagnostic = new CompileDiagnostic(code, message, position);
    Object.assign(this, this.#diagnostic);
    this.name = "CompileError";
  }
  toString() {
    return this.#diagnostic.toString();
  }
  toJSON() {
    return this.#diagnostic.toJSON();
  }
};
function e(node, code, message) {
  const start = typeof node === "number" ? node : node?.start;
  const end = typeof node === "number" ? node : node?.end;
  throw new InternalCompileError(code, message, start !== void 0 ? [start, end ?? start] : void 0);
}
function options_invalid_value(node, details) {
  e(node, "options_invalid_value", `Invalid compiler option: ${details}
https://svelte.dev/e/options_invalid_value`);
}
function options_removed(node, details) {
  e(node, "options_removed", `Invalid compiler option: ${details}
https://svelte.dev/e/options_removed`);
}
function options_unrecognised(node, keypath) {
  e(node, "options_unrecognised", `Unrecognised compiler option ${keypath}
https://svelte.dev/e/options_unrecognised`);
}
function bindable_invalid_location(node) {
  e(node, "bindable_invalid_location", `\`$bindable()\` can only be used inside a \`$props()\` declaration
https://svelte.dev/e/bindable_invalid_location`);
}
function constant_assignment(node, thing) {
  e(node, "constant_assignment", `Cannot assign to ${thing}
https://svelte.dev/e/constant_assignment`);
}
function constant_binding(node, thing) {
  e(node, "constant_binding", `Cannot bind to ${thing}
https://svelte.dev/e/constant_binding`);
}
function declaration_duplicate(node, name) {
  e(node, "declaration_duplicate", `\`${name}\` has already been declared
https://svelte.dev/e/declaration_duplicate`);
}
function declaration_duplicate_module_import(node) {
  e(node, "declaration_duplicate_module_import", `Cannot declare a variable with the same name as an import inside \`<script module>\`
https://svelte.dev/e/declaration_duplicate_module_import`);
}
function derived_invalid_export(node) {
  e(node, "derived_invalid_export", `Cannot export derived state from a module. To expose the current derived value, export a function returning its value
https://svelte.dev/e/derived_invalid_export`);
}
function dollar_binding_invalid(node) {
  e(node, "dollar_binding_invalid", `The $ name is reserved, and cannot be used for variables and imports
https://svelte.dev/e/dollar_binding_invalid`);
}
function dollar_prefix_invalid(node) {
  e(node, "dollar_prefix_invalid", `The $ prefix is reserved, and cannot be used for variables and imports
https://svelte.dev/e/dollar_prefix_invalid`);
}
function duplicate_class_field(node, name) {
  e(node, "duplicate_class_field", `\`${name}\` has already been declared
https://svelte.dev/e/duplicate_class_field`);
}
function each_item_invalid_assignment(node) {
  e(node, "each_item_invalid_assignment", `Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. \`array[i] = value\` instead of \`entry = value\`, or \`bind:value={array[i]}\` instead of \`bind:value={entry}\`)
https://svelte.dev/e/each_item_invalid_assignment`);
}
function effect_invalid_placement(node) {
  e(node, "effect_invalid_placement", `\`$effect()\` can only be used as an expression statement
https://svelte.dev/e/effect_invalid_placement`);
}
function experimental_async(node) {
  e(node, "experimental_async", `Cannot use \`await\` in deriveds and template expressions, or at the top level of a component, unless the \`experimental.async\` compiler option is \`true\`
https://svelte.dev/e/experimental_async`);
}
function export_undefined(node, name) {
  e(node, "export_undefined", `\`${name}\` is not defined
https://svelte.dev/e/export_undefined`);
}
function global_reference_invalid(node, name) {
  e(node, "global_reference_invalid", `\`${name}\` is an illegal variable name. To reference a global variable called \`${name}\`, use \`globalThis.${name}\`
https://svelte.dev/e/global_reference_invalid`);
}
function host_invalid_placement(node) {
  e(node, "host_invalid_placement", `\`$host()\` can only be used inside custom element component instances
https://svelte.dev/e/host_invalid_placement`);
}
function import_svelte_internal_forbidden(node) {
  e(node, "import_svelte_internal_forbidden", `Imports of \`svelte/internal/*\` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from \`svelte/internal/*\` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case
https://svelte.dev/e/import_svelte_internal_forbidden`);
}
function inspect_trace_generator(node) {
  e(node, "inspect_trace_generator", `\`$inspect.trace(...)\` cannot be used inside a generator function
https://svelte.dev/e/inspect_trace_generator`);
}
function inspect_trace_invalid_placement(node) {
  e(node, "inspect_trace_invalid_placement", `\`$inspect.trace(...)\` must be the first statement of a function body
https://svelte.dev/e/inspect_trace_invalid_placement`);
}
function invalid_arguments_usage(node) {
  e(node, "invalid_arguments_usage", `The arguments keyword cannot be used within the template or at the top level of a component
https://svelte.dev/e/invalid_arguments_usage`);
}
function legacy_await_invalid(node) {
  e(node, "legacy_await_invalid", `Cannot use \`await\` in deriveds and template expressions, or at the top level of a component, unless in runes mode
https://svelte.dev/e/legacy_await_invalid`);
}
function legacy_export_invalid(node) {
  e(node, "legacy_export_invalid", `Cannot use \`export let\` in runes mode \u2014 use \`$props()\` instead
https://svelte.dev/e/legacy_export_invalid`);
}
function legacy_props_invalid(node) {
  e(node, "legacy_props_invalid", `Cannot use \`$$props\` in runes mode
https://svelte.dev/e/legacy_props_invalid`);
}
function legacy_reactive_statement_invalid(node) {
  e(node, "legacy_reactive_statement_invalid", `\`$:\` is not allowed in runes mode, use \`$derived\` or \`$effect\` instead
https://svelte.dev/e/legacy_reactive_statement_invalid`);
}
function legacy_rest_props_invalid(node) {
  e(node, "legacy_rest_props_invalid", `Cannot use \`$$restProps\` in runes mode
https://svelte.dev/e/legacy_rest_props_invalid`);
}
function module_illegal_default_export(node) {
  e(node, "module_illegal_default_export", `A component cannot have a default export
https://svelte.dev/e/module_illegal_default_export`);
}
function props_duplicate(node, rune) {
  e(node, "props_duplicate", `Cannot use \`${rune}()\` more than once
https://svelte.dev/e/props_duplicate`);
}
function props_id_invalid_placement(node) {
  e(node, "props_id_invalid_placement", `\`$props.id()\` can only be used at the top level of components as a variable declaration initializer
https://svelte.dev/e/props_id_invalid_placement`);
}
function props_illegal_name(node) {
  e(node, "props_illegal_name", `Declaring or accessing a prop starting with \`$$\` is illegal (they are reserved for Svelte internals)
https://svelte.dev/e/props_illegal_name`);
}
function props_invalid_identifier(node) {
  e(node, "props_invalid_identifier", `\`$props()\` can only be used with an object destructuring pattern
https://svelte.dev/e/props_invalid_identifier`);
}
function props_invalid_pattern(node) {
  e(node, "props_invalid_pattern", `\`$props()\` assignment must not contain nested properties or computed keys
https://svelte.dev/e/props_invalid_pattern`);
}
function props_invalid_placement(node) {
  e(node, "props_invalid_placement", `\`$props()\` can only be used at the top level of components as a variable declaration initializer
https://svelte.dev/e/props_invalid_placement`);
}
function reactive_declaration_cycle(node, cycle) {
  e(node, "reactive_declaration_cycle", `Cyclical dependency detected: ${cycle}
https://svelte.dev/e/reactive_declaration_cycle`);
}
function rune_invalid_arguments(node, rune) {
  e(node, "rune_invalid_arguments", `\`${rune}\` cannot be called with arguments
https://svelte.dev/e/rune_invalid_arguments`);
}
function rune_invalid_arguments_length(node, rune, args) {
  e(node, "rune_invalid_arguments_length", `\`${rune}\` must be called with ${args}
https://svelte.dev/e/rune_invalid_arguments_length`);
}
function rune_invalid_computed_property(node) {
  e(node, "rune_invalid_computed_property", `Cannot access a computed property of a rune
https://svelte.dev/e/rune_invalid_computed_property`);
}
function rune_invalid_name(node, name) {
  e(node, "rune_invalid_name", `\`${name}\` is not a valid rune
https://svelte.dev/e/rune_invalid_name`);
}
function rune_invalid_spread(node, rune) {
  e(node, "rune_invalid_spread", `\`${rune}\` cannot be called with a spread argument
https://svelte.dev/e/rune_invalid_spread`);
}
function rune_invalid_usage(node, rune) {
  e(node, "rune_invalid_usage", `Cannot use \`${rune}\` rune in non-runes mode
https://svelte.dev/e/rune_invalid_usage`);
}
function rune_missing_parentheses(node) {
  e(node, "rune_missing_parentheses", `Cannot use rune without parentheses
https://svelte.dev/e/rune_missing_parentheses`);
}
function rune_removed(node, name) {
  e(node, "rune_removed", `The \`${name}\` rune has been removed
https://svelte.dev/e/rune_removed`);
}
function rune_renamed(node, name, replacement) {
  e(node, "rune_renamed", `\`${name}\` is now \`${replacement}\`
https://svelte.dev/e/rune_renamed`);
}
function runes_mode_invalid_import(node, name) {
  e(node, "runes_mode_invalid_import", `${name} cannot be used in runes mode
https://svelte.dev/e/runes_mode_invalid_import`);
}
function snippet_invalid_export(node) {
  e(node, "snippet_invalid_export", `An exported snippet can only reference things declared in a \`<script module>\`, or other exportable snippets
https://svelte.dev/e/snippet_invalid_export`);
}
function snippet_parameter_assignment(node) {
  e(node, "snippet_parameter_assignment", `Cannot reassign or bind to snippet parameter
https://svelte.dev/e/snippet_parameter_assignment`);
}
function state_field_duplicate(node, name) {
  e(node, "state_field_duplicate", `\`${name}\` has already been declared on this class
https://svelte.dev/e/state_field_duplicate`);
}
function state_field_invalid_assignment(node) {
  e(node, "state_field_invalid_assignment", `Cannot assign to a state field before its declaration
https://svelte.dev/e/state_field_invalid_assignment`);
}
function state_invalid_export(node) {
  e(node, "state_invalid_export", `Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties
https://svelte.dev/e/state_invalid_export`);
}
function state_invalid_placement(node, rune) {
  e(node, "state_invalid_placement", `\`${rune}(...)\` can only be used as a variable declaration initializer, a class field declaration, or the first assignment to a class field at the top level of the constructor.
https://svelte.dev/e/state_invalid_placement`);
}
function store_invalid_scoped_subscription(node) {
  e(node, "store_invalid_scoped_subscription", `Cannot subscribe to stores that are not declared at the top level of the component
https://svelte.dev/e/store_invalid_scoped_subscription`);
}
function store_invalid_subscription(node) {
  e(node, "store_invalid_subscription", `Cannot reference store value inside \`<script module>\`
https://svelte.dev/e/store_invalid_subscription`);
}
function typescript_invalid_feature(node, feature) {
  e(node, "typescript_invalid_feature", `TypeScript language features like ${feature} are not natively supported, and their use is generally discouraged. Outside of \`<script>\` tags, these features are not supported. For use within \`<script>\` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using \`vitePreprocess\`, make sure to specifically enable preprocessing script tags (\`vitePreprocess({ script: true })\`)
https://svelte.dev/e/typescript_invalid_feature`);
}
function css_empty_declaration(node) {
  e(node, "css_empty_declaration", `Declaration cannot be empty
https://svelte.dev/e/css_empty_declaration`);
}
function css_expected_identifier(node) {
  e(node, "css_expected_identifier", `Expected a valid CSS identifier
https://svelte.dev/e/css_expected_identifier`);
}
function css_global_block_invalid_combinator(node, name) {
  e(node, "css_global_block_invalid_combinator", `A \`:global\` selector cannot follow a \`${name}\` combinator
https://svelte.dev/e/css_global_block_invalid_combinator`);
}
function css_global_block_invalid_declaration(node) {
  e(node, "css_global_block_invalid_declaration", `A top-level \`:global {...}\` block can only contain rules, not declarations
https://svelte.dev/e/css_global_block_invalid_declaration`);
}
function css_global_block_invalid_list(node) {
  e(node, "css_global_block_invalid_list", `A \`:global\` selector cannot be part of a selector list with entries that don't contain \`:global\`
https://svelte.dev/e/css_global_block_invalid_list`);
}
function css_global_block_invalid_modifier(node) {
  e(node, "css_global_block_invalid_modifier", `A \`:global\` selector cannot modify an existing selector
https://svelte.dev/e/css_global_block_invalid_modifier`);
}
function css_global_block_invalid_modifier_start(node) {
  e(node, "css_global_block_invalid_modifier_start", `A \`:global\` selector can only be modified if it is a descendant of other selectors
https://svelte.dev/e/css_global_block_invalid_modifier_start`);
}
function css_global_block_invalid_placement(node) {
  e(node, "css_global_block_invalid_placement", `A \`:global\` selector cannot be inside a pseudoclass
https://svelte.dev/e/css_global_block_invalid_placement`);
}
function css_global_invalid_placement(node) {
  e(node, "css_global_invalid_placement", `\`:global(...)\` can be at the start or end of a selector sequence, but not in the middle
https://svelte.dev/e/css_global_invalid_placement`);
}
function css_global_invalid_selector(node) {
  e(node, "css_global_invalid_selector", `\`:global(...)\` must contain exactly one selector
https://svelte.dev/e/css_global_invalid_selector`);
}
function css_global_invalid_selector_list(node) {
  e(node, "css_global_invalid_selector_list", `\`:global(...)\` must not contain type or universal selectors when used in a compound selector
https://svelte.dev/e/css_global_invalid_selector_list`);
}
function css_nesting_selector_invalid_placement(node) {
  e(node, "css_nesting_selector_invalid_placement", `Nesting selectors can only be used inside a rule or as the first selector inside a lone \`:global(...)\`
https://svelte.dev/e/css_nesting_selector_invalid_placement`);
}
function css_selector_invalid(node) {
  e(node, "css_selector_invalid", `Invalid selector
https://svelte.dev/e/css_selector_invalid`);
}
function css_type_selector_invalid_placement(node) {
  e(node, "css_type_selector_invalid_placement", `\`:global(...)\` must not be followed by a type selector
https://svelte.dev/e/css_type_selector_invalid_placement`);
}
function animation_duplicate(node) {
  e(node, "animation_duplicate", `An element can only have one 'animate' directive
https://svelte.dev/e/animation_duplicate`);
}
function animation_invalid_placement(node) {
  e(node, "animation_invalid_placement", `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block
https://svelte.dev/e/animation_invalid_placement`);
}
function animation_missing_key(node) {
  e(node, "animation_missing_key", `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block. Did you forget to add a key to your each block?
https://svelte.dev/e/animation_missing_key`);
}
function attribute_contenteditable_dynamic(node) {
  e(node, "attribute_contenteditable_dynamic", `'contenteditable' attribute cannot be dynamic if element uses two-way binding
https://svelte.dev/e/attribute_contenteditable_dynamic`);
}
function attribute_contenteditable_missing(node) {
  e(node, "attribute_contenteditable_missing", `'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings
https://svelte.dev/e/attribute_contenteditable_missing`);
}
function attribute_duplicate(node) {
  e(node, "attribute_duplicate", `Attributes need to be unique
https://svelte.dev/e/attribute_duplicate`);
}
function attribute_empty_shorthand(node) {
  e(node, "attribute_empty_shorthand", `Attribute shorthand cannot be empty
https://svelte.dev/e/attribute_empty_shorthand`);
}
function attribute_invalid_event_handler(node) {
  e(node, "attribute_invalid_event_handler", `Event attribute must be a JavaScript expression, not a string
https://svelte.dev/e/attribute_invalid_event_handler`);
}
function attribute_invalid_multiple(node) {
  e(node, "attribute_invalid_multiple", `'multiple' attribute must be static if select uses two-way binding
https://svelte.dev/e/attribute_invalid_multiple`);
}
function attribute_invalid_name(node, name) {
  e(node, "attribute_invalid_name", `'${name}' is not a valid attribute name
https://svelte.dev/e/attribute_invalid_name`);
}
function attribute_invalid_sequence_expression(node) {
  e(node, "attribute_invalid_sequence_expression", `Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses
https://svelte.dev/e/attribute_invalid_sequence_expression`);
}
function attribute_invalid_type(node) {
  e(node, "attribute_invalid_type", `'type' attribute must be a static text value if input uses two-way binding
https://svelte.dev/e/attribute_invalid_type`);
}
function attribute_unquoted_sequence(node) {
  e(node, "attribute_unquoted_sequence", `Attribute values containing \`{...}\` must be enclosed in quote marks, unless the value only contains the expression
https://svelte.dev/e/attribute_unquoted_sequence`);
}
function bind_group_invalid_expression(node) {
  e(node, "bind_group_invalid_expression", `\`bind:group\` can only bind to an Identifier or MemberExpression
https://svelte.dev/e/bind_group_invalid_expression`);
}
function bind_group_invalid_snippet_parameter(node) {
  e(node, "bind_group_invalid_snippet_parameter", `Cannot \`bind:group\` to a snippet parameter
https://svelte.dev/e/bind_group_invalid_snippet_parameter`);
}
function bind_invalid_expression(node) {
  e(node, "bind_invalid_expression", `Can only bind to an Identifier or MemberExpression or a \`{get, set}\` pair
https://svelte.dev/e/bind_invalid_expression`);
}
function bind_invalid_name(node, name, explanation) {
  e(node, "bind_invalid_name", `${explanation ? `\`bind:${name}\` is not a valid binding. ${explanation}` : `\`bind:${name}\` is not a valid binding`}
https://svelte.dev/e/bind_invalid_name`);
}
function bind_invalid_parens(node, name) {
  e(node, "bind_invalid_parens", `\`bind:${name}={get, set}\` must not have surrounding parentheses
https://svelte.dev/e/bind_invalid_parens`);
}
function bind_invalid_target(node, name, elements) {
  e(node, "bind_invalid_target", `\`bind:${name}\` can only be used with ${elements}
https://svelte.dev/e/bind_invalid_target`);
}
function bind_invalid_value(node) {
  e(node, "bind_invalid_value", `Can only bind to state or props
https://svelte.dev/e/bind_invalid_value`);
}
function block_duplicate_clause(node, name) {
  e(node, "block_duplicate_clause", `${name} cannot appear more than once within a block
https://svelte.dev/e/block_duplicate_clause`);
}
function block_invalid_continuation_placement(node) {
  e(node, "block_invalid_continuation_placement", `{:...} block is invalid at this position (did you forget to close the preceding element or block?)
https://svelte.dev/e/block_invalid_continuation_placement`);
}
function block_invalid_elseif(node) {
  e(node, "block_invalid_elseif", `'elseif' should be 'else if'
https://svelte.dev/e/block_invalid_elseif`);
}
function block_invalid_placement(node, name, location2) {
  e(node, "block_invalid_placement", `{#${name} ...} block cannot be ${location2}
https://svelte.dev/e/block_invalid_placement`);
}
function block_unclosed(node) {
  e(node, "block_unclosed", `Block was left open
https://svelte.dev/e/block_unclosed`);
}
function block_unexpected_character(node, character) {
  e(node, "block_unexpected_character", `Expected a \`${character}\` character immediately following the opening bracket
https://svelte.dev/e/block_unexpected_character`);
}
function block_unexpected_close(node) {
  e(node, "block_unexpected_close", `Unexpected block closing tag
https://svelte.dev/e/block_unexpected_close`);
}
function component_invalid_directive(node) {
  e(node, "component_invalid_directive", `This type of directive is not valid on components
https://svelte.dev/e/component_invalid_directive`);
}
function const_tag_cycle(node, cycle) {
  e(node, "const_tag_cycle", `Cyclical dependency detected: ${cycle}
https://svelte.dev/e/const_tag_cycle`);
}
function const_tag_invalid_expression(node) {
  e(node, "const_tag_invalid_expression", `{@const ...} must consist of a single variable declaration
https://svelte.dev/e/const_tag_invalid_expression`);
}
function const_tag_invalid_placement(node) {
  e(node, "const_tag_invalid_placement", `\`{@const}\` must be the immediate child of \`{#snippet}\`, \`{#if}\`, \`{:else if}\`, \`{:else}\`, \`{#each}\`, \`{:then}\`, \`{:catch}\`, \`<svelte:fragment>\`, \`<svelte:boundary\` or \`<Component>\`
https://svelte.dev/e/const_tag_invalid_placement`);
}
function const_tag_invalid_reference(node, name) {
  e(node, "const_tag_invalid_reference", `The \`{@const ${name} = ...}\` declaration is not available in this snippet
https://svelte.dev/e/const_tag_invalid_reference`);
}
function debug_tag_invalid_arguments(node) {
  e(node, "debug_tag_invalid_arguments", `{@debug ...} arguments must be identifiers, not arbitrary expressions
https://svelte.dev/e/debug_tag_invalid_arguments`);
}
function directive_invalid_value(node) {
  e(node, "directive_invalid_value", `Directive value must be a JavaScript expression enclosed in curly braces
https://svelte.dev/e/directive_invalid_value`);
}
function directive_missing_name(node, type) {
  e(node, "directive_missing_name", `\`${type}\` name cannot be empty
https://svelte.dev/e/directive_missing_name`);
}
function each_key_without_as(node) {
  e(node, "each_key_without_as", `An \`{#each ...}\` block without an \`as\` clause cannot have a key
https://svelte.dev/e/each_key_without_as`);
}
function element_invalid_closing_tag(node, name) {
  e(node, "element_invalid_closing_tag", `\`</${name}>\` attempted to close an element that was not open
https://svelte.dev/e/element_invalid_closing_tag`);
}
function element_invalid_closing_tag_autoclosed(node, name, reason) {
  e(node, "element_invalid_closing_tag_autoclosed", `\`</${name}>\` attempted to close element that was already automatically closed by \`<${reason}>\` (cannot nest \`<${reason}>\` inside \`<${name}>\`)
https://svelte.dev/e/element_invalid_closing_tag_autoclosed`);
}
function element_unclosed(node, name) {
  e(node, "element_unclosed", `\`<${name}>\` was left open
https://svelte.dev/e/element_unclosed`);
}
function event_handler_invalid_component_modifier(node) {
  e(node, "event_handler_invalid_component_modifier", `Event modifiers other than 'once' can only be used on DOM elements
https://svelte.dev/e/event_handler_invalid_component_modifier`);
}
function event_handler_invalid_modifier(node, list3) {
  e(node, "event_handler_invalid_modifier", `Valid event modifiers are ${list3}
https://svelte.dev/e/event_handler_invalid_modifier`);
}
function event_handler_invalid_modifier_combination(node, modifier1, modifier2) {
  e(node, "event_handler_invalid_modifier_combination", `The '${modifier1}' and '${modifier2}' modifiers cannot be used together
https://svelte.dev/e/event_handler_invalid_modifier_combination`);
}
function expected_attribute_value(node) {
  e(node, "expected_attribute_value", `Expected attribute value
https://svelte.dev/e/expected_attribute_value`);
}
function expected_block_type(node) {
  e(node, "expected_block_type", `Expected 'if', 'each', 'await', 'key' or 'snippet'
https://svelte.dev/e/expected_block_type`);
}
function expected_identifier(node) {
  e(node, "expected_identifier", `Expected an identifier
https://svelte.dev/e/expected_identifier`);
}
function expected_pattern(node) {
  e(node, "expected_pattern", `Expected identifier or destructure pattern
https://svelte.dev/e/expected_pattern`);
}
function expected_token(node, token) {
  e(node, "expected_token", `Expected token ${token}
https://svelte.dev/e/expected_token`);
}
function expected_whitespace(node) {
  e(node, "expected_whitespace", `Expected whitespace
https://svelte.dev/e/expected_whitespace`);
}
function illegal_await_expression(node) {
  e(node, "illegal_await_expression", `\`use:\`, \`transition:\` and \`animate:\` directives, attachments and bindings do not support await expressions
https://svelte.dev/e/illegal_await_expression`);
}
function illegal_element_attribute(node, name) {
  e(node, "illegal_element_attribute", `\`<${name}>\` does not support non-event attributes or spread attributes
https://svelte.dev/e/illegal_element_attribute`);
}
function js_parse_error(node, message) {
  e(node, "js_parse_error", `${message}
https://svelte.dev/e/js_parse_error`);
}
function let_directive_invalid_placement(node) {
  e(node, "let_directive_invalid_placement", `\`let:\` directive at invalid position
https://svelte.dev/e/let_directive_invalid_placement`);
}
function mixed_event_handler_syntaxes(node, name) {
  e(node, "mixed_event_handler_syntaxes", `Mixing old (on:${name}) and new syntaxes for event handling is not allowed. Use only the on${name} syntax
https://svelte.dev/e/mixed_event_handler_syntaxes`);
}
function node_invalid_placement(node, message) {
  e(node, "node_invalid_placement", `${message}. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components.
https://svelte.dev/e/node_invalid_placement`);
}
function render_tag_invalid_call_expression(node) {
  e(node, "render_tag_invalid_call_expression", `Calling a snippet function using apply, bind or call is not allowed
https://svelte.dev/e/render_tag_invalid_call_expression`);
}
function render_tag_invalid_expression(node) {
  e(node, "render_tag_invalid_expression", `\`{@render ...}\` tags can only contain call expressions
https://svelte.dev/e/render_tag_invalid_expression`);
}
function render_tag_invalid_spread_argument(node) {
  e(node, "render_tag_invalid_spread_argument", `cannot use spread arguments in \`{@render ...}\` tags
https://svelte.dev/e/render_tag_invalid_spread_argument`);
}
function script_duplicate(node) {
  e(node, "script_duplicate", `A component can have a single top-level \`<script>\` element and/or a single top-level \`<script module>\` element
https://svelte.dev/e/script_duplicate`);
}
function script_invalid_attribute_value(node, name) {
  e(node, "script_invalid_attribute_value", `If the \`${name}\` attribute is supplied, it must be a boolean attribute
https://svelte.dev/e/script_invalid_attribute_value`);
}
function script_invalid_context(node) {
  e(node, "script_invalid_context", `If the context attribute is supplied, its value must be "module"
https://svelte.dev/e/script_invalid_context`);
}
function script_reserved_attribute(node, name) {
  e(node, "script_reserved_attribute", `The \`${name}\` attribute is reserved and cannot be used
https://svelte.dev/e/script_reserved_attribute`);
}
function slot_attribute_duplicate(node, name, component) {
  e(node, "slot_attribute_duplicate", `Duplicate slot name '${name}' in <${component}>
https://svelte.dev/e/slot_attribute_duplicate`);
}
function slot_attribute_invalid(node) {
  e(node, "slot_attribute_invalid", `slot attribute must be a static value
https://svelte.dev/e/slot_attribute_invalid`);
}
function slot_attribute_invalid_placement(node) {
  e(node, "slot_attribute_invalid_placement", `Element with a slot='...' attribute must be a child of a component or a descendant of a custom element
https://svelte.dev/e/slot_attribute_invalid_placement`);
}
function slot_default_duplicate(node) {
  e(node, "slot_default_duplicate", `Found default slot content alongside an explicit slot="default"
https://svelte.dev/e/slot_default_duplicate`);
}
function slot_element_invalid_attribute(node) {
  e(node, "slot_element_invalid_attribute", `\`<slot>\` can only receive attributes and (optionally) let directives
https://svelte.dev/e/slot_element_invalid_attribute`);
}
function slot_element_invalid_name(node) {
  e(node, "slot_element_invalid_name", `slot attribute must be a static value
https://svelte.dev/e/slot_element_invalid_name`);
}
function slot_element_invalid_name_default(node) {
  e(node, "slot_element_invalid_name_default", `\`default\` is a reserved word \u2014 it cannot be used as a slot name
https://svelte.dev/e/slot_element_invalid_name_default`);
}
function slot_snippet_conflict(node) {
  e(node, "slot_snippet_conflict", `Cannot use \`<slot>\` syntax and \`{@render ...}\` tags in the same component. Migrate towards \`{@render ...}\` tags completely
https://svelte.dev/e/slot_snippet_conflict`);
}
function snippet_conflict(node) {
  e(node, "snippet_conflict", `Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block
https://svelte.dev/e/snippet_conflict`);
}
function snippet_invalid_rest_parameter(node) {
  e(node, "snippet_invalid_rest_parameter", `Snippets do not support rest parameters; use an array instead
https://svelte.dev/e/snippet_invalid_rest_parameter`);
}
function snippet_shadowing_prop(node, prop2) {
  e(node, "snippet_shadowing_prop", `This snippet is shadowing the prop \`${prop2}\` with the same name
https://svelte.dev/e/snippet_shadowing_prop`);
}
function style_directive_invalid_modifier(node) {
  e(node, "style_directive_invalid_modifier", `\`style:\` directive can only use the \`important\` modifier
https://svelte.dev/e/style_directive_invalid_modifier`);
}
function style_duplicate(node) {
  e(node, "style_duplicate", `A component can have a single top-level \`<style>\` element
https://svelte.dev/e/style_duplicate`);
}
function svelte_body_illegal_attribute(node) {
  e(node, "svelte_body_illegal_attribute", `\`<svelte:body>\` does not support non-event attributes or spread attributes
https://svelte.dev/e/svelte_body_illegal_attribute`);
}
function svelte_boundary_invalid_attribute(node) {
  e(node, "svelte_boundary_invalid_attribute", `Valid attributes on \`<svelte:boundary>\` are \`onerror\` and \`failed\`
https://svelte.dev/e/svelte_boundary_invalid_attribute`);
}
function svelte_boundary_invalid_attribute_value(node) {
  e(node, "svelte_boundary_invalid_attribute_value", `Attribute value must be a non-string expression
https://svelte.dev/e/svelte_boundary_invalid_attribute_value`);
}
function svelte_component_invalid_this(node) {
  e(node, "svelte_component_invalid_this", `Invalid component definition \u2014 must be an \`{expression}\`
https://svelte.dev/e/svelte_component_invalid_this`);
}
function svelte_component_missing_this(node) {
  e(node, "svelte_component_missing_this", `\`<svelte:component>\` must have a 'this' attribute
https://svelte.dev/e/svelte_component_missing_this`);
}
function svelte_element_missing_this(node) {
  e(node, "svelte_element_missing_this", `\`<svelte:element>\` must have a 'this' attribute with a value
https://svelte.dev/e/svelte_element_missing_this`);
}
function svelte_fragment_invalid_attribute(node) {
  e(node, "svelte_fragment_invalid_attribute", `\`<svelte:fragment>\` can only have a slot attribute and (optionally) a let: directive
https://svelte.dev/e/svelte_fragment_invalid_attribute`);
}
function svelte_fragment_invalid_placement(node) {
  e(node, "svelte_fragment_invalid_placement", `\`<svelte:fragment>\` must be the direct child of a component
https://svelte.dev/e/svelte_fragment_invalid_placement`);
}
function svelte_head_illegal_attribute(node) {
  e(node, "svelte_head_illegal_attribute", `\`<svelte:head>\` cannot have attributes nor directives
https://svelte.dev/e/svelte_head_illegal_attribute`);
}
function svelte_meta_duplicate(node, name) {
  e(node, "svelte_meta_duplicate", `A component can only have one \`<${name}>\` element
https://svelte.dev/e/svelte_meta_duplicate`);
}
function svelte_meta_invalid_content(node, name) {
  e(node, "svelte_meta_invalid_content", `<${name}> cannot have children
https://svelte.dev/e/svelte_meta_invalid_content`);
}
function svelte_meta_invalid_placement(node, name) {
  e(node, "svelte_meta_invalid_placement", `\`<${name}>\` tags cannot be inside elements or blocks
https://svelte.dev/e/svelte_meta_invalid_placement`);
}
function svelte_meta_invalid_tag(node, list3) {
  e(node, "svelte_meta_invalid_tag", `Valid \`<svelte:...>\` tag names are ${list3}
https://svelte.dev/e/svelte_meta_invalid_tag`);
}
function svelte_options_deprecated_tag(node) {
  e(node, "svelte_options_deprecated_tag", `"tag" option is deprecated \u2014 use "customElement" instead
https://svelte.dev/e/svelte_options_deprecated_tag`);
}
function svelte_options_invalid_attribute(node) {
  e(node, "svelte_options_invalid_attribute", `\`<svelte:options>\` can only receive static attributes
https://svelte.dev/e/svelte_options_invalid_attribute`);
}
function svelte_options_invalid_attribute_value(node, list3) {
  e(node, "svelte_options_invalid_attribute_value", `Value must be ${list3}, if specified
https://svelte.dev/e/svelte_options_invalid_attribute_value`);
}
function svelte_options_invalid_customelement(node) {
  e(node, "svelte_options_invalid_customelement", `"customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }
https://svelte.dev/e/svelte_options_invalid_customelement`);
}
function svelte_options_invalid_customelement_props(node) {
  e(node, "svelte_options_invalid_customelement_props", `"props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"
https://svelte.dev/e/svelte_options_invalid_customelement_props`);
}
function svelte_options_invalid_customelement_shadow(node) {
  e(node, "svelte_options_invalid_customelement_shadow", `"shadow" must be either "open" or "none"
https://svelte.dev/e/svelte_options_invalid_customelement_shadow`);
}
function svelte_options_invalid_tagname(node) {
  e(node, "svelte_options_invalid_tagname", `Tag name must be lowercase and hyphenated
https://svelte.dev/e/svelte_options_invalid_tagname`);
}
function svelte_options_reserved_tagname(node) {
  e(node, "svelte_options_reserved_tagname", `Tag name is reserved
https://svelte.dev/e/svelte_options_reserved_tagname`);
}
function svelte_options_unknown_attribute(node, name) {
  e(node, "svelte_options_unknown_attribute", `\`<svelte:options>\` unknown attribute '${name}'
https://svelte.dev/e/svelte_options_unknown_attribute`);
}
function svelte_self_invalid_placement(node) {
  e(node, "svelte_self_invalid_placement", `\`<svelte:self>\` components can only exist inside \`{#if}\` blocks, \`{#each}\` blocks, \`{#snippet}\` blocks or slots passed to components
https://svelte.dev/e/svelte_self_invalid_placement`);
}
function tag_invalid_name(node) {
  e(node, "tag_invalid_name", `Expected a valid element or component name. Components must have a valid variable name or dot notation expression
https://svelte.dev/e/tag_invalid_name`);
}
function tag_invalid_placement(node, name, location2) {
  e(node, "tag_invalid_placement", `{@${name} ...} tag cannot be ${location2}
https://svelte.dev/e/tag_invalid_placement`);
}
function textarea_invalid_content(node) {
  e(node, "textarea_invalid_content", `A \`<textarea>\` can have either a value attribute or (equivalently) child content, but not both
https://svelte.dev/e/textarea_invalid_content`);
}
function title_illegal_attribute(node) {
  e(node, "title_illegal_attribute", `\`<title>\` cannot have attributes nor directives
https://svelte.dev/e/title_illegal_attribute`);
}
function title_invalid_content(node) {
  e(node, "title_invalid_content", `\`<title>\` can only contain text and {tags}
https://svelte.dev/e/title_invalid_content`);
}
function transition_conflict(node, type, existing) {
  e(node, "transition_conflict", `Cannot use \`${type}:\` alongside existing \`${existing}:\` directive
https://svelte.dev/e/transition_conflict`);
}
function transition_duplicate(node, type) {
  e(node, "transition_duplicate", `Cannot use multiple \`${type}:\` directives on a single element
https://svelte.dev/e/transition_duplicate`);
}
function unexpected_eof(node) {
  e(node, "unexpected_eof", `Unexpected end of input
https://svelte.dev/e/unexpected_eof`);
}
function unexpected_reserved_word(node, word) {
  e(node, "unexpected_reserved_word", `'${word}' is a reserved word in JavaScript and cannot be used here
https://svelte.dev/e/unexpected_reserved_word`);
}
function unterminated_string_constant(node) {
  e(node, "unterminated_string_constant", `Unterminated string constant
https://svelte.dev/e/unterminated_string_constant`);
}
function void_element_invalid_content(node) {
  e(node, "void_element_invalid_content", `Void elements cannot have children or closing tags
https://svelte.dev/e/void_element_invalid_content`);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/utils/bracket.js
function infinity_if_negative(num) {
  if (num < 0) {
    return Infinity;
  }
  return num;
}
function find_string_end(string2, search_start_index, string_start_char) {
  let string_to_search;
  if (string_start_char === "`") {
    string_to_search = string2;
  } else {
    string_to_search = string2.slice(
      0,
      infinity_if_negative(string2.indexOf("\n", search_start_index))
    );
  }
  return find_unescaped_char(string_to_search, search_start_index, string_start_char);
}
function find_regex_end(string2, search_start_index) {
  return find_unescaped_char(string2, search_start_index, "/");
}
function find_unescaped_char(string2, search_start_index, char) {
  let i = search_start_index;
  while (true) {
    const found_index = string2.indexOf(char, i);
    if (found_index === -1) {
      return Infinity;
    }
    if (count_leading_backslashes(string2, found_index - 1) % 2 === 0) {
      return found_index;
    }
    i = found_index + 1;
  }
}
function count_leading_backslashes(string2, search_start_index) {
  let i = search_start_index;
  let count = 0;
  while (string2[i] === "\\") {
    count++;
    i--;
  }
  return count;
}
function find_matching_bracket(template2, index, open2) {
  const close2 = default_brackets[open2];
  let brackets = 1;
  let i = index;
  while (brackets > 0 && i < template2.length) {
    const char = template2[i];
    switch (char) {
      case "'":
      case '"':
      case "`":
        i = find_string_end(template2, i + 1, char) + 1;
        continue;
      case "/": {
        const next_char = template2[i + 1];
        if (!next_char) continue;
        if (next_char === "/") {
          i = infinity_if_negative(template2.indexOf("\n", i + 1)) + "\n".length;
          continue;
        }
        if (next_char === "*") {
          i = infinity_if_negative(template2.indexOf("*/", i + 1)) + "*/".length;
          continue;
        }
        i = find_regex_end(template2, i + 1) + "/".length;
        continue;
      }
      default: {
        const char2 = template2[i];
        if (char2 === open2) {
          brackets++;
        } else if (char2 === close2) {
          brackets--;
        }
        if (brackets === 0) {
          return i;
        }
        i++;
      }
    }
  }
  return void 0;
}
var default_brackets = {
  "{": "}",
  "(": ")",
  "[": "]"
};
function match_bracket(parser, start, brackets = default_brackets) {
  const close2 = Object.values(brackets);
  const bracket_stack = [];
  let i = start;
  while (i < parser.template.length) {
    let char = parser.template[i++];
    if (char === "'" || char === '"' || char === "`") {
      i = match_quote(parser, i, char);
      continue;
    }
    if (char in brackets) {
      bracket_stack.push(char);
    } else if (close2.includes(char)) {
      const popped = (
        /** @type {string} */
        bracket_stack.pop()
      );
      const expected = (
        /** @type {string} */
        brackets[popped]
      );
      if (char !== expected) {
        expected_token(i - 1, expected);
      }
      if (bracket_stack.length === 0) {
        return i;
      }
    }
  }
  unexpected_eof(parser.template.length);
}
function match_quote(parser, start, quote2) {
  let is_escaped = false;
  let i = start;
  while (i < parser.template.length) {
    const char = parser.template[i++];
    if (is_escaped) {
      is_escaped = false;
      continue;
    }
    if (char === quote2) {
      return i;
    }
    if (char === "\\") {
      is_escaped = true;
    }
    if (quote2 === "`" && char === "$" && parser.template[i] === "{") {
      i = match_bracket(parser, i);
    }
  }
  unterminated_string_constant(start);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/read/expression.js
function get_loose_identifier(parser, opening_token) {
  const end = find_matching_bracket(parser.template, parser.index, opening_token ?? "{");
  if (end) {
    const start = parser.index;
    parser.index = end;
    return {
      type: "Identifier",
      start,
      end,
      name: ""
    };
  }
}
function read_expression(parser, opening_token, disallow_loose) {
  try {
    let comment_index = parser.root.comments.length;
    const node = parse_expression_at(
      parser.template,
      parser.root.comments,
      parser.ts,
      parser.index
    );
    let num_parens = 0;
    let i = parser.root.comments.length;
    while (i-- > comment_index) {
      const comment = parser.root.comments[i];
      if (comment.end < node.start) {
        parser.index = comment.end;
        break;
      }
    }
    for (let i2 = parser.index; i2 < /** @type {number} */
    node.start; i2 += 1) {
      if (parser.template[i2] === "(") num_parens += 1;
    }
    let index = (
      /** @type {number} */
      node.end
    );
    const last_comment = parser.root.comments.at(-1);
    if (last_comment && last_comment.end > index) index = last_comment.end;
    while (num_parens > 0) {
      const char = parser.template[index];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        expected_token(index, ")");
      }
      index += 1;
    }
    parser.index = index;
    return (
      /** @type {Expression} */
      node
    );
  } catch (err2) {
    if (parser.loose && !disallow_loose) {
      const expression = get_loose_identifier(parser, opening_token);
      if (expression) {
        return expression;
      }
    }
    parser.acorn_error(err2);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/sanitize_template_string.js
function sanitize_template_string(str2) {
  return str2.replace(/(`|\${|\\)/g, "\\$1");
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/builders.js
function array(elements = []) {
  return { type: "ArrayExpression", elements };
}
function array_pattern(elements) {
  return { type: "ArrayPattern", elements };
}
function assignment_pattern(left, right) {
  return { type: "AssignmentPattern", left, right };
}
function arrow(params, body, async = false) {
  return {
    type: "ArrowFunctionExpression",
    params,
    body,
    expression: body.type !== "BlockStatement",
    generator: false,
    async
  };
}
function assignment(operator, left, right) {
  return { type: "AssignmentExpression", operator, left, right };
}
function await_builder(argument) {
  return { type: "AwaitExpression", argument };
}
function binary(operator, left, right) {
  return { type: "BinaryExpression", operator, left, right };
}
function block(body) {
  return { type: "BlockStatement", body };
}
function labeled(name, body) {
  return { type: "LabeledStatement", label: id(name), body };
}
function call(callee, ...args) {
  if (typeof callee === "string") callee = id(callee);
  args = args.slice();
  let i = args.length;
  let popping = true;
  while (i--) {
    if (!args[i]) {
      if (popping) {
        args.pop();
      } else {
        args[i] = void0;
      }
    } else {
      popping = false;
    }
  }
  return {
    type: "CallExpression",
    callee,
    arguments: (
      /** @type {Array<ESTree.Expression | ESTree.SpreadElement>} */
      args
    ),
    optional: false
  };
}
function maybe_call(callee, ...args) {
  const expression = (
    /** @type {ESTree.SimpleCallExpression} */
    call(callee, ...args)
  );
  expression.optional = true;
  return {
    type: "ChainExpression",
    expression
  };
}
function unary(operator, argument) {
  return { type: "UnaryExpression", argument, operator, prefix: true };
}
var void0 = unary("void", literal2(0));
function logical(operator, left, right) {
  return { type: "LogicalExpression", operator, left, right };
}
function declaration(kind, declarations) {
  return {
    type: "VariableDeclaration",
    kind,
    declarations
  };
}
function declarator(pattern, init3) {
  if (typeof pattern === "string") pattern = id(pattern);
  return { type: "VariableDeclarator", id: pattern, init: init3 };
}
var empty2 = {
  type: "EmptyStatement"
};
function export_default(declaration2) {
  return { type: "ExportDefaultDeclaration", declaration: declaration2 };
}
function for_of(left, right, body, _await = false) {
  return {
    type: "ForOfStatement",
    left,
    right,
    body,
    await: _await
  };
}
function function_declaration(id2, params, body, async = false) {
  return {
    type: "FunctionDeclaration",
    id: id2,
    params,
    body,
    generator: false,
    async
  };
}
function get(name, body) {
  return prop("get", key(name), function_builder(null, [], block(body)));
}
function id(name) {
  return { type: "Identifier", name };
}
function private_id(name) {
  return { type: "PrivateIdentifier", name };
}
function import_namespace(local) {
  return {
    type: "ImportNamespaceSpecifier",
    local: id(local)
  };
}
function init(name, value) {
  return prop("init", key(name), value);
}
function literal2(value) {
  return { type: "Literal", value };
}
function member(object4, property, computed = false, optional = false) {
  if (typeof property === "string") {
    property = id(property);
  }
  return { type: "MemberExpression", object: object4, property, computed, optional };
}
function member_id(path) {
  const parts = path.split(".");
  let expression = id(parts[0]);
  for (let i = 1; i < parts.length; i += 1) {
    expression = member(expression, id(parts[i]));
  }
  return expression;
}
function object(properties) {
  return { type: "ObjectExpression", properties };
}
function object_pattern(properties) {
  return { type: "ObjectPattern", properties };
}
function prop(kind, key2, value, computed = false) {
  return { type: "Property", kind, key: key2, value, method: false, shorthand: false, computed };
}
function prop_def(key2, value, computed = false, is_static = false) {
  return {
    type: "PropertyDefinition",
    decorators: [],
    key: key2,
    value,
    computed,
    static: is_static
  };
}
function quasi(cooked, tail = false) {
  const raw = sanitize_template_string(cooked);
  return { type: "TemplateElement", value: { raw, cooked }, tail };
}
function rest(argument) {
  return { type: "RestElement", argument };
}
function sequence(expressions) {
  return { type: "SequenceExpression", expressions };
}
function set(name, body) {
  return prop("set", key(name), function_builder(null, [id("$$value")], block(body)));
}
function spread(argument) {
  return { type: "SpreadElement", argument };
}
function stmt(expression) {
  return { type: "ExpressionStatement", expression };
}
function template(elements, expressions) {
  return { type: "TemplateLiteral", quasis: elements, expressions };
}
function thunk(expression, async = false) {
  return unthunk(arrow([], expression, async));
}
function unthunk(expression) {
  if (expression.async && expression.body.type === "AwaitExpression") {
    if (!has_await_expression(expression.body.argument)) {
      return unthunk(arrow(expression.params, expression.body.argument));
    }
  }
  if (expression.async === false && expression.body.type === "CallExpression" && expression.body.callee.type === "Identifier" && expression.params.length === expression.body.arguments.length && expression.params.every((param, index) => {
    const arg = (
      /** @type {ESTree.SimpleCallExpression} */
      expression.body.arguments[index]
    );
    return param.type === "Identifier" && arg.type === "Identifier" && param.name === arg.name;
  })) {
    return expression.body.callee;
  }
  return expression;
}
function new_builder(expression, ...args) {
  if (typeof expression === "string") expression = id(expression);
  return {
    callee: expression,
    arguments: args,
    type: "NewExpression"
  };
}
function update(operator, argument, prefix = false) {
  return { type: "UpdateExpression", operator, argument, prefix };
}
function do_while(test, body) {
  return { type: "DoWhileStatement", test, body };
}
var true_instance = literal2(true);
var false_instance = literal2(false);
var null_instance = literal2(null);
var debugger_builder = {
  type: "DebuggerStatement"
};
var this_instance = {
  type: "ThisExpression"
};
function let_builder(pattern, init3) {
  return declaration("let", [declarator(pattern, init3)]);
}
function const_builder(pattern, init3) {
  return declaration("const", [declarator(pattern, init3)]);
}
function var_builder(pattern, init3) {
  return declaration("var", [declarator(pattern, init3)]);
}
function for_builder(init3, test, update2, body) {
  return { type: "ForStatement", init: init3, test, update: update2, body };
}
function method(kind, key2, params, body, computed = false, is_static = false) {
  return {
    type: "MethodDefinition",
    decorators: [],
    key: key2,
    kind,
    value: function_builder(null, params, block(body)),
    computed,
    static: is_static
  };
}
function function_builder(id2, params, body, async = false) {
  return {
    type: "FunctionExpression",
    id: id2,
    params,
    body,
    generator: false,
    async
  };
}
function if_builder(test, consequent, alternate) {
  return { type: "IfStatement", test, consequent, alternate };
}
function import_all(as, source2) {
  return {
    type: "ImportDeclaration",
    attributes: [],
    source: literal2(source2),
    specifiers: [import_namespace(as)]
  };
}
function imports2(parts, source2) {
  return {
    type: "ImportDeclaration",
    attributes: [],
    source: literal2(source2),
    specifiers: parts.map((p) => ({
      type: "ImportSpecifier",
      imported: id(p[0]),
      local: id(p[1])
    }))
  };
}
function return_builder(argument = null) {
  return { type: "ReturnStatement", argument };
}
function throw_error(str2) {
  return {
    type: "ThrowStatement",
    argument: new_builder("Error", literal2(str2))
  };
}
function key(name) {
  return regex_is_valid_identifier.test(name) ? id(name) : literal2(name);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/ast.js
function object2(expression) {
  while (expression.type === "MemberExpression") {
    expression = /** @type {ESTree.MemberExpression | ESTree.Identifier} */
    expression.object;
  }
  if (expression.type !== "Identifier") {
    return null;
  }
  return expression;
}
function is_text_attribute(attribute) {
  return Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "Text";
}
function is_expression_attribute(attribute) {
  return attribute.value !== true && !Array.isArray(attribute.value) || Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "ExpressionTag";
}
function get_attribute_expression(attribute) {
  return Array.isArray(attribute.value) ? (
    /** @type {AST.ExpressionTag} */
    attribute.value[0].expression
  ) : attribute.value.expression;
}
function get_attribute_chunks(value) {
  return Array.isArray(value) ? value : typeof value === "boolean" ? [] : [value];
}
function is_event_attribute(attribute) {
  return is_expression_attribute(attribute) && attribute.name.startsWith("on");
}
function unwrap_pattern(pattern, nodes = []) {
  switch (pattern.type) {
    case "Identifier":
      nodes.push(pattern);
      break;
    case "MemberExpression":
      nodes.push(pattern);
      break;
    case "ObjectPattern":
      for (const prop2 of pattern.properties) {
        if (prop2.type === "RestElement") {
          unwrap_pattern(prop2.argument, nodes);
        } else {
          unwrap_pattern(prop2.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      for (const element2 of pattern.elements) {
        if (element2) unwrap_pattern(element2, nodes);
      }
      break;
    case "RestElement":
      unwrap_pattern(pattern.argument, nodes);
      break;
    case "AssignmentPattern":
      unwrap_pattern(pattern.left, nodes);
      break;
  }
  return nodes;
}
function extract_identifiers(pattern) {
  return unwrap_pattern(pattern, []).filter((node) => node.type === "Identifier");
}
function extract_all_identifiers_from_expression(expr) {
  let nodes = [];
  let keypath = [];
  walk(
    expr,
    {},
    {
      Identifier(node, { path }) {
        const parent = path.at(-1);
        if (parent?.type !== "MemberExpression" || parent.property !== node || parent.computed) {
          nodes.push(node);
        }
        if (parent?.type === "MemberExpression" && parent.computed && parent.property === node) {
          keypath.push(`[${node.name}]`);
        } else {
          keypath.push(node.name);
        }
      },
      Literal(node, { path }) {
        const value = typeof node.value === "string" ? `"${node.value}"` : String(node.value);
        const parent = path.at(-1);
        if (parent?.type === "MemberExpression" && parent.computed && parent.property === node) {
          keypath.push(`[${value}]`);
        } else {
          keypath.push(value);
        }
      },
      ThisExpression(_2, { next: next2 }) {
        keypath.push("this");
        next2();
      }
    }
  );
  return [keypath.join("."), nodes];
}
function extract_identifiers_from_destructuring(node, nodes = []) {
  switch (node.type) {
    case "Identifier":
      nodes.push(node);
      break;
    case "ObjectExpression":
      for (const prop2 of node.properties) {
        if (prop2.type === "Property") {
          extract_identifiers_from_destructuring(
            /** @type {any} */
            prop2.value,
            nodes
          );
        } else {
          extract_identifiers_from_destructuring(
            /** @type {any} */
            prop2.argument,
            nodes
          );
        }
      }
      break;
    case "ArrayExpression":
      for (const element2 of node.elements) {
        if (element2) extract_identifiers_from_destructuring(
          /** @type {any} */
          element2,
          nodes
        );
      }
      break;
  }
  return nodes;
}
function extract_paths(param, initial) {
  const inserts = [];
  const paths = [];
  _extract_paths(paths, inserts, param, initial, initial, false);
  return { inserts, paths };
}
function _extract_paths(paths, inserts, param, expression, update_expression, has_default_value) {
  switch (param.type) {
    case "Identifier":
    case "MemberExpression":
      paths.push({
        node: param,
        is_rest: false,
        has_default_value,
        expression,
        update_expression
      });
      break;
    case "ObjectPattern":
      for (const prop2 of param.properties) {
        if (prop2.type === "RestElement") {
          const props = [];
          for (const p of param.properties) {
            if (p.type === "Property" && p.key.type !== "PrivateIdentifier") {
              if (p.key.type === "Identifier" && !p.computed) {
                props.push(literal2(p.key.name));
              } else if (p.key.type === "Literal") {
                props.push(literal2(String(p.key.value)));
              } else {
                props.push(call("String", p.key));
              }
            }
          }
          const rest_expression = call("$.exclude_from_object", expression, array(props));
          if (prop2.argument.type === "Identifier") {
            paths.push({
              node: prop2.argument,
              is_rest: true,
              has_default_value,
              expression: rest_expression,
              update_expression: rest_expression
            });
          } else {
            _extract_paths(
              paths,
              inserts,
              prop2.argument,
              rest_expression,
              rest_expression,
              has_default_value
            );
          }
        } else {
          const object_expression = member(
            expression,
            prop2.key,
            prop2.computed || prop2.key.type !== "Identifier"
          );
          _extract_paths(
            paths,
            inserts,
            prop2.value,
            object_expression,
            object_expression,
            has_default_value
          );
        }
      }
      break;
    case "ArrayPattern": {
      const id2 = id("#");
      const value = call(
        "$.to_array",
        expression,
        param.elements.at(-1)?.type === "RestElement" ? void 0 : literal2(param.elements.length)
      );
      inserts.push({ id: id2, value });
      for (let i = 0; i < param.elements.length; i += 1) {
        const element2 = param.elements[i];
        if (element2) {
          if (element2.type === "RestElement") {
            const rest_expression = call(member(id2, "slice"), literal2(i));
            if (element2.argument.type === "Identifier") {
              paths.push({
                node: element2.argument,
                is_rest: true,
                has_default_value,
                expression: rest_expression,
                update_expression: rest_expression
              });
            } else {
              _extract_paths(
                paths,
                inserts,
                element2.argument,
                rest_expression,
                rest_expression,
                has_default_value
              );
            }
          } else {
            const array_expression = member(id2, literal2(i), true);
            _extract_paths(
              paths,
              inserts,
              element2,
              array_expression,
              array_expression,
              has_default_value
            );
          }
        }
      }
      break;
    }
    case "AssignmentPattern": {
      const fallback_expression = build_fallback(expression, param.right);
      if (param.left.type === "Identifier") {
        paths.push({
          node: param.left,
          is_rest: false,
          has_default_value: true,
          expression: fallback_expression,
          update_expression
        });
      } else {
        _extract_paths(paths, inserts, param.left, fallback_expression, update_expression, true);
      }
      break;
    }
  }
  return paths;
}
function get_parent(path, at3) {
  let node = path.at(at3);
  if (node.type === "TSNonNullExpression" || node.type === "TSAsExpression") {
    return (
      /** @type {T} */
      path.at(at3 < 0 ? at3 - 1 : at3 + 1)
    );
  }
  return (
    /** @type {T} */
    node
  );
}
function is_simple_expression(node) {
  if (node.type === "Literal" || node.type === "Identifier" || node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression") {
    return true;
  }
  if (node.type === "ConditionalExpression") {
    return is_simple_expression(node.test) && is_simple_expression(node.consequent) && is_simple_expression(node.alternate);
  }
  if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
    return node.left.type !== "PrivateIdentifier" && is_simple_expression(node.left) && is_simple_expression(node.right);
  }
  return false;
}
function unwrap_optional(node) {
  return node.type === "ChainExpression" ? node.expression : node;
}
function is_expression_async(expression) {
  switch (expression.type) {
    case "AwaitExpression": {
      return true;
    }
    case "ArrayPattern": {
      return expression.elements.some((element2) => element2 && is_expression_async(element2));
    }
    case "ArrayExpression": {
      return expression.elements.some((element2) => {
        if (!element2) {
          return false;
        } else if (element2.type === "SpreadElement") {
          return is_expression_async(element2.argument);
        } else {
          return is_expression_async(element2);
        }
      });
    }
    case "AssignmentPattern":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "LogicalExpression": {
      return expression.left.type !== "PrivateIdentifier" && is_expression_async(expression.left) || is_expression_async(expression.right);
    }
    case "CallExpression":
    case "NewExpression": {
      return expression.callee.type !== "Super" && is_expression_async(expression.callee) || expression.arguments.some((element2) => {
        if (element2.type === "SpreadElement") {
          return is_expression_async(element2.argument);
        } else {
          return is_expression_async(element2);
        }
      });
    }
    case "ChainExpression": {
      return is_expression_async(expression.expression);
    }
    case "ConditionalExpression": {
      return is_expression_async(expression.test) || is_expression_async(expression.alternate) || is_expression_async(expression.consequent);
    }
    case "ImportExpression": {
      return is_expression_async(expression.source);
    }
    case "MemberExpression": {
      return expression.object.type !== "Super" && is_expression_async(expression.object) || expression.property.type !== "PrivateIdentifier" && is_expression_async(expression.property);
    }
    case "ObjectPattern":
    case "ObjectExpression": {
      return expression.properties.some((property) => {
        if (property.type === "SpreadElement") {
          return is_expression_async(property.argument);
        } else if (property.type === "Property") {
          return property.key.type !== "PrivateIdentifier" && is_expression_async(property.key) || is_expression_async(property.value);
        }
      });
    }
    case "RestElement": {
      return is_expression_async(expression.argument);
    }
    case "SequenceExpression":
    case "TemplateLiteral": {
      return expression.expressions.some((subexpression) => is_expression_async(subexpression));
    }
    case "TaggedTemplateExpression": {
      return is_expression_async(expression.tag) || is_expression_async(expression.quasi);
    }
    case "UnaryExpression":
    case "UpdateExpression": {
      return is_expression_async(expression.argument);
    }
    case "YieldExpression": {
      return expression.argument ? is_expression_async(expression.argument) : false;
    }
    default:
      return false;
  }
}
function build_fallback(expression, fallback) {
  if (is_simple_expression(fallback)) {
    return call("$.fallback", expression, fallback);
  }
  if (fallback.type === "AwaitExpression" && is_simple_expression(fallback.argument)) {
    return await_builder(call("$.fallback", expression, fallback.argument));
  }
  return is_expression_async(fallback) ? await_builder(call("$.fallback", expression, thunk(fallback, true), true_instance)) : call("$.fallback", expression, thunk(fallback), true_instance);
}
function build_assignment_value(operator, left, right) {
  return operator === "=" ? right : (
    // turn something like x += 1 into x = x + 1
    ["||=", "&&=", "??="].includes(operator) ? logical(
      /** @type {ESTree.LogicalOperator} */
      operator.slice(0, -1),
      left,
      right
    ) : binary(
      /** @type {ESTree.BinaryOperator} */
      operator.slice(0, -1),
      left,
      right
    )
  );
}
function has_await_expression(node) {
  let has_await = false;
  walk(node, null, {
    AwaitExpression(_node, context) {
      has_await = true;
      context.stop();
    },
    // don't traverse into these
    FunctionDeclaration() {
    },
    FunctionExpression() {
    },
    ArrowFunctionExpression() {
    }
  });
  return has_await;
}
function save(expression) {
  return call(await_builder(call("$.save", expression)));
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/read/script.js
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
var RESERVED_ATTRIBUTES = ["server", "client", "worker", "test", "default"];
var ALLOWED_ATTRIBUTES = ["context", "generics", "lang", "module"];
function read_script(parser, start, attributes) {
  const script_start = parser.index;
  const data2 = parser.read_until(regex_closing_script_tag);
  if (parser.index >= parser.template.length) {
    element_unclosed(parser.template.length, "script");
  }
  const source2 = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data2;
  parser.read(regex_starts_with_closing_script_tag);
  let ast;
  try {
    ast = parse4(source2, parser.root.comments, parser.ts, true);
  } catch (err2) {
    parser.acorn_error(err2);
  }
  ast.start = script_start;
  let context = "default";
  for (
    const attribute of
    /** @type {AST.Attribute[]} */
    attributes
  ) {
    if (RESERVED_ATTRIBUTES.includes(attribute.name)) {
      script_reserved_attribute(attribute, attribute.name);
    }
    if (!ALLOWED_ATTRIBUTES.includes(attribute.name)) {
      script_unknown_attribute(attribute);
    }
    if (attribute.name === "module") {
      if (attribute.value !== true) {
        script_invalid_attribute_value(attribute, attribute.name);
      }
      context = "module";
    }
    if (attribute.name === "context") {
      if (attribute.value === true || !is_text_attribute(attribute)) {
        script_invalid_context(attribute);
      }
      const value = attribute.value[0].data;
      if (value !== "module") {
        script_invalid_context(attribute);
      }
      context = "module";
    }
  }
  return {
    type: "Script",
    start,
    end: parser.index,
    context,
    content: ast,
    // @ts-ignore
    attributes
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/read/style.js
var REGEX_MATCHER = /^[~^$*|]?=/;
var REGEX_CLOSING_BRACKET = /[\s\]]/;
var REGEX_ATTRIBUTE_FLAGS = /^[a-zA-Z]+/;
var REGEX_COMBINATOR = /^(\+|~|>|\|\|)/;
var REGEX_PERCENTAGE = /^\d+(\.\d+)?%/;
var REGEX_NTH_OF = /^(even|odd|\+?(\d+|\d*n(\s*[+-]\s*\d+)?)|-\d*n(\s*\+\s*\d+))((?=\s*[,)])|\s+of\s+)/;
var REGEX_WHITESPACE_OR_COLON = /[\s:]/;
var REGEX_LEADING_HYPHEN_OR_DIGIT = /-?\d/;
var REGEX_VALID_IDENTIFIER_CHAR = /[a-zA-Z0-9_-]/;
var REGEX_UNICODE_SEQUENCE = /^\\[0-9a-fA-F]{1,6}(\r\n|\s)?/;
var REGEX_COMMENT_CLOSE = /\*\//;
var REGEX_HTML_COMMENT_CLOSE = /-->/;
function read_style(parser, start, attributes) {
  const content_start = parser.index;
  const children = read_body(parser, "</style");
  const content_end = parser.index;
  parser.read(/^<\/style\s*>/);
  return {
    type: "StyleSheet",
    start,
    end: parser.index,
    attributes,
    children,
    content: {
      start: content_start,
      end: content_end,
      styles: parser.template.slice(content_start, content_end),
      comment: null
    }
  };
}
function read_body(parser, close2) {
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match(close2)) {
      return children;
    }
    if (parser.match("@")) {
      children.push(read_at_rule(parser));
    } else {
      children.push(read_rule(parser));
    }
  }
  expected_token(parser.template.length, close2);
}
function read_at_rule(parser) {
  const start = parser.index;
  parser.eat("@", true);
  const name = read_identifier(parser);
  const prelude = read_value(parser);
  let block2 = null;
  if (parser.match("{")) {
    block2 = read_block(parser);
  } else {
    parser.eat(";", true);
  }
  return {
    type: "Atrule",
    start,
    end: parser.index,
    name,
    prelude,
    block: block2
  };
}
function read_rule(parser) {
  const start = parser.index;
  return {
    type: "Rule",
    prelude: read_selector_list(parser),
    block: read_block(parser),
    start,
    end: parser.index,
    metadata: {
      parent_rule: null,
      has_local_selectors: false,
      has_global_selectors: false,
      is_global_block: false
    }
  };
}
function read_selector_list(parser, inside_pseudo_class = false) {
  const children = [];
  allow_comment_or_whitespace(parser);
  const start = parser.index;
  while (parser.index < parser.template.length) {
    children.push(read_selector(parser, inside_pseudo_class));
    const end = parser.index;
    allow_comment_or_whitespace(parser);
    if (inside_pseudo_class ? parser.match(")") : parser.match("{")) {
      return {
        type: "SelectorList",
        start,
        end,
        children
      };
    } else {
      parser.eat(",", true);
      allow_comment_or_whitespace(parser);
    }
  }
  unexpected_eof(parser.template.length);
}
function read_selector(parser, inside_pseudo_class = false) {
  const list_start = parser.index;
  const children = [];
  function create_selector(combinator, start) {
    return {
      type: "RelativeSelector",
      combinator,
      selectors: [],
      start,
      end: -1,
      metadata: {
        is_global: false,
        is_global_like: false,
        scoped: false
      }
    };
  }
  let relative_selector = create_selector(null, parser.index);
  while (parser.index < parser.template.length) {
    let start = parser.index;
    if (parser.eat("&")) {
      relative_selector.selectors.push({
        type: "NestingSelector",
        name: "&",
        start,
        end: parser.index
      });
    } else if (parser.eat("*")) {
      let name = "*";
      if (parser.eat("|")) {
        name = read_identifier(parser);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name,
        start,
        end: parser.index
      });
    } else if (parser.eat("#")) {
      relative_selector.selectors.push({
        type: "IdSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat(".")) {
      relative_selector.selectors.push({
        type: "ClassSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat("::")) {
      relative_selector.selectors.push({
        type: "PseudoElementSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
      if (parser.eat("(")) {
        read_selector_list(parser, true);
        parser.eat(")", true);
      }
    } else if (parser.eat(":")) {
      const name = read_identifier(parser);
      let args = null;
      if (parser.eat("(")) {
        args = read_selector_list(parser, true);
        parser.eat(")", true);
      }
      relative_selector.selectors.push({
        type: "PseudoClassSelector",
        name,
        args,
        start,
        end: parser.index
      });
    } else if (parser.eat("[")) {
      parser.allow_whitespace();
      const name = read_identifier(parser);
      parser.allow_whitespace();
      let value = null;
      const matcher = parser.read(REGEX_MATCHER);
      if (matcher) {
        parser.allow_whitespace();
        value = read_attribute_value(parser);
      }
      parser.allow_whitespace();
      const flags = parser.read(REGEX_ATTRIBUTE_FLAGS);
      parser.allow_whitespace();
      parser.eat("]", true);
      relative_selector.selectors.push({
        type: "AttributeSelector",
        start,
        end: parser.index,
        name,
        matcher,
        value,
        flags
      });
    } else if (inside_pseudo_class && parser.match_regex(REGEX_NTH_OF)) {
      relative_selector.selectors.push({
        type: "Nth",
        value: (
          /**@type {string} */
          parser.read(REGEX_NTH_OF)
        ),
        start,
        end: parser.index
      });
    } else if (parser.match_regex(REGEX_PERCENTAGE)) {
      relative_selector.selectors.push({
        type: "Percentage",
        value: (
          /** @type {string} */
          parser.read(REGEX_PERCENTAGE)
        ),
        start,
        end: parser.index
      });
    } else if (!parser.match_regex(REGEX_COMBINATOR)) {
      let name = read_identifier(parser);
      if (parser.eat("|")) {
        name = read_identifier(parser);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name,
        start,
        end: parser.index
      });
    }
    const index = parser.index;
    allow_comment_or_whitespace(parser);
    if (parser.match(",") || (inside_pseudo_class ? parser.match(")") : parser.match("{"))) {
      parser.index = index;
      relative_selector.end = index;
      children.push(relative_selector);
      return {
        type: "ComplexSelector",
        start: list_start,
        end: index,
        children,
        metadata: {
          rule: null,
          is_global: false,
          used: false
        }
      };
    }
    parser.index = index;
    const combinator = read_combinator(parser);
    if (combinator) {
      if (relative_selector.selectors.length > 0) {
        relative_selector.end = index;
        children.push(relative_selector);
      }
      relative_selector = create_selector(combinator, combinator.start);
      parser.allow_whitespace();
      if (parser.match(",") || (inside_pseudo_class ? parser.match(")") : parser.match("{"))) {
        css_selector_invalid(parser.index);
      }
    }
  }
  unexpected_eof(parser.template.length);
}
function read_combinator(parser) {
  const start = parser.index;
  parser.allow_whitespace();
  const index = parser.index;
  const name = parser.read(REGEX_COMBINATOR);
  if (name) {
    const end = parser.index;
    parser.allow_whitespace();
    return {
      type: "Combinator",
      name,
      start: index,
      end
    };
  }
  if (parser.index !== start) {
    return {
      type: "Combinator",
      name: " ",
      start,
      end: parser.index
    };
  }
  return null;
}
function read_block(parser) {
  const start = parser.index;
  parser.eat("{", true);
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match("}")) {
      break;
    } else {
      children.push(read_block_item(parser));
    }
  }
  parser.eat("}", true);
  return {
    type: "Block",
    start,
    end: parser.index,
    children
  };
}
function read_block_item(parser) {
  if (parser.match("@")) {
    return read_at_rule(parser);
  }
  const start = parser.index;
  read_value(parser);
  const char = parser.template[parser.index];
  parser.index = start;
  return char === "{" ? read_rule(parser) : read_declaration(parser);
}
function read_declaration(parser) {
  const start = parser.index;
  const property = parser.read_until(REGEX_WHITESPACE_OR_COLON);
  parser.allow_whitespace();
  parser.eat(":");
  let index = parser.index;
  parser.allow_whitespace();
  const value = read_value(parser);
  if (!value && !property.startsWith("--")) {
    css_empty_declaration({ start, end: index });
  }
  const end = parser.index;
  if (!parser.match("}")) {
    parser.eat(";", true);
  }
  return {
    type: "Declaration",
    start,
    end,
    property,
    value
  };
}
function read_value(parser) {
  let value = "";
  let escaped = false;
  let in_url = false;
  let quote_mark = null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (char === quote_mark) {
      quote_mark = null;
    } else if (char === ")") {
      in_url = false;
    } else if (quote_mark === null && (char === '"' || char === "'")) {
      quote_mark = char;
    } else if (char === "(" && value.slice(-3) === "url") {
      in_url = true;
    } else if ((char === ";" || char === "{" || char === "}") && !in_url && !quote_mark) {
      return value.trim();
    }
    value += char;
    parser.index++;
  }
  unexpected_eof(parser.template.length);
}
function read_attribute_value(parser) {
  let value = "";
  let escaped = false;
  const quote_mark = parser.eat('"') ? '"' : parser.eat("'") ? "'" : null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (quote_mark ? char === quote_mark : REGEX_CLOSING_BRACKET.test(char)) {
      if (quote_mark) {
        parser.eat(quote_mark, true);
      }
      return value.trim();
    } else {
      value += char;
    }
    parser.index++;
  }
  unexpected_eof(parser.template.length);
}
function read_identifier(parser) {
  const start = parser.index;
  let identifier = "";
  if (parser.match_regex(REGEX_LEADING_HYPHEN_OR_DIGIT)) {
    css_expected_identifier(start);
  }
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (char === "\\") {
      const sequence2 = parser.match_regex(REGEX_UNICODE_SEQUENCE);
      if (sequence2) {
        identifier += String.fromCodePoint(parseInt(sequence2.slice(1), 16));
        parser.index += sequence2.length;
      } else {
        identifier += "\\" + parser.template[parser.index + 1];
        parser.index += 2;
      }
    } else if (
      /** @type {number} */
      char.codePointAt(0) >= 160 || REGEX_VALID_IDENTIFIER_CHAR.test(char)
    ) {
      identifier += char;
      parser.index++;
    } else {
      break;
    }
  }
  if (identifier === "") {
    css_expected_identifier(start);
  }
  return identifier;
}
function allow_comment_or_whitespace(parser) {
  parser.allow_whitespace();
  while (parser.match("/*") || parser.match("<!--")) {
    if (parser.eat("/*")) {
      parser.read_until(REGEX_COMMENT_CLOSE);
      parser.eat("*/", true);
    }
    if (parser.eat("<!--")) {
      parser.read_until(REGEX_HTML_COMMENT_CLOSE);
      parser.eat("-->", true);
    }
    parser.allow_whitespace();
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/utils/entities.js
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/utils/html.js
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    /** @param {any} entity_name */
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html.replace(
    entity_pattern,
    /**
     * @param {any} match
     * @param {keyof typeof entities} entity
     */
    (match, entity) => {
      let code;
      if (entity[0] !== "#") {
        code = entities_default[entity];
      } else if (entity[1] === "x") {
        code = parseInt(entity.substring(2), 16);
      } else {
        code = parseInt(entity.substring(1), 10);
      }
      if (!code) {
        return match;
      }
      return String.fromCodePoint(validate_code(code));
    }
  );
}
var NUL = 0;
function validate_code(code) {
  if (code === 10) {
    return 32;
  }
  if (code < 128) {
    return code;
  }
  if (code <= 159) {
    return windows_1252[code - 128];
  }
  if (code < 55296) {
    return code;
  }
  if (code <= 57343) {
    return NUL;
  }
  if (code <= 65535) {
    return code;
  }
  if (code >= 65536 && code <= 131071) {
    return code;
  }
  if (code >= 131072 && code <= 196607) {
    return code;
  }
  if (code >= 917504 && code <= 917631 || code >= 917760 && code <= 917999) {
    return code;
  }
  return NUL;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/utils/create.js
function create_fragment(transparent = false) {
  return {
    type: "Fragment",
    nodes: [],
    metadata: {
      transparent,
      dynamic: false
    }
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/nodes.js
var element_nodes = [
  "SvelteElement",
  "RegularElement",
  "SvelteFragment",
  "Component",
  "SvelteComponent",
  "SvelteSelf",
  "SlotElement"
];
function is_element_node(node) {
  return element_nodes.includes(node.type);
}
function is_component_node(node) {
  return ["Component", "SvelteComponent", "SvelteSelf"].includes(node.type);
}
function is_custom_element_node(node) {
  return node.type === "RegularElement" && (node.name.includes("-") || node.attributes.some((attr) => attr.type === "Attribute" && attr.name === "is"));
}
function create_attribute(name, start, end, value) {
  return {
    type: "Attribute",
    start,
    end,
    name,
    value,
    metadata: {
      delegated: false,
      needs_clsx: false
    }
  };
}
var ExpressionMetadata = class {
  /** True if the expression references state directly, or _might_ (via member/call expressions) */
  has_state = false;
  /** True if the expression involves a call expression (often, it will need to be wrapped in a derived) */
  has_call = false;
  /** True if the expression contains `await` */
  has_await = false;
  /** True if the expression includes a member expression */
  has_member_expression = false;
  /** True if the expression includes an assignment or an update */
  has_assignment = false;
  /**
   * All the bindings that are referenced eagerly (not inside functions) in this expression
   * @type {Set<Binding>}
   */
  dependencies = /* @__PURE__ */ new Set();
  /**
   * True if the expression references state directly, or _might_ (via member/call expressions)
   * @type {Set<Binding>}
   */
  references = /* @__PURE__ */ new Set();
  /** @type {null | Set<Expression>} */
  #blockers = null;
  #get_blockers() {
    if (!this.#blockers) {
      this.#blockers = /* @__PURE__ */ new Set();
      for (const d of this.dependencies) {
        if (d.blocker) this.#blockers.add(d.blocker);
      }
    }
    return this.#blockers;
  }
  blockers() {
    return array([...this.#get_blockers()]);
  }
  has_blockers() {
    return this.#get_blockers().size > 0;
  }
  is_async() {
    return this.has_await || this.#get_blockers().size > 0;
  }
  /**
   * @param {ExpressionMetadata} source
   */
  merge(source2) {
    this.has_state ||= source2.has_state;
    this.has_call ||= source2.has_call;
    this.has_await ||= source2.has_await;
    this.has_member_expression ||= source2.has_member_expression;
    this.has_assignment ||= source2.has_assignment;
    this.#blockers = null;
    for (const r2 of source2.references) this.references.add(r2);
    for (const b of source2.dependencies) this.dependencies.add(b);
  }
};
function get_name(node) {
  if (node.type === "Literal") return String(node.value);
  if (node.type === "PrivateIdentifier") return "#" + node.name;
  if (node.type === "Identifier") return node.name;
  return null;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/html-tree-validation.js
var autoclosing_children = {
  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  li: { direct: ["li"] },
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
  dt: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  dd: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  p: {
    descendant: [
      "address",
      "article",
      "aside",
      "blockquote",
      "div",
      "dl",
      "fieldset",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "table",
      "ul"
    ]
  },
  rt: { descendant: ["rt", "rp"] },
  rp: { descendant: ["rt", "rp"] },
  optgroup: { descendant: ["optgroup"] },
  option: { descendant: ["option", "optgroup"] },
  thead: { direct: ["tbody", "tfoot"] },
  tbody: { direct: ["tbody", "tfoot"] },
  tfoot: { direct: ["tbody"] },
  tr: { direct: ["tr", "tbody"] },
  td: { direct: ["td", "th", "tr"] },
  th: { direct: ["td", "th", "tr"] }
};
function closing_tag_omitted(current2, next2) {
  const disallowed = autoclosing_children[current2];
  if (disallowed) {
    if (!next2 || ("direct" in disallowed ? disallowed.direct : disallowed.descendant).includes(next2)) {
      return true;
    }
  }
  return false;
}
var disallowed_children = {
  ...autoclosing_children,
  optgroup: { only: ["option", "#text"] },
  // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
  option: { only: ["#text"] },
  form: { descendant: ["form"] },
  a: { descendant: ["a"] },
  button: { descendant: ["button"] },
  h1: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h2: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h3: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h4: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h5: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h6: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
  select: { only: ["option", "optgroup", "#text", "hr", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
  // No special behavior since these rules fall back to "in body" mode for
  // all except special table nodes which cause bad parsing behavior anyway.
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  tr: { only: ["th", "td", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
  tbody: { only: ["tr", "style", "script", "template"] },
  thead: { only: ["tr", "style", "script", "template"] },
  tfoot: { only: ["tr", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
  colgroup: { only: ["col", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
  table: {
    only: ["caption", "colgroup", "tbody", "thead", "tfoot", "style", "script", "template"]
  },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
  head: {
    only: [
      "base",
      "basefont",
      "bgsound",
      "link",
      "meta",
      "title",
      "noscript",
      "noframes",
      "style",
      "script",
      "template"
    ]
  },
  // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
  html: { only: ["head", "body", "frameset"] },
  frameset: { only: ["frame"] },
  "#document": { only: ["html"] }
};
function is_tag_valid_with_ancestor(child_tag, ancestors, child_loc, ancestor_loc) {
  if (child_tag.includes("-")) return null;
  const ancestor_tag = ancestors[ancestors.length - 1];
  const disallowed = disallowed_children[ancestor_tag];
  if (!disallowed) return null;
  if ("reset_by" in disallowed && disallowed.reset_by) {
    for (let i = ancestors.length - 2; i >= 0; i--) {
      const ancestor = ancestors[i];
      if (ancestor.includes("-")) return null;
      if (disallowed.reset_by.includes(ancestors[i])) {
        return null;
      }
    }
  }
  if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
    const child = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
    const ancestor = ancestor_loc ? `\`<${ancestor_tag}>\` (${ancestor_loc})` : `\`<${ancestor_tag}>\``;
    return `${child} cannot be a descendant of ${ancestor}`;
  }
  return null;
}
function is_tag_valid_with_parent(child_tag, parent_tag, child_loc, parent_loc) {
  if (child_tag.includes("-") || parent_tag?.includes("-")) return null;
  if (parent_tag === "template") return null;
  const disallowed = disallowed_children[parent_tag];
  const child = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
  const parent = parent_loc ? `\`<${parent_tag}>\` (${parent_loc})` : `\`<${parent_tag}>\``;
  if (disallowed) {
    if ("direct" in disallowed && disallowed.direct.includes(child_tag)) {
      return `${child} cannot be a direct child of ${parent}`;
    }
    if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
      return `${child} cannot be a child of ${parent}`;
    }
    if ("only" in disallowed && disallowed.only) {
      if (disallowed.only.includes(child_tag)) {
        return null;
      } else {
        return `${child} cannot be a child of ${parent}. \`<${parent_tag}>\` only allows these children: ${disallowed.only.map((d) => `\`<${d}>\``).join(", ")}`;
      }
    }
  }
  switch (child_tag) {
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
      return `${child} cannot be a child of ${parent}`;
    case "thead":
    case "tbody":
    case "tfoot":
      return `${child} must be the child of a \`<table>\`, not a ${parent}`;
    case "td":
    case "th":
      return `${child} must be the child of a \`<tr>\`, not a ${parent}`;
    case "tr":
      return `\`<tr>\` must be the child of a \`<thead>\`, \`<tbody>\`, or \`<tfoot>\`, not a ${parent}`;
  }
  return null;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/string.js
function list(strings, conjunction = "or") {
  if (strings.length === 1) return strings[0];
  if (strings.length === 2) return `${strings[0]} ${conjunction} ${strings[1]}`;
  return `${strings.slice(0, -1).join(", ")} ${conjunction} ${strings[strings.length - 1]}`;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/state/element.js
var regex_invalid_unquoted_attribute_value = /^(\/>|[\s"'=<>`])/;
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
var regex_token_ending_character = /[\s=/>"']/;
var regex_starts_with_quote_characters = /^["']/;
var regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
var regex_valid_element_name = /^(?:![a-zA-Z]+|[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])$/;
var regex_valid_component_name = (
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers adjusted for our needs
  // (must start with uppercase letter if no dots, can contain dots)
  /^(?:\p{Lu}[$\u200c\u200d\p{ID_Continue}.]*|\p{ID_Start}[$\u200c\u200d\p{ID_Continue}]*(?:\.[$\u200c\u200d\p{ID_Continue}]+)+)$/u
);
var root_only_meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "SvelteHead"],
  ["svelte:options", "SvelteOptions"],
  ["svelte:window", "SvelteWindow"],
  ["svelte:document", "SvelteDocument"],
  ["svelte:body", "SvelteBody"]
]);
var meta_tags = new Map([
  ...root_only_meta_tags,
  ["svelte:element", "SvelteElement"],
  ["svelte:component", "SvelteComponent"],
  ["svelte:self", "SvelteSelf"],
  ["svelte:fragment", "SvelteFragment"],
  ["svelte:boundary", "SvelteBoundary"]
]);
function element(parser) {
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data2 = parser.read_until(regex_closing_comment);
    parser.eat("-->", true);
    parser.append({
      type: "Comment",
      start,
      end: parser.index,
      data: data2
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (is_closing_tag) {
    parser.allow_whitespace();
    parser.eat(">", true);
    if (is_void(name)) {
      void_element_invalid_content(start);
    }
    while (
      /** @type {AST.RegularElement} */
      parent.name !== name
    ) {
      if (parser.loose) {
        if (is_element_node(parent)) {
          const last = parent.attributes.at(-1);
          if (last?.type === "Attribute" && last.name === `<${name}`) {
            parser.index = last.start;
            parent.attributes.pop();
            break;
          }
        }
      }
      if (parent.type === "RegularElement") {
        if (!parser.last_auto_closed_tag || parser.last_auto_closed_tag.tag !== name) {
          const end = parent.fragment.nodes[0]?.start ?? start;
          element_implicitly_closed(
            { start: parent.start, end },
            `</${name}>`,
            `</${parent.name}>`
          );
        }
      } else if (!parser.loose) {
        if (parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name) {
          element_invalid_closing_tag_autoclosed(start, name, parser.last_auto_closed_tag.reason);
        } else {
          element_invalid_closing_tag(start, name);
        }
      }
      parent.end = start;
      parser.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = void 0;
    }
    return;
  }
  if (name.startsWith("svelte:") && !meta_tags.has(name)) {
    const bounds = { start: start + 1, end: start + 1 + name.length };
    svelte_meta_invalid_tag(bounds, list(Array.from(meta_tags.keys())));
  }
  if (!regex_valid_element_name.test(name) && !regex_valid_component_name.test(name)) {
    if (!parser.loose || !name.endsWith(".")) {
      const bounds = { start: start + 1, end: start + 1 + name.length };
      tag_invalid_name(bounds);
    }
  }
  if (root_only_meta_tags.has(name)) {
    if (name in parser.meta_tags) {
      svelte_meta_duplicate(start, name);
    }
    if (parent.type !== "Root") {
      svelte_meta_invalid_placement(start, name);
    }
    parser.meta_tags[name] = true;
  }
  const type = meta_tags.has(name) ? meta_tags.get(name) : regex_valid_component_name.test(name) || parser.loose && name.endsWith(".") ? "Component" : name === "title" && parent_is_head(parser.stack) ? "TitleElement" : (
    // TODO Svelte 6/7: once slots are removed in favor of snippets, always keep slot as a regular element
    name === "slot" && !parent_is_shadowroot_template(parser.stack) ? "SlotElement" : "RegularElement"
  );
  const element2 = type === "RegularElement" ? {
    type,
    start,
    end: -1,
    name,
    attributes: [],
    fragment: create_fragment(true),
    metadata: {
      svg: false,
      mathml: false,
      scoped: false,
      has_spread: false,
      path: [],
      synthetic_value_node: null
    }
  } : (
    /** @type {AST.ElementLike} */
    {
      type,
      start,
      end: -1,
      name,
      attributes: [],
      fragment: create_fragment(true),
      metadata: {
        // unpopulated at first, differs between types
      }
    }
  );
  parser.allow_whitespace();
  if (parent.type === "RegularElement" && closing_tag_omitted(parent.name, name)) {
    const end = parent.fragment.nodes[0]?.start ?? start;
    element_implicitly_closed({ start: parent.start, end }, `<${name}>`, `</${parent.name}>`);
    parent.end = start;
    parser.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name,
      depth: parser.stack.length
    };
  }
  const unique_names = [];
  const current2 = parser.current();
  const is_top_level_script_or_style = (name === "script" || name === "style") && current2.type === "Root";
  const read = is_top_level_script_or_style ? read_static_attribute : read_attribute;
  let attribute;
  while (attribute = read(parser)) {
    if (attribute.type === "Attribute" || attribute.type === "BindDirective" || attribute.type === "StyleDirective" || attribute.type === "ClassDirective") {
      const type2 = attribute.type === "BindDirective" ? "Attribute" : attribute.type;
      if (unique_names.includes(type2 + attribute.name)) {
        attribute_duplicate(attribute);
      } else if (attribute.name !== "this") {
        unique_names.push(type2 + attribute.name);
      }
    }
    element2.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (element2.type === "Component") {
    element2.metadata.expression = new ExpressionMetadata();
  }
  if (element2.type === "SvelteComponent") {
    const index = element2.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      svelte_component_missing_this(start);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element2.attributes.splice(index, 1)[0]
    );
    if (!is_expression_attribute(definition)) {
      svelte_component_invalid_this(definition.start);
    }
    element2.expression = get_attribute_expression(definition);
    element2.metadata.expression = new ExpressionMetadata();
  }
  if (element2.type === "SvelteElement") {
    const index = element2.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      svelte_element_missing_this(start);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element2.attributes.splice(index, 1)[0]
    );
    if (definition.value === true) {
      svelte_element_missing_this(definition);
    }
    if (!is_expression_attribute(definition)) {
      svelte_element_invalid_this(definition);
      const chunk = (
        /** @type {Array<AST.ExpressionTag | AST.Text>} */
        definition.value[0]
      );
      element2.tag = chunk.type === "Text" ? {
        type: "Literal",
        value: chunk.data,
        raw: `'${chunk.raw}'`,
        start: chunk.start,
        end: chunk.end
      } : chunk.expression;
    } else {
      element2.tag = get_attribute_expression(definition);
    }
    element2.metadata.expression = new ExpressionMetadata();
  }
  if (is_top_level_script_or_style) {
    parser.eat(">", true);
    let prev_comment = null;
    for (let i = current2.fragment.nodes.length - 1; i >= 0; i--) {
      const node = current2.fragment.nodes[i];
      if (i === current2.fragment.nodes.length - 1 && node.end !== start) {
        break;
      }
      if (node.type === "Comment") {
        prev_comment = node;
        break;
      } else if (node.type !== "Text" || node.data.trim()) {
        break;
      }
    }
    if (name === "script") {
      const content = read_script(parser, start, element2.attributes);
      if (prev_comment) {
        content.content.leadingComments = [{ type: "Line", value: prev_comment.data }];
      }
      if (content.context === "module") {
        if (current2.module) script_duplicate(start);
        current2.module = content;
      } else {
        if (current2.instance) script_duplicate(start);
        current2.instance = content;
      }
    } else {
      const content = read_style(parser, start, element2.attributes);
      content.content.comment = prev_comment;
      if (current2.css) style_duplicate(start);
      current2.css = content;
    }
    return;
  }
  parser.append(element2);
  const self_closing = parser.eat("/") || is_void(name);
  const closed = parser.eat(">", true, false);
  if (!closed) {
    const last = element2.attributes.at(-1);
    if (last?.type === "Attribute" && last.name === "<") {
      parser.index = last.start;
      element2.attributes.pop();
    } else {
      const prev_1 = parser.template[parser.index - 1];
      const prev_2 = parser.template[parser.index - 2];
      const current3 = parser.template[parser.index];
      if (prev_2 === "{" && prev_1 === "/") {
        parser.index -= 2;
      } else if (prev_1 === "{" && (current3 === "#" || current3 === "@" || current3 === ":")) {
        parser.index -= 1;
      } else {
        parser.allow_whitespace();
      }
    }
  }
  if (self_closing || !closed) {
    element2.end = parser.index;
  } else if (name === "textarea") {
    element2.fragment.nodes = read_sequence(
      parser,
      () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
      "inside <textarea>"
    );
    parser.read(regex_closing_textarea_tag);
    element2.end = parser.index;
  } else if (name === "script" || name === "style") {
    const start2 = parser.index;
    const data2 = parser.read_until(new RegExp(`</${name}>`));
    const end = parser.index;
    const node = {
      start: start2,
      end,
      type: "Text",
      data: data2,
      raw: data2
    };
    element2.fragment.nodes.push(node);
    parser.eat(`</${name}>`, true);
    element2.end = parser.index;
  } else {
    parser.stack.push(element2);
    parser.fragments.push(element2.fragment);
  }
}
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "SvelteHead") return true;
    if (type === "RegularElement" || type === "Component") return false;
  }
  return false;
}
function parent_is_shadowroot_template(stack) {
  let i = stack.length;
  while (i--) {
    if (stack[i].type === "RegularElement" && /** @type {AST.RegularElement} */
    stack[i].attributes.some(
      (a) => a.type === "Attribute" && a.name === "shadowrootmode"
    )) {
      return true;
    }
  }
  return false;
}
function read_static_attribute(parser) {
  const start = parser.index;
  const name = parser.read_until(regex_token_ending_character);
  if (!name) return null;
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    let raw = parser.match_regex(regex_attribute_value);
    if (!raw) {
      expected_attribute_value(parser.index);
    }
    parser.index += raw.length;
    const quoted = raw[0] === '"' || raw[0] === "'";
    if (quoted) {
      raw = raw.slice(1, -1);
    }
    value = [
      {
        start: parser.index - raw.length - (quoted ? 1 : 0),
        end: quoted ? parser.index - 1 : parser.index,
        type: "Text",
        raw,
        data: decode_character_references(raw, true)
      }
    ];
  }
  if (parser.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser.index, "=");
  }
  return create_attribute(name, start, parser.index, value);
}
function read_attribute(parser) {
  const start = parser.index;
  if (parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("@attach")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const attachment = {
        type: "AttachTag",
        start,
        end: parser.index,
        expression,
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
      return attachment;
    }
    if (parser.eat("...")) {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const spread2 = {
        type: "SpreadAttribute",
        start,
        end: parser.index,
        expression,
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
      return spread2;
    } else {
      const value_start = parser.index;
      let name2 = parser.read_identifier();
      if (name2 === null) {
        if (parser.loose && (parser.match("#") || parser.match("/") || parser.match("@") || parser.match(":"))) {
          return null;
        } else if (parser.loose && parser.match("}")) {
          name2 = "";
        } else {
          attribute_empty_shorthand(start);
        }
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      const expression = {
        type: "ExpressionTag",
        start: value_start,
        end: value_start + name2.length,
        expression: {
          start: value_start,
          end: value_start + name2.length,
          type: "Identifier",
          name: name2
        },
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
      return create_attribute(name2, start, parser.index, expression);
    }
  }
  const name = parser.read_until(regex_token_ending_character);
  if (!name) return null;
  let end = parser.index;
  parser.allow_whitespace();
  const colon_index = name.indexOf(":");
  const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    if (parser.template[parser.index] === "/" && parser.template[parser.index + 1] === ">") {
      const char_start = parser.index;
      parser.index++;
      value = [
        {
          start: char_start,
          end: char_start + 1,
          type: "Text",
          raw: "/",
          data: "/"
        }
      ];
      end = parser.index;
    } else {
      value = read_attribute_value2(parser);
      end = parser.index;
    }
  } else if (parser.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser.index, "=");
  }
  if (type) {
    const [directive_name, ...modifiers2] = name.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      directive_missing_name({ start, end: start + colon_index + 1 }, name);
    }
    if (type === "StyleDirective") {
      return {
        start,
        end,
        type,
        name: directive_name,
        modifiers: (
          /** @type {Array<'important'>} */
          modifiers2
        ),
        value,
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
    }
    const first_value = value === true ? void 0 : Array.isArray(value) ? value[0] : value;
    let expression = null;
    if (first_value) {
      const attribute_contains_text = (
        /** @type {any[]} */
        value.length > 1 || first_value.type === "Text"
      );
      if (attribute_contains_text) {
        directive_invalid_value(
          /** @type {number} */
          first_value.start
        );
      } else {
        expression = first_value.expression;
      }
    }
    const directive = (
      /** @type {AST.Directive} */
      {
        start,
        end,
        type,
        name: directive_name,
        expression,
        metadata: {
          expression: new ExpressionMetadata()
        }
      }
    );
    directive.modifiers = modifiers2;
    if (directive.type === "TransitionDirective") {
      const direction = name.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if ((directive.type === "BindDirective" || directive.type === "ClassDirective") && !directive.expression) {
      directive.expression = /** @type {any} */
      {
        start: start + colon_index + 1,
        end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  return create_attribute(name, start, end, value);
}
function get_directive_type(name) {
  if (name === "use") return "UseDirective";
  if (name === "animate") return "AnimateDirective";
  if (name === "bind") return "BindDirective";
  if (name === "class") return "ClassDirective";
  if (name === "style") return "StyleDirective";
  if (name === "on") return "OnDirective";
  if (name === "let") return "LetDirective";
  if (name === "in" || name === "out" || name === "transition") return "TransitionDirective";
  return false;
}
function read_attribute_value2(parser) {
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  if (quote_mark && parser.eat(quote_mark)) {
    return [
      {
        start: parser.index - 1,
        end: parser.index - 1,
        type: "Text",
        raw: "",
        data: ""
      }
    ];
  }
  let value;
  try {
    value = read_sequence(
      parser,
      () => {
        if (quote_mark) return parser.match(quote_mark);
        return !!parser.match_regex(regex_invalid_unquoted_attribute_value);
      },
      "in attribute value"
    );
  } catch (error) {
    if (error.code === "js_parse_error") {
      const pos = error.position?.[0];
      if (pos !== void 0 && parser.template.slice(pos - 1, pos + 1) === "/>") {
        parser.index = pos;
        expected_token(pos, quote_mark || "}");
      }
    }
    throw error;
  }
  if (value.length === 0 && !quote_mark) {
    expected_attribute_value(parser.index);
  }
  if (quote_mark) parser.index += 1;
  if (quote_mark || value.length > 1 || value[0].type === "Text") {
    return value;
  } else {
    return value[0];
  }
}
function read_sequence(parser, done, location2) {
  let current_chunk = {
    start: parser.index,
    end: -1,
    type: "Text",
    raw: "",
    data: ""
  };
  const chunks = [];
  function flush(end) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end;
      chunks.push(current_chunk);
    }
  }
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush(parser.index);
      return chunks;
    } else if (parser.eat("{")) {
      if (parser.match("#")) {
        const index2 = parser.index - 1;
        parser.eat("#");
        const name = parser.read_until(/[^a-z]/);
        block_invalid_placement(index2, name, location2);
      } else if (parser.match("@")) {
        const index2 = parser.index - 1;
        parser.eat("@");
        const name = parser.read_until(/[^a-z]/);
        tag_invalid_placement(index2, name, location2);
      }
      flush(parser.index - 1);
      parser.allow_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const chunk = {
        type: "ExpressionTag",
        start: index,
        end: parser.index,
        expression,
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
      chunks.push(chunk);
      current_chunk = {
        start: parser.index,
        end: -1,
        type: "Text",
        raw: "",
        data: ""
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  if (parser.loose) {
    return chunks;
  } else {
    unexpected_eof(parser.template.length);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/read/context.js
function read_pattern(parser) {
  const start = parser.index;
  let i = parser.index;
  const name = parser.read_identifier();
  if (name !== null) {
    const annotation = read_type_annotation(parser);
    return {
      type: "Identifier",
      name,
      start,
      loc: {
        start: (
          /** @type {Location} */
          locator(start)
        ),
        end: (
          /** @type {Location} */
          locator(parser.index)
        )
      },
      end: parser.index,
      typeAnnotation: annotation
    };
  }
  const char = parser.template[i];
  if (char !== "{" && char !== "[") {
    expected_pattern(i);
  }
  i = match_bracket(parser, start);
  parser.index = i;
  const pattern_string = parser.template.slice(start, i);
  try {
    let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    const expression = (
      /** @type {any} */
      parse_expression_at(
        `${space_with_newline}(${pattern_string} = 1)`,
        parser.root.comments,
        parser.ts,
        start - 1
      ).left
    );
    expression.typeAnnotation = read_type_annotation(parser);
    if (expression.typeAnnotation) {
      expression.end = expression.typeAnnotation.end;
    }
    return expression;
  } catch (error) {
    parser.acorn_error(error);
  }
}
function read_type_annotation(parser) {
  const start = parser.index;
  parser.allow_whitespace();
  if (!parser.eat(":")) {
    parser.index = start;
    return void 0;
  }
  const insert2 = "_ as ";
  let a = parser.index - insert2.length;
  const template2 = parser.template.slice(0, a).replace(/[^\n]/g, " ") + insert2 + // If this is a type annotation for a function parameter, Acorn-TS will treat subsequent
  // parameters as part of a sequence expression instead, and will then error on optional
  // parameters (`?:`). Therefore replace that sequence with something that will not error.
  parser.template.slice(parser.index).replace(/\?\s*:/g, ":");
  let expression = parse_expression_at(template2, parser.root.comments, parser.ts, a);
  if (expression.type === "AssignmentExpression") {
    let b = expression.right.start;
    while (template2[b] !== "=") b -= 1;
    expression = parse_expression_at(template2.slice(0, b), parser.root.comments, parser.ts, a);
  }
  if (expression.type === "SequenceExpression") {
    expression = expression.expressions[0];
  }
  parser.index = /** @type {number} */
  expression.end;
  return {
    type: "TSTypeAnnotation",
    start,
    end: parser.index,
    typeAnnotation: (
      /** @type {any} */
      expression.typeAnnotation
    )
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/state/tag.js
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
var pointy_bois = { "<": ">" };
function tag(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("#")) return open(parser);
  if (parser.eat(":")) return next(parser);
  if (parser.eat("@")) return special(parser);
  if (parser.match("/")) {
    if (!parser.match("/*") && !parser.match("//")) {
      parser.eat("/");
      return close(parser);
    }
  }
  const expression = read_expression(parser);
  parser.allow_whitespace();
  parser.eat("}", true);
  parser.append({
    type: "ExpressionTag",
    start,
    end: parser.index,
    expression,
    metadata: {
      expression: new ExpressionMetadata()
    }
  });
}
function open(parser) {
  let start = parser.index - 2;
  while (parser.template[start] !== "{") start -= 1;
  if (parser.eat("if")) {
    parser.require_whitespace();
    const block2 = parser.append({
      type: "IfBlock",
      elseif: false,
      start,
      end: -1,
      test: read_expression(parser),
      consequent: create_fragment(),
      alternate: null,
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.stack.push(block2);
    parser.fragments.push(block2.consequent);
    return;
  }
  if (parser.eat("each")) {
    parser.require_whitespace();
    const template2 = parser.template;
    let end = parser.template.length;
    let expression;
    while (!expression) {
      try {
        expression = read_expression(parser, void 0, true);
      } catch (err2) {
        end = /** @type {any} */
        err2.position[0] - 2;
        while (end > start && parser.template.slice(end, end + 2) !== "as") {
          end -= 1;
        }
        if (end <= start) {
          if (parser.loose) {
            expression = get_loose_identifier(parser);
            if (expression) {
              break;
            }
          }
          throw err2;
        }
        parser.template = template2.slice(0, end);
      }
    }
    parser.template = template2;
    parser.allow_whitespace();
    if (!parser.match("as")) {
      if (expression.type === "SequenceExpression") {
        expression = expression.expressions[0];
      }
      let assertion = null;
      let end2 = expression.end;
      expression = walk(expression, null, {
        // @ts-expect-error
        TSAsExpression(node, context2) {
          if (node.end === /** @type {Expression} */
          expression.end) {
            assertion = node;
            end2 = node.expression.end;
            return node.expression;
          }
          context2.next();
        }
      });
      expression.end = end2;
      if (assertion) {
        let end3 = (
          /** @type {any} */
          /** @type {any} */
          assertion.typeAnnotation.start - 2
        );
        while (parser.template.slice(end3, end3 + 2) !== "as") end3 -= 1;
        parser.index = end3;
      }
    }
    let context = null;
    let index;
    let key2;
    if (parser.eat("as")) {
      parser.require_whitespace();
      context = read_pattern(parser);
    } else {
      parser.index = /** @type {number} */
      expression.end;
    }
    parser.allow_whitespace();
    if (parser.eat(",")) {
      parser.allow_whitespace();
      index = parser.read_identifier();
      if (!index) {
        expected_identifier(parser.index);
      }
      parser.allow_whitespace();
    }
    if (parser.eat("(")) {
      parser.allow_whitespace();
      key2 = read_expression(parser, "(");
      parser.allow_whitespace();
      parser.eat(")", true);
      parser.allow_whitespace();
    }
    const matches = parser.eat("}", true, false);
    if (!matches) {
      if (parser.template.slice(parser.index - 4, parser.index) === " as ") {
        const prev_index = parser.index;
        context = read_pattern(parser);
        parser.eat("}", true);
        expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 4
        };
      } else {
        parser.eat("}", true);
      }
    }
    const block2 = parser.append({
      type: "EachBlock",
      start,
      end: -1,
      expression,
      body: create_fragment(),
      context,
      index,
      key: key2,
      metadata: (
        /** @type {any} */
        null
      )
      // filled in later
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  if (parser.eat("await")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    const block2 = parser.append({
      type: "AwaitBlock",
      start,
      end: -1,
      expression,
      value: null,
      error: null,
      pending: null,
      then: null,
      catch: null,
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
    if (parser.eat("then")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.value = read_pattern(parser);
        parser.allow_whitespace();
      }
      block2.then = create_fragment();
      parser.fragments.push(block2.then);
    } else if (parser.eat("catch")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.error = read_pattern(parser);
        parser.allow_whitespace();
      }
      block2.catch = create_fragment();
      parser.fragments.push(block2.catch);
    } else {
      block2.pending = create_fragment();
      parser.fragments.push(block2.pending);
    }
    const matches = parser.eat("}", true, false);
    if (!matches) {
      if (parser.template.slice(parser.index - 6, parser.index) === " then ") {
        const prev_index = parser.index;
        block2.value = read_pattern(parser);
        parser.eat("}", true);
        block2.expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 6
        };
        block2.then = block2.pending;
        block2.pending = null;
      } else if (parser.template.slice(parser.index - 7, parser.index) === " catch ") {
        const prev_index = parser.index;
        block2.error = read_pattern(parser);
        parser.eat("}", true);
        block2.expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 7
        };
        block2.catch = block2.pending;
        block2.pending = null;
      } else {
        parser.eat("}", true);
      }
    }
    parser.stack.push(block2);
    return;
  }
  if (parser.eat("key")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "KeyBlock",
      start,
      end: -1,
      expression,
      fragment: create_fragment(),
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.fragment);
    return;
  }
  if (parser.eat("snippet")) {
    parser.require_whitespace();
    const name_start = parser.index;
    let name = parser.read_identifier();
    const name_end = parser.index;
    if (name === null) {
      if (parser.loose) {
        name = "";
      } else {
        expected_identifier(parser.index);
      }
    }
    parser.allow_whitespace();
    const params_start = parser.index;
    let type_params;
    if (parser.ts && parser.match("<")) {
      const start2 = parser.index;
      const end = match_bracket(parser, start2, pointy_bois);
      type_params = parser.template.slice(start2 + 1, end - 1);
      parser.index = end;
    }
    parser.allow_whitespace();
    const matched = parser.eat("(", true, false);
    if (matched) {
      let parentheses = 1;
      while (parser.index < parser.template.length && (!parser.match(")") || parentheses !== 1)) {
        if (parser.match("(")) parentheses++;
        if (parser.match(")")) parentheses--;
        parser.index += 1;
      }
      parser.eat(")", true);
    }
    const prelude = parser.template.slice(0, params_start).replace(/\S/g, " ");
    const params = parser.template.slice(params_start, parser.index);
    let function_expression = matched ? (
      /** @type {ArrowFunctionExpression} */
      parse_expression_at(
        prelude + `${params} => {}`,
        parser.root.comments,
        parser.ts,
        params_start
      )
    ) : { params: [] };
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "SnippetBlock",
      start,
      end: -1,
      expression: {
        type: "Identifier",
        start: name_start,
        end: name_end,
        name
      },
      typeParams: type_params,
      parameters: function_expression.params,
      body: create_fragment(),
      metadata: {
        can_hoist: false,
        sites: /* @__PURE__ */ new Set()
      }
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  expected_block_type(parser.index);
}
function next(parser) {
  const start = parser.index - 1;
  const block2 = parser.current();
  if (block2.type === "IfBlock") {
    if (!parser.eat("else")) expected_token(start, "{:else} or {:else if}");
    if (parser.eat("if")) block_invalid_elseif(start);
    parser.allow_whitespace();
    parser.fragments.pop();
    block2.alternate = create_fragment();
    parser.fragments.push(block2.alternate);
    if (parser.eat("if")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      let elseif_start = start - 1;
      while (parser.template[elseif_start] !== "{") elseif_start -= 1;
      const child = parser.append({
        start: elseif_start,
        end: -1,
        type: "IfBlock",
        elseif: true,
        test: expression,
        consequent: create_fragment(),
        alternate: null,
        metadata: {
          expression: new ExpressionMetadata()
        }
      });
      parser.stack.push(child);
      parser.fragments.pop();
      parser.fragments.push(child.consequent);
    } else {
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    return;
  }
  if (block2.type === "EachBlock") {
    if (!parser.eat("else")) expected_token(start, "{:else}");
    parser.allow_whitespace();
    parser.eat("}", true);
    block2.fallback = create_fragment();
    parser.fragments.pop();
    parser.fragments.push(block2.fallback);
    return;
  }
  if (block2.type === "AwaitBlock") {
    if (parser.eat("then")) {
      if (block2.then) {
        block_duplicate_clause(start, "{:then}");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.value = read_pattern(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.then = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.then);
      return;
    }
    if (parser.eat("catch")) {
      if (block2.catch) {
        block_duplicate_clause(start, "{:catch}");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.error = read_pattern(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.catch = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.catch);
      return;
    }
    expected_token(start, "{:then ...} or {:catch ...}");
  }
  block_invalid_continuation_placement(start);
}
function close(parser) {
  const start = parser.index - 1;
  let block2 = parser.current();
  let matched;
  switch (block2.type) {
    case "IfBlock":
      matched = parser.eat("if", true, false);
      if (!matched) {
        block2.end = start - 1;
        parser.pop();
        close(parser);
        return;
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      while (block2.elseif) {
        block2.end = parser.index;
        parser.stack.pop();
        block2 = /** @type {AST.IfBlock} */
        parser.current();
      }
      block2.end = parser.index;
      parser.pop();
      return;
    case "EachBlock":
      matched = parser.eat("each", true, false);
      break;
    case "KeyBlock":
      matched = parser.eat("key", true, false);
      break;
    case "AwaitBlock":
      matched = parser.eat("await", true, false);
      break;
    case "SnippetBlock":
      matched = parser.eat("snippet", true, false);
      break;
    case "RegularElement":
      if (parser.loose) {
        matched = false;
      } else {
        block_unexpected_close(start);
      }
      break;
    default:
      block_unexpected_close(start);
  }
  if (!matched) {
    block2.end = start - 1;
    parser.pop();
    close(parser);
    return;
  }
  parser.allow_whitespace();
  parser.eat("}", true);
  block2.end = parser.index;
  parser.pop();
}
function special(parser) {
  let start = parser.index;
  while (parser.template[start] !== "{") start -= 1;
  if (parser.eat("html")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "HtmlTag",
      start,
      end: parser.index,
      expression,
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
    return;
  }
  if (parser.eat("debug")) {
    let identifiers;
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      identifiers = expression.type === "SequenceExpression" ? (
        /** @type {Identifier[]} */
        expression.expressions
      ) : [
        /** @type {Identifier} */
        expression
      ];
      identifiers.forEach(
        /** @param {any} node */
        (node) => {
          if (node.type !== "Identifier") {
            debug_tag_invalid_arguments(
              /** @type {number} */
              node.start
            );
          }
        }
      );
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    parser.append({
      type: "DebugTag",
      start,
      end: parser.index,
      identifiers
    });
    return;
  }
  if (parser.eat("const")) {
    parser.require_whitespace();
    const id2 = read_pattern(parser);
    parser.allow_whitespace();
    parser.eat("=", true);
    parser.allow_whitespace();
    const expression_start = parser.index;
    const init3 = read_expression(parser);
    if (init3.type === "SequenceExpression" && !parser.template.substring(expression_start, init3.start).includes("(")) {
      const_tag_invalid_expression(init3);
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "ConstTag",
      start,
      end: parser.index,
      declaration: {
        type: "VariableDeclaration",
        kind: "const",
        declarations: [{ type: "VariableDeclarator", id: id2, init: init3, start: id2.start, end: init3.end }],
        start: start + 2,
        // start at const, not at @const
        end: parser.index - 1
      },
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
  }
  if (parser.eat("render")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    if (expression.type !== "CallExpression" && (expression.type !== "ChainExpression" || expression.expression.type !== "CallExpression")) {
      render_tag_invalid_expression(expression);
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "RenderTag",
      start,
      end: parser.index,
      expression: (
        /** @type {AST.RenderTag['expression']} */
        expression
      ),
      metadata: {
        expression: new ExpressionMetadata(),
        dynamic: false,
        arguments: [],
        path: [],
        snippets: /* @__PURE__ */ new Set()
      }
    });
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/state/text.js
function text(parser) {
  const start = parser.index;
  let data2 = "";
  while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{")) {
    data2 += parser.template[parser.index++];
  }
  parser.append({
    type: "Text",
    start,
    end: parser.index,
    raw: data2,
    data: decode_character_references(data2, false)
  });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/state/fragment.js
function fragment(parser) {
  if (parser.match("<")) {
    return element;
  }
  if (parser.match("{")) {
    return tag;
  }
  return text;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/read/options.js
function read_options(node) {
  const component_options2 = {
    start: node.start,
    end: node.end,
    // @ts-ignore
    attributes: node.attributes
  };
  if (!node) {
    return component_options2;
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      svelte_options_invalid_attribute(attribute);
    }
    const { name } = attribute;
    switch (name) {
      case "runes": {
        component_options2.runes = get_boolean_value(attribute);
        break;
      }
      case "tag": {
        svelte_options_deprecated_tag(attribute);
        break;
      }
      case "customElement": {
        const ce = {};
        const { value: v } = attribute;
        const value = v === true || Array.isArray(v) ? v : [v];
        if (value === true) {
          svelte_options_invalid_customelement(attribute);
        } else if (value[0].type === "Text") {
          const tag3 = get_static_value(attribute);
          validate_tag(attribute, tag3);
          ce.tag = tag3;
          component_options2.customElement = ce;
          break;
        } else if (value[0].expression.type !== "ObjectExpression") {
          if (value[0].expression.type === "Literal" && value[0].expression.value === null) {
            break;
          }
          svelte_options_invalid_customelement(attribute);
        }
        const properties = [];
        for (const property of value[0].expression.properties) {
          if (property.type !== "Property" || property.computed || property.key.type !== "Identifier") {
            svelte_options_invalid_customelement(attribute);
          }
          properties.push([property.key.name, property.value]);
        }
        const tag2 = properties.find(([name2]) => name2 === "tag");
        if (tag2) {
          const tag_value = tag2[1]?.value;
          validate_tag(tag2, tag_value);
          ce.tag = tag_value;
        }
        const props = properties.find(([name2]) => name2 === "props")?.[1];
        if (props) {
          if (props.type !== "ObjectExpression") {
            svelte_options_invalid_customelement_props(attribute);
          }
          ce.props = {};
          for (
            const property of
            /** @type {ObjectExpression} */
            props.properties
          ) {
            if (property.type !== "Property" || property.computed || property.key.type !== "Identifier" || property.value.type !== "ObjectExpression") {
              svelte_options_invalid_customelement_props(attribute);
            }
            ce.props[property.key.name] = {};
            for (const prop2 of property.value.properties) {
              if (prop2.type !== "Property" || prop2.computed || prop2.key.type !== "Identifier" || prop2.value.type !== "Literal") {
                svelte_options_invalid_customelement_props(attribute);
              }
              if (prop2.key.name === "type") {
                if (["String", "Number", "Boolean", "Array", "Object"].indexOf(
                  /** @type {string} */
                  prop2.value.value
                ) === -1) {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].type = /** @type {any} */
                prop2.value.value;
              } else if (prop2.key.name === "reflect") {
                if (typeof prop2.value.value !== "boolean") {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].reflect = prop2.value.value;
              } else if (prop2.key.name === "attribute") {
                if (typeof prop2.value.value !== "string") {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].attribute = prop2.value.value;
              } else {
                svelte_options_invalid_customelement_props(attribute);
              }
            }
          }
        }
        const shadow = properties.find(([name2]) => name2 === "shadow")?.[1];
        if (shadow) {
          const shadowdom = shadow?.value;
          if (shadowdom !== "open" && shadowdom !== "none") {
            svelte_options_invalid_customelement_shadow(shadow);
          }
          ce.shadow = shadowdom;
        }
        const extend2 = properties.find(([name2]) => name2 === "extend")?.[1];
        if (extend2) {
          ce.extend = extend2;
        }
        component_options2.customElement = ce;
        break;
      }
      case "namespace": {
        const value = get_static_value(attribute);
        if (value === NAMESPACE_SVG) {
          component_options2.namespace = "svg";
        } else if (value === NAMESPACE_MATHML) {
          component_options2.namespace = "mathml";
        } else if (value === "html" || value === "mathml" || value === "svg") {
          component_options2.namespace = value;
        } else {
          svelte_options_invalid_attribute_value(attribute, `"html", "mathml" or "svg"`);
        }
        break;
      }
      case "css": {
        const value = get_static_value(attribute);
        if (value === "injected") {
          component_options2.css = value;
        } else {
          svelte_options_invalid_attribute_value(attribute, `"injected"`);
        }
        break;
      }
      case "immutable": {
        component_options2.immutable = get_boolean_value(attribute);
        break;
      }
      case "preserveWhitespace": {
        component_options2.preserveWhitespace = get_boolean_value(attribute);
        break;
      }
      case "accessors": {
        component_options2.accessors = get_boolean_value(attribute);
        break;
      }
      default:
        svelte_options_unknown_attribute(attribute, name);
    }
  }
  return component_options2;
}
function get_static_value(attribute) {
  const { value } = attribute;
  if (value === true) return true;
  const chunk = Array.isArray(value) ? value[0] : value;
  if (!chunk) return true;
  if (value.length > 1) {
    return null;
  }
  if (chunk.type === "Text") return chunk.data;
  if (chunk.expression.type !== "Literal") {
    return null;
  }
  return chunk.expression.value;
}
function get_boolean_value(attribute) {
  const value = get_static_value(attribute);
  if (typeof value !== "boolean") {
    svelte_options_invalid_attribute_value(attribute, "true or false");
  }
  return value;
}
var tag_name_char = "[a-z0-9_.\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u{10000}-\u{EFFFF}-]";
var regex_valid_tag_name = new RegExp(`^[a-z]${tag_name_char}*-${tag_name_char}*$`, "u");
var reserved_tag_names = [
  "annotation-xml",
  "color-profile",
  "font-face",
  "font-face-src",
  "font-face-uri",
  "font-face-format",
  "font-face-name",
  "missing-glyph"
];
function validate_tag(attribute, tag2) {
  if (typeof tag2 !== "string") {
    svelte_options_invalid_tagname(attribute);
  }
  if (tag2) {
    if (!regex_valid_tag_name.test(tag2)) {
      svelte_options_invalid_tagname(attribute);
    } else if (reserved_tag_names.includes(tag2)) {
      svelte_options_reserved_tagname(attribute);
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/special-element.js
function disallow_children(node) {
  const { nodes } = node.fragment;
  if (nodes.length > 0) {
    const first = nodes[0];
    const last = nodes[nodes.length - 1];
    svelte_meta_invalid_content({ start: first.start, end: last.end }, node.name);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/index.js
var regex_position_indicator = / \(\d+:\d+\)$/;
var regex_lang_attribute = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;
var Parser3 = class {
  /**
   * @readonly
   * @type {string}
   */
  template;
  /**
   * Whether or not we're in loose parsing mode, in which
   * case we try to continue parsing as much as possible
   * @type {boolean}
   */
  loose;
  /** */
  index = 0;
  /** Whether we're parsing in TypeScript mode */
  ts = false;
  /** @type {AST.TemplateNode[]} */
  stack = [];
  /** @type {AST.Fragment[]} */
  fragments = [];
  /** @type {AST.Root} */
  root;
  /** @type {Record<string, boolean>} */
  meta_tags = {};
  /** @type {LastAutoClosedTag | undefined} */
  last_auto_closed_tag;
  /**
   * @param {string} template
   * @param {boolean} loose
   */
  constructor(template2, loose) {
    if (typeof template2 !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.loose = loose;
    this.template = template2.trimEnd();
    let match_lang;
    do
      match_lang = regex_lang_attribute.exec(template2);
    while (match_lang && match_lang[0][1] !== "s");
    regex_lang_attribute.lastIndex = 0;
    this.ts = match_lang?.[2] === "ts";
    this.root = {
      css: null,
      js: [],
      // @ts-ignore
      start: null,
      // @ts-ignore
      end: null,
      type: "Root",
      fragment: create_fragment(),
      options: null,
      comments: [],
      metadata: {
        ts: this.ts
      }
    };
    this.stack.push(this.root);
    this.fragments.push(this.root.fragment);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current2 = this.current();
      if (this.loose) {
        current2.end = this.template.length;
      } else if (current2.type === "RegularElement") {
        current2.end = current2.start + 1;
        element_unclosed(current2, current2.name);
      } else {
        current2.end = current2.start + 1;
        block_unclosed(current2);
      }
    }
    if (state !== fragment) {
      unexpected_eof(this.index);
    }
    if (this.root.fragment.nodes.length) {
      let start = (
        /** @type {number} */
        this.root.fragment.nodes[0].start
      );
      while (regex_whitespace.test(template2[start])) start += 1;
      let end = (
        /** @type {number} */
        this.root.fragment.nodes[this.root.fragment.nodes.length - 1].end
      );
      while (regex_whitespace.test(template2[end - 1])) end -= 1;
      this.root.start = start;
      this.root.end = end;
    } else {
      this.root.start = this.root.end = null;
    }
    const options_index = this.root.fragment.nodes.findIndex(
      /** @param {any} thing */
      (thing) => thing.type === "SvelteOptions"
    );
    if (options_index !== -1) {
      const options = (
        /** @type {AST.SvelteOptionsRaw} */
        this.root.fragment.nodes[options_index]
      );
      this.root.fragment.nodes.splice(options_index, 1);
      this.root.options = read_options(options);
      disallow_children(options);
      Object.defineProperty(this.root.options, "__raw__", {
        value: options,
        enumerable: false
      });
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  /**
   * @param {any} err
   * @returns {never}
   */
  acorn_error(err2) {
    js_parse_error(err2.pos, err2.message.replace(regex_position_indicator, ""));
  }
  /**
   * @param {string} str
   * @param {boolean} required
   * @param {boolean} required_in_loose
   */
  eat(str2, required = false, required_in_loose = true) {
    if (this.match(str2)) {
      this.index += str2.length;
      return true;
    }
    if (required && (!this.loose || required_in_loose)) {
      expected_token(this.index, str2);
    }
    return false;
  }
  /** @param {string} str */
  match(str2) {
    const length = str2.length;
    if (length === 1) {
      return this.template[this.index] === str2;
    }
    return this.template.slice(this.index, this.index + length) === str2;
  }
  /**
   * Match a regex at the current index
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0) return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result) this.index += result.length;
    return result;
  }
  /** @param {any} allow_reserved */
  read_identifier(allow_reserved = false) {
    const start = this.index;
    let i = this.index;
    const code = (
      /** @type {number} */
      this.template.codePointAt(i)
    );
    if (!isIdentifierStart(code, true)) return null;
    i += code <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code2 = (
        /** @type {number} */
        this.template.codePointAt(i)
      );
      if (!isIdentifierChar(code2, true)) break;
      i += code2 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && is_reserved(identifier)) {
      unexpected_reserved_word(start, identifier);
    }
    return identifier;
  }
  /** @param {RegExp} pattern */
  read_until(pattern) {
    if (this.index >= this.template.length) {
      if (this.loose) return "";
      unexpected_eof(this.template.length);
    }
    const start = this.index;
    const match = pattern.exec(this.template.slice(start));
    if (match) {
      this.index = start + match.index;
      return this.template.slice(start, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      expected_whitespace(this.index);
    }
    this.allow_whitespace();
  }
  pop() {
    this.fragments.pop();
    return this.stack.pop();
  }
  /**
   * @template {AST.Fragment['nodes'][number]} T
   * @param {T} node
   * @returns {T}
   */
  append(node) {
    this.fragments.at(-1)?.nodes.push(node);
    return node;
  }
};
function parse5(template2, loose = false) {
  set_source(template2);
  const parser = new Parser3(template2, loose);
  return parser.root;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/1-parse/remove_typescript_nodes.js
function remove_this_param(node, context) {
  if (node.params[0]?.type === "Identifier" && node.params[0].name === "this") {
    node.params.shift();
  }
  return context.next();
}
var visitors = {
  _(node, context) {
    const n2 = context.next() ?? node;
    delete n2.typeAnnotation;
    delete n2.typeParameters;
    delete n2.typeArguments;
    delete n2.returnType;
    delete n2.accessibility;
  },
  Decorator(node) {
    typescript_invalid_feature(node, "decorators (related TSC proposal is not stage 4 yet)");
  },
  ImportDeclaration(node) {
    if (node.importKind === "type") return empty2;
    if (node.specifiers?.length > 0) {
      const specifiers = node.specifiers.filter((s) => s.importKind !== "type");
      if (specifiers.length === 0) return empty2;
      return { ...node, specifiers };
    }
    return node;
  },
  ExportNamedDeclaration(node, context) {
    if (node.exportKind === "type") return empty2;
    if (node.declaration) {
      const result = context.next();
      if (result?.declaration?.type === "EmptyStatement") {
        return empty2;
      }
      return result;
    }
    if (node.specifiers) {
      const specifiers = node.specifiers.filter((s) => s.exportKind !== "type");
      if (specifiers.length === 0) return empty2;
      return { ...node, specifiers };
    }
    return node;
  },
  ExportDefaultDeclaration(node) {
    if (node.exportKind === "type") return empty2;
    return node;
  },
  ExportAllDeclaration(node) {
    if (node.exportKind === "type") return empty2;
    return node;
  },
  PropertyDefinition(node, { next: next2 }) {
    if (node.accessor) {
      typescript_invalid_feature(
        node,
        "accessor fields (related TSC proposal is not stage 4 yet)"
      );
    }
    return next2();
  },
  TSAsExpression(node, context) {
    return context.visit(node.expression);
  },
  TSSatisfiesExpression(node, context) {
    return context.visit(node.expression);
  },
  TSNonNullExpression(node, context) {
    return context.visit(node.expression);
  },
  TSInterfaceDeclaration() {
    return empty2;
  },
  TSTypeAliasDeclaration() {
    return empty2;
  },
  TSTypeAssertion(node, context) {
    return context.visit(node.expression);
  },
  TSEnumDeclaration(node) {
    typescript_invalid_feature(node, "enums");
  },
  TSParameterProperty(node, context) {
    if ((node.readonly || node.accessibility) && context.path.at(-2)?.kind === "constructor") {
      typescript_invalid_feature(node, "accessibility modifiers on constructor parameters");
    }
    return context.visit(node.parameter);
  },
  TSInstantiationExpression(node, context) {
    return context.visit(node.expression);
  },
  FunctionExpression: remove_this_param,
  FunctionDeclaration: remove_this_param,
  TSDeclareFunction() {
    return empty2;
  },
  ClassBody(node, context) {
    const body = [];
    for (const _child of node.body) {
      const child = context.visit(_child);
      if (child.type !== "PropertyDefinition" || !child.declare) {
        body.push(child);
      }
    }
    return {
      ...node,
      body
    };
  },
  ClassDeclaration(node, context) {
    if (node.declare) {
      return empty2;
    }
    delete node.implements;
    return context.next();
  },
  MethodDefinition(node, context) {
    if (node.abstract) {
      return empty2;
    }
    return context.next();
  },
  VariableDeclaration(node, context) {
    if (node.declare) {
      return empty2;
    }
    return context.next();
  },
  TSModuleDeclaration(node, context) {
    if (!node.body) return empty2;
    const cleaned = (
      /** @type {any[]} */
      node.body.body.map((entry) => context.visit(entry))
    );
    if (cleaned.some((entry) => entry !== empty2)) {
      typescript_invalid_feature(node, "namespaces with non-type nodes");
    }
    return empty2;
  }
};
function remove_typescript_nodes(ast) {
  return walk(ast, null, visitors);
}

// node_modules/.deno/is-reference@3.0.3/node_modules/is-reference/src/index.js
function is_reference(node, parent) {
  if (node.type === "MemberExpression") {
    return !node.computed && is_reference(node.object, node);
  }
  if (node.type !== "Identifier") return false;
  switch (parent?.type) {
    // disregard `bar` in `foo.bar`
    case "MemberExpression":
      return parent.computed || node === parent.object;
    // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
    case "MethodDefinition":
      return parent.computed;
    // disregard the `meta` in `import.meta`
    case "MetaProperty":
      return parent.meta === node;
    // disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`
    case "PropertyDefinition":
      return parent.computed || node === parent.value;
    // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
    case "Property":
      return parent.computed || node === parent.value;
    // disregard the `bar` in `export { foo as bar }` or
    // the foo in `import { foo as bar }`
    case "ExportSpecifier":
    case "ImportSpecifier":
      return node === parent.local;
    // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
    case "LabeledStatement":
    case "BreakStatement":
    case "ContinueStatement":
      return false;
    default:
      return true;
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/slot.js
function determine_slot(node) {
  if (!is_element_node(node)) return null;
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") continue;
    if (attribute.name !== "slot") continue;
    if (!is_text_attribute(attribute)) continue;
    return (
      /** @type {string} */
      attribute.value[0].data
    );
  }
  return null;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/utils.js
function validate_assignment(node, argument, context) {
  validate_no_const_assignment(node, argument, context.state.scope, node.type === "BindDirective");
  if (argument.type === "Identifier") {
    const binding = context.state.scope.get(argument.name);
    if (context.state.analysis.runes) {
      if (context.state.analysis.props_id != null && binding?.node === context.state.analysis.props_id) {
        constant_assignment(node, "$props.id()");
      }
      if (binding?.kind === "each") {
        each_item_invalid_assignment(node);
      }
    }
    if (binding?.kind === "snippet") {
      snippet_parameter_assignment(node);
    }
  }
  if (argument.type === "MemberExpression" && argument.object.type === "ThisExpression") {
    const name = argument.computed && argument.property.type !== "Literal" ? null : get_name(argument.property);
    const field = name !== null && context.state.state_fields?.get(name);
    if (field && field.node.type === "AssignmentExpression" && node !== field.node) {
      let i = context.path.length;
      while (i--) {
        const parent = context.path[i];
        if (parent.type === "FunctionDeclaration" || parent.type === "FunctionExpression" || parent.type === "ArrowFunctionExpression") {
          const grandparent = get_parent(context.path, i - 1);
          if (grandparent.type === "MethodDefinition" && grandparent.kind === "constructor" && /** @type {number} */
          node.start < /** @type {number} */
          field.node.start) {
            state_field_invalid_assignment(node);
          }
          break;
        }
      }
    }
  }
}
function validate_no_const_assignment(node, argument, scope, is_binding) {
  if (argument.type === "ArrayPattern") {
    for (const element2 of argument.elements) {
      if (element2) {
        validate_no_const_assignment(node, element2, scope, is_binding);
      }
    }
  } else if (argument.type === "ObjectPattern") {
    for (const element2 of argument.properties) {
      if (element2.type === "Property") {
        validate_no_const_assignment(node, element2.value, scope, is_binding);
      }
    }
  } else if (argument.type === "Identifier") {
    const binding = scope.get(argument.name);
    if (binding?.declaration_kind === "import" || binding?.declaration_kind === "const" && binding.kind !== "each") {
      const thing = binding.declaration_kind === "import" ? "import" : "constant";
      if (is_binding) {
        constant_binding(node, thing);
      } else {
        constant_assignment(node, thing);
      }
    }
  }
}
function validate_opening_tag(node, state, expected) {
  if (state.analysis.source[node.start + 1] !== expected) {
    block_unexpected_character({ start: node.start, end: node.start + 5 }, expected);
  }
}
function validate_block_not_empty(node, context) {
  if (!node) return;
  if (node.nodes.length === 1 && node.nodes[0].type === "Text" && !node.nodes[0].raw.trim()) {
    block_empty(node.nodes[0]);
  }
}
function ensure_no_module_import_conflict(node, state) {
  const ids = extract_identifiers(node.id);
  for (const id2 of ids) {
    if (state.ast_type === "instance" && state.scope === state.analysis.instance.scope && state.analysis.module.scope.get(id2.name)?.declaration_kind === "import") {
      declaration_duplicate_module_import(node.id);
    }
  }
}
function is_safe_identifier(expression, scope) {
  let node = expression;
  while (node.type === "MemberExpression") node = node.object;
  if (node.type !== "Identifier") return false;
  const binding = scope.get(node.name);
  if (!binding) return true;
  if (binding.kind === "store_sub") {
    return is_safe_identifier({ name: node.name.slice(1), type: "Identifier" }, scope);
  }
  return binding.declaration_kind !== "import" && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "rest_prop";
}
function is_pure(node, context) {
  if (node.type === "Literal") {
    return true;
  }
  if (node.type === "CallExpression") {
    if (!is_pure(node.callee, context)) {
      return false;
    }
    for (let arg of node.arguments) {
      if (!is_pure(arg.type === "SpreadElement" ? arg.argument : arg, context)) {
        return false;
      }
    }
    return true;
  }
  if (node.type !== "Identifier" && node.type !== "MemberExpression") {
    return false;
  }
  if (get_rune(call(node), context.state.scope) === "$effect.tracking") {
    return false;
  }
  let left = node;
  while (left.type === "MemberExpression") {
    left = left.object;
  }
  if (!left) return false;
  if (left.type === "Identifier") {
    const binding = context.state.scope.get(left.name);
    if (binding === null) return true;
  } else if (is_pure(left, context)) {
    return true;
  }
  return false;
}
function validate_identifier_name(binding, function_depth) {
  if (!binding) return;
  const declaration_kind = binding.declaration_kind;
  if (declaration_kind !== "synthetic" && declaration_kind !== "param" && declaration_kind !== "rest_param" && (!function_depth || function_depth <= 1)) {
    const node = binding.node;
    if (node.name === "$") {
      dollar_binding_invalid(node);
    } else if (node.name.startsWith("$") && // import type { $Type } from "" - these are normally already filtered out,
    // but for the migration they aren't, and throwing here is preventing the migration to complete
    // TODO -> once migration script is gone we can remove this check
    !(binding.initial?.type === "ImportDeclaration" && /** @type {any} */
    binding.initial.importKind === "type")) {
      dollar_prefix_invalid(node);
    }
  }
}
function validate_export(node, scope, name) {
  const binding = scope.get(name);
  if (!binding) return;
  if (binding.kind === "derived") {
    derived_invalid_export(node);
  }
  if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
    state_invalid_export(node);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/scope.js
var UNKNOWN = Symbol("unknown");
var NUMBER = Symbol("number");
var STRING = Symbol("string");
var FUNCTION = Symbol("string");
var globals = {
  BigInt: [NUMBER],
  "Math.min": [NUMBER, Math.min],
  "Math.max": [NUMBER, Math.max],
  "Math.random": [NUMBER],
  "Math.floor": [NUMBER, Math.floor],
  // @ts-ignore
  "Math.f16round": [NUMBER, Math.f16round],
  "Math.round": [NUMBER, Math.round],
  "Math.abs": [NUMBER, Math.abs],
  "Math.acos": [NUMBER, Math.acos],
  "Math.asin": [NUMBER, Math.asin],
  "Math.atan": [NUMBER, Math.atan],
  "Math.atan2": [NUMBER, Math.atan2],
  "Math.ceil": [NUMBER, Math.ceil],
  "Math.cos": [NUMBER, Math.cos],
  "Math.sin": [NUMBER, Math.sin],
  "Math.tan": [NUMBER, Math.tan],
  "Math.exp": [NUMBER, Math.exp],
  "Math.log": [NUMBER, Math.log],
  "Math.pow": [NUMBER, Math.pow],
  "Math.sqrt": [NUMBER, Math.sqrt],
  "Math.clz32": [NUMBER, Math.clz32],
  "Math.imul": [NUMBER, Math.imul],
  "Math.sign": [NUMBER, Math.sign],
  "Math.log10": [NUMBER, Math.log10],
  "Math.log2": [NUMBER, Math.log2],
  "Math.log1p": [NUMBER, Math.log1p],
  "Math.expm1": [NUMBER, Math.expm1],
  "Math.cosh": [NUMBER, Math.cosh],
  "Math.sinh": [NUMBER, Math.sinh],
  "Math.tanh": [NUMBER, Math.tanh],
  "Math.acosh": [NUMBER, Math.acosh],
  "Math.asinh": [NUMBER, Math.asinh],
  "Math.atanh": [NUMBER, Math.atanh],
  "Math.trunc": [NUMBER, Math.trunc],
  "Math.fround": [NUMBER, Math.fround],
  "Math.cbrt": [NUMBER, Math.cbrt],
  Number: [NUMBER, Number],
  "Number.isInteger": [NUMBER, Number.isInteger],
  "Number.isFinite": [NUMBER, Number.isFinite],
  "Number.isNaN": [NUMBER, Number.isNaN],
  "Number.isSafeInteger": [NUMBER, Number.isSafeInteger],
  "Number.parseFloat": [NUMBER, Number.parseFloat],
  "Number.parseInt": [NUMBER, Number.parseInt],
  String: [STRING, String],
  "String.fromCharCode": [STRING, String.fromCharCode],
  "String.fromCodePoint": [STRING, String.fromCodePoint]
};
var global_constants = {
  "Math.PI": Math.PI,
  "Math.E": Math.E,
  "Math.LN10": Math.LN10,
  "Math.LN2": Math.LN2,
  "Math.LOG10E": Math.LOG10E,
  "Math.LOG2E": Math.LOG2E,
  "Math.SQRT2": Math.SQRT2,
  "Math.SQRT1_2": Math.SQRT1_2
};
var Binding = class {
  /** @type {Scope} */
  scope;
  /** @type {Identifier} */
  node;
  /** @type {BindingKind} */
  kind;
  /** @type {DeclarationKind} */
  declaration_kind;
  /**
   * What the value was initialized with.
   * For destructured props such as `let { foo = 'bar' } = $props()` this is `'bar'` and not `$props()`
   * @type {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock}
   */
  initial = null;
  /** @type {Array<{ node: Identifier; path: AST.SvelteNode[] }>} */
  references = [];
  /**
   * (Re)assignments of this binding. Includes declarations such as `function x() {}`.
   * @type {Array<{ value: Expression; scope: Scope }>}
   */
  assignments = [];
  /**
   * For `legacy_reactive`: its reactive dependencies
   * @type {Binding[]}
   */
  legacy_dependencies = [];
  /**
   * Legacy props: the `class` in `{ export klass as class}`. $props(): The `class` in { class: klass } = $props()
   * @type {string | null}
   */
  prop_alias = null;
  /**
   * Additional metadata, varies per binding type
   * @type {null | { inside_rest?: boolean; is_template_declaration?: boolean; exclude_props?: string[] }}
   */
  metadata = null;
  mutated = false;
  reassigned = false;
  /**
   * Instance-level declarations may follow (or contain) a top-level `await`. In these cases,
   * any reads that occur in the template must wait for the corresponding promise to resolve
   * otherwise the initial value will not have been assigned.
   * It is a member expression of the form `$$blockers[n]`.
   * TODO the blocker is set during transform which feels a bit grubby
   * @type {MemberExpression | null}
   */
  blocker = null;
  /**
   *
   * @param {Scope} scope
   * @param {Identifier} node
   * @param {BindingKind} kind
   * @param {DeclarationKind} declaration_kind
   * @param {Binding['initial']} initial
   */
  constructor(scope, node, kind, declaration_kind, initial) {
    this.scope = scope;
    this.node = node;
    this.initial = initial;
    this.kind = kind;
    this.declaration_kind = declaration_kind;
    if (initial) {
      this.assignments.push({ value: (
        /** @type {Expression} */
        initial
      ), scope });
    }
  }
  get updated() {
    return this.mutated || this.reassigned;
  }
  /**
   * @returns {this is Binding & { initial: ArrowFunctionExpression | FunctionDeclaration | FunctionExpression }}
   */
  is_function() {
    if (this.updated) {
      return false;
    }
    const type = this.initial?.type;
    return type === "ArrowFunctionExpression" || type === "FunctionExpression" || type === "FunctionDeclaration";
  }
};
var Evaluation = class {
  /** @type {Set<any>} */
  values;
  /**
   * True if there is exactly one possible value
   * @readonly
   * @type {boolean}
   */
  is_known = true;
  /**
   * True if the possible values contains `UNKNOWN`
   * @readonly
   * @type {boolean}
   */
  has_unknown = false;
  /**
   * True if the value is known to not be null/undefined
   * @readonly
   * @type {boolean}
   */
  is_defined = true;
  /**
   * True if the value is known to be a string
   * @readonly
   * @type {boolean}
   */
  is_string = true;
  /**
   * True if the value is known to be a number
   * @readonly
   * @type {boolean}
   */
  is_number = true;
  /**
   * True if the value is known to be a function
   * @readonly
   * @type {boolean}
   */
  is_function = true;
  /**
   * @readonly
   * @type {any}
   */
  value = void 0;
  /**
   *
   * @param {Scope} scope
   * @param {Expression | FunctionDeclaration} expression
   * @param {Set<any>} values
   */
  constructor(scope, expression, values) {
    current_evaluations.set(expression, this);
    this.values = values;
    switch (expression.type) {
      case "Literal": {
        this.values.add(expression.value);
        break;
      }
      case "Identifier": {
        const binding = scope.get(expression.name);
        if (binding) {
          if (binding.initial?.type === "CallExpression" && get_rune(binding.initial, scope) === "$props.id") {
            this.values.add(STRING);
            break;
          }
          const is_prop = binding.kind === "prop" || binding.kind === "rest_prop" || binding.kind === "bindable_prop";
          if (binding.initial?.type === "EachBlock" && binding.initial.index === expression.name) {
            this.values.add(NUMBER);
            break;
          }
          if (binding.initial?.type === "SnippetBlock") {
            this.is_defined = true;
            this.is_known = false;
            this.values.add(UNKNOWN);
            break;
          }
          if (!binding.updated && binding.initial !== null && !is_prop) {
            binding.scope.evaluate(
              /** @type {Expression} */
              binding.initial,
              this.values
            );
            break;
          }
        } else if (expression.name === "undefined") {
          this.values.add(void 0);
          break;
        }
        this.values.add(UNKNOWN);
        break;
      }
      case "BinaryExpression": {
        const a = scope.evaluate(
          /** @type {Expression} */
          expression.left
        );
        const b = scope.evaluate(expression.right);
        if (a.is_known && b.is_known) {
          this.values.add(binary2[expression.operator](a.value, b.value));
          break;
        }
        switch (expression.operator) {
          case "!=":
          case "!==":
          case "<":
          case "<=":
          case ">":
          case ">=":
          case "==":
          case "===":
          case "in":
          case "instanceof":
            this.values.add(true);
            this.values.add(false);
            break;
          case "%":
          case "&":
          case "*":
          case "**":
          case "-":
          case "/":
          case "<<":
          case ">>":
          case ">>>":
          case "^":
          case "|":
            this.values.add(NUMBER);
            break;
          case "+":
            if (a.is_string || b.is_string) {
              this.values.add(STRING);
            } else if (a.is_number && b.is_number) {
              this.values.add(NUMBER);
            } else {
              this.values.add(STRING);
              this.values.add(NUMBER);
            }
            break;
          default:
            this.values.add(UNKNOWN);
        }
        break;
      }
      case "ConditionalExpression": {
        const test = scope.evaluate(expression.test);
        const consequent = scope.evaluate(expression.consequent);
        const alternate = scope.evaluate(expression.alternate);
        if (test.is_known) {
          for (const value of (test.value ? consequent : alternate).values) {
            this.values.add(value);
          }
        } else {
          for (const value of consequent.values) {
            this.values.add(value);
          }
          for (const value of alternate.values) {
            this.values.add(value);
          }
        }
        break;
      }
      case "LogicalExpression": {
        const a = scope.evaluate(expression.left);
        const b = scope.evaluate(expression.right);
        if (a.is_known) {
          if (b.is_known) {
            this.values.add(logical2[expression.operator](a.value, b.value));
            break;
          }
          if (expression.operator === "&&" && !a.value || expression.operator === "||" && a.value || expression.operator === "??" && a.value != null) {
            this.values.add(a.value);
          } else {
            for (const value of b.values) {
              this.values.add(value);
            }
          }
          break;
        }
        for (const value of a.values) {
          this.values.add(value);
        }
        for (const value of b.values) {
          this.values.add(value);
        }
        break;
      }
      case "UnaryExpression": {
        const argument = scope.evaluate(expression.argument);
        if (argument.is_known) {
          this.values.add(unary2[expression.operator](argument.value));
          break;
        }
        switch (expression.operator) {
          case "!":
          case "delete":
            this.values.add(false);
            this.values.add(true);
            break;
          case "+":
          case "-":
          case "~":
            this.values.add(NUMBER);
            break;
          case "typeof":
            this.values.add(STRING);
            break;
          case "void":
            this.values.add(void 0);
            break;
          default:
            this.values.add(UNKNOWN);
        }
        break;
      }
      case "CallExpression": {
        const keypath = get_global_keypath(expression.callee, scope);
        if (keypath) {
          if (is_rune(keypath)) {
            const arg = (
              /** @type {Expression | undefined} */
              expression.arguments[0]
            );
            switch (keypath) {
              case "$state":
              case "$state.raw":
              case "$derived":
                if (arg) {
                  scope.evaluate(arg, this.values);
                } else {
                  this.values.add(void 0);
                }
                break;
              case "$props.id":
                this.values.add(STRING);
                break;
              case "$effect.tracking":
                this.values.add(false);
                this.values.add(true);
                break;
              case "$derived.by":
                if (arg?.type === "ArrowFunctionExpression" && arg.body.type !== "BlockStatement") {
                  scope.evaluate(arg.body, this.values);
                  break;
                }
                this.values.add(UNKNOWN);
                break;
              default: {
                this.values.add(UNKNOWN);
              }
            }
            break;
          }
          if (Object.hasOwn(globals, keypath) && expression.arguments.every((arg) => arg.type !== "SpreadElement")) {
            const [type, fn] = globals[keypath];
            const values2 = expression.arguments.map((arg) => scope.evaluate(arg));
            if (fn && values2.every((e2) => e2.is_known)) {
              this.values.add(fn(...values2.map((e2) => e2.value)));
            } else {
              this.values.add(type);
            }
            break;
          }
        }
        this.values.add(UNKNOWN);
        break;
      }
      case "TemplateLiteral": {
        let result = expression.quasis[0].value.cooked;
        for (let i = 0; i < expression.expressions.length; i += 1) {
          const e2 = scope.evaluate(expression.expressions[i]);
          if (e2.is_known) {
            result += e2.value + expression.quasis[i + 1].value.cooked;
          } else {
            this.values.add(STRING);
            break;
          }
        }
        this.values.add(result);
        break;
      }
      case "MemberExpression": {
        const keypath = get_global_keypath(expression, scope);
        if (keypath && Object.hasOwn(global_constants, keypath)) {
          this.values.add(global_constants[keypath]);
          break;
        }
        this.values.add(UNKNOWN);
        break;
      }
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "FunctionDeclaration": {
        this.values.add(FUNCTION);
        break;
      }
      default: {
        this.values.add(UNKNOWN);
      }
    }
    for (const value of this.values) {
      this.value = value;
      if (value !== STRING && typeof value !== "string") {
        this.is_string = false;
      }
      if (value !== NUMBER && typeof value !== "number") {
        this.is_number = false;
      }
      if (value !== FUNCTION) {
        this.is_function = false;
      }
      if (value == null || value === UNKNOWN) {
        this.is_defined = false;
      }
      if (value === UNKNOWN) {
        this.has_unknown = true;
      }
    }
    if (this.values.size > 1 || typeof this.value === "symbol") {
      this.is_known = false;
    }
    current_evaluations.delete(expression);
  }
};
var Scope3 = class _Scope {
  /** @type {ScopeRoot} */
  root;
  /**
   * The immediate parent scope
   * @type {Scope | null}
   */
  parent;
  /**
   * Whether or not `var` declarations are contained by this scope
   * @type {boolean}
   */
  #porous;
  /**
   * A map of every identifier declared by this scope, and all the
   * identifiers that reference it
   * @type {Map<string, Binding>}
   */
  declarations = /* @__PURE__ */ new Map();
  /**
   * A map of declarators to the bindings they declare
   * @type {Map<VariableDeclarator | AST.LetDirective, Binding[]>}
   */
  declarators = /* @__PURE__ */ new Map();
  /**
   * A set of all the names referenced with this scope
   *  useful for generating unique names
   * @type {Map<string, { node: Identifier; path: AST.SvelteNode[] }[]>}
   */
  references = /* @__PURE__ */ new Map();
  /**
   * The scope depth allows us to determine if a state variable is referenced in its own scope,
   * which is usually an error. Block statements do not increase this value
   */
  function_depth = 0;
  /**
   * If tracing of reactive dependencies is enabled for this scope
   * @type {null | Expression}
   */
  tracing = null;
  /**
   *
   * @param {ScopeRoot} root
   * @param {Scope | null} parent
   * @param {boolean} porous
   */
  constructor(root, parent, porous) {
    this.root = root;
    this.parent = parent;
    this.#porous = porous;
    this.function_depth = parent ? parent.function_depth + (porous ? 0 : 1) : 0;
  }
  /**
   * @param {Identifier} node
   * @param {Binding['kind']} kind
   * @param {DeclarationKind} declaration_kind
   * @param {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock} initial
   * @returns {Binding}
   */
  declare(node, kind, declaration_kind, initial = null) {
    if (this.parent) {
      if (declaration_kind === "var" && this.#porous) {
        return this.parent.declare(node, kind, declaration_kind);
      }
      if (declaration_kind === "import") {
        return this.parent.declare(node, kind, declaration_kind, initial);
      }
    }
    if (this.declarations.has(node.name)) {
      const binding2 = this.declarations.get(node.name);
      if (binding2 && binding2.declaration_kind !== "var" && declaration_kind !== "var") {
        declaration_duplicate(node, node.name);
      }
    }
    const binding = new Binding(this, node, kind, declaration_kind, initial);
    validate_identifier_name(binding, this.function_depth);
    this.declarations.set(node.name, binding);
    this.root.conflicts.add(node.name);
    return binding;
  }
  child(porous = false) {
    return new _Scope(this.root, this, porous);
  }
  /**
   * @param {string} preferred_name
   * @returns {string}
   */
  generate(preferred_name) {
    if (this.#porous) {
      return (
        /** @type {Scope} */
        this.parent.generate(preferred_name)
      );
    }
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_").replace(/^[0-9]/, "_");
    let name = preferred_name;
    let n2 = 1;
    while (this.references.has(name) || this.declarations.has(name) || this.root.conflicts.has(name) || is_reserved(name)) {
      name = `${preferred_name}_${n2++}`;
    }
    this.references.set(name, []);
    this.root.conflicts.add(name);
    return name;
  }
  /**
   * @param {string} name
   * @returns {Binding | null}
   */
  get(name) {
    return this.declarations.get(name) ?? this.parent?.get(name) ?? null;
  }
  /**
   * @param {VariableDeclarator | AST.LetDirective} node
   * @returns {Binding[]}
   */
  get_bindings(node) {
    const bindings = this.declarators.get(node);
    if (!bindings) {
      throw new Error("No binding found for declarator");
    }
    return bindings;
  }
  /**
   * @param {string} name
   * @returns {Scope | null}
   */
  owner(name) {
    return this.declarations.has(name) ? this : this.parent && this.parent.owner(name);
  }
  /**
   * @param {Identifier} node
   * @param {AST.SvelteNode[]} path
   */
  reference(node, path) {
    path = [...path];
    let references = this.references.get(node.name);
    if (!references) this.references.set(node.name, references = []);
    references.push({ node, path });
    const binding = this.declarations.get(node.name);
    if (binding) {
      binding.references.push({ node, path });
    } else if (this.parent) {
      this.parent.reference(node, path);
    } else {
      this.root.conflicts.add(node.name);
    }
  }
  /**
   * Does partial evaluation to find an exact value or at least the rough type of the expression.
   * Only call this once scope has been fully generated in a first pass,
   * else this evaluates on incomplete data and may yield wrong results.
   * @param {Expression} expression
   * @param {Set<any>} [values]
   */
  evaluate(expression, values = /* @__PURE__ */ new Set()) {
    const current2 = current_evaluations.get(expression);
    if (current2) return current2;
    return new Evaluation(this, expression, values);
  }
};
var current_evaluations = /* @__PURE__ */ new Map();
var binary2 = {
  "!=": (left, right) => left != right,
  "!==": (left, right) => left !== right,
  "<": (left, right) => left < right,
  "<=": (left, right) => left <= right,
  ">": (left, right) => left > right,
  ">=": (left, right) => left >= right,
  "==": (left, right) => left == right,
  "===": (left, right) => left === right,
  in: (left, right) => left in right,
  instanceof: (left, right) => left instanceof right,
  "%": (left, right) => left % right,
  "&": (left, right) => left & right,
  "*": (left, right) => left * right,
  "**": (left, right) => left ** right,
  "+": (left, right) => left + right,
  "-": (left, right) => left - right,
  "/": (left, right) => left / right,
  "<<": (left, right) => left << right,
  ">>": (left, right) => left >> right,
  ">>>": (left, right) => left >>> right,
  "^": (left, right) => left ^ right,
  "|": (left, right) => left | right
};
var unary2 = {
  "-": (argument) => -argument,
  "+": (argument) => +argument,
  "!": (argument) => !argument,
  "~": (argument) => ~argument,
  typeof: (argument) => typeof argument,
  void: () => void 0,
  delete: () => true
};
var logical2 = {
  "||": (left, right) => left || right,
  "&&": (left, right) => left && right,
  "??": (left, right) => left ?? right
};
var ScopeRoot = class {
  /** @type {Set<string>} */
  conflicts = /* @__PURE__ */ new Set();
  /**
   * @param {string} preferred_name
   */
  unique(preferred_name) {
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_");
    let final_name = preferred_name;
    let n2 = 1;
    while (this.conflicts.has(final_name)) {
      final_name = `${preferred_name}_${n2++}`;
    }
    this.conflicts.add(final_name);
    const id2 = id(final_name);
    return id2;
  }
};
function create_scopes(ast, root, allow_reactive_declarations, parent) {
  const scopes = /* @__PURE__ */ new Map();
  const scope = new Scope3(root, parent, false);
  scopes.set(ast, scope);
  const state = { scope };
  const references = [];
  const updates = [];
  const possible_implicit_declarations = [];
  function add_params(scope2, params) {
    for (const param of params) {
      for (const node of extract_identifiers(param)) {
        scope2.declare(node, "normal", param.type === "RestElement" ? "rest_param" : "param");
      }
    }
  }
  const create_block_scope = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child(true);
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const SvelteFragment4 = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child();
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const Component4 = (node, context) => {
    node.metadata.scopes = {
      default: context.state.scope.child()
    };
    if (node.type === "SvelteComponent") {
      context.visit(node.expression);
    }
    const default_state = determine_slot(node) ? context.state : { scope: node.metadata.scopes.default };
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        context.visit(attribute, default_state);
      } else {
        context.visit(attribute);
      }
    }
    for (const child of node.fragment.nodes) {
      let state2 = default_state;
      const slot_name = determine_slot(child);
      if (slot_name !== null) {
        node.metadata.scopes[slot_name] = context.state.scope.child();
        state2 = {
          scope: node.metadata.scopes[slot_name]
        };
      }
      context.visit(child, state2);
    }
  };
  const SvelteDirective = (node, { state: state2, path, visit }) => {
    state2.scope.reference(id(node.name.split(".")[0]), path);
    if (node.expression) {
      visit(node.expression);
    }
  };
  let has_await = false;
  walk(ast, state, {
    AwaitExpression(node, context) {
      has_await ||= context.path.every(
        ({ type }) => type !== "ArrowFunctionExpression" && type !== "FunctionExpression" && type !== "FunctionDeclaration"
      );
      context.next();
    },
    // references
    Identifier(node, { path, state: state2 }) {
      const parent2 = path.at(-1);
      if (parent2 && is_reference(
        node,
        /** @type {Node} */
        parent2
      ) && // TSTypeAnnotation, TSInterfaceDeclaration etc - these are normally already filtered out,
      // but for the migration they aren't, so we need to filter them out here
      // TODO -> once migration script is gone we can remove this check
      !parent2.type.startsWith("TS")) {
        references.push([state2.scope, { node, path: path.slice() }]);
      }
    },
    LabeledStatement(node, { path, next: next2 }) {
      if (path.length > 1 || !allow_reactive_declarations) return next2();
      if (node.label.name !== "$") return next2();
      const scope2 = state.scope.child();
      scopes.set(node, scope2);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        for (const id2 of extract_identifiers(node.body.expression.left)) {
          if (!id2.name.startsWith("$")) {
            possible_implicit_declarations.push(id2);
          }
        }
      }
      next2({ scope: scope2 });
    },
    SvelteFragment: SvelteFragment4,
    SlotElement: SvelteFragment4,
    SvelteElement: SvelteFragment4,
    RegularElement: SvelteFragment4,
    LetDirective(node, context) {
      const scope2 = context.state.scope;
      const bindings = [];
      scope2.declarators.set(node, bindings);
      if (node.expression) {
        for (const id2 of extract_identifiers_from_destructuring(node.expression)) {
          const binding = scope2.declare(id2, "template", "const");
          scope2.reference(id2, [context.path[context.path.length - 1], node]);
          bindings.push(binding);
        }
      } else {
        const id2 = {
          name: node.name,
          type: "Identifier",
          start: node.start,
          end: node.end
        };
        const binding = scope2.declare(id2, "template", "const");
        scope2.reference(id2, [context.path[context.path.length - 1], node]);
        bindings.push(binding);
      }
    },
    Component: (node, context) => {
      context.state.scope.reference(id(node.name.split(".")[0]), context.path);
      Component4(node, context);
    },
    SvelteSelf: Component4,
    SvelteComponent: Component4,
    // updates
    AssignmentExpression(node, { state: state2, next: next2 }) {
      updates.push([state2.scope, node.left, node.right]);
      next2();
    },
    UpdateExpression(node, { state: state2, next: next2 }) {
      const expression = (
        /** @type {Identifier | MemberExpression} */
        node.argument
      );
      updates.push([state2.scope, expression, expression]);
      next2();
    },
    ImportDeclaration(node, { state: state2 }) {
      for (const specifier of node.specifiers) {
        state2.scope.declare(specifier.local, "normal", "import", node);
      }
    },
    FunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      if (node.id) scope2.declare(node.id, "normal", "function");
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    FunctionDeclaration(node, { state: state2, next: next2 }) {
      if (node.id) state2.scope.declare(node.id, "normal", "function", node);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ArrowFunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ForStatement: create_block_scope,
    ForInStatement: create_block_scope,
    ForOfStatement: create_block_scope,
    SwitchStatement: create_block_scope,
    BlockStatement(node, context) {
      const parent2 = context.path.at(-1);
      if (parent2?.type === "FunctionDeclaration" || parent2?.type === "FunctionExpression" || parent2?.type === "ArrowFunctionExpression") {
        context.next();
      } else {
        create_block_scope(node, context);
      }
    },
    ClassDeclaration(node, { state: state2, next: next2 }) {
      if (node.id) state2.scope.declare(node.id, "normal", "let", node);
      next2();
    },
    VariableDeclaration(node, { state: state2, path, next: next2 }) {
      const is_parent_const_tag = path.at(-1)?.type === "ConstTag";
      for (const declarator2 of node.declarations) {
        const bindings = [];
        state2.scope.declarators.set(declarator2, bindings);
        for (const id2 of extract_identifiers(declarator2.id)) {
          const binding = state2.scope.declare(
            id2,
            is_parent_const_tag ? "template" : "normal",
            node.kind,
            declarator2.init
          );
          binding.metadata = { is_template_declaration: true };
          bindings.push(binding);
        }
      }
      next2();
    },
    CatchClause(node, { state: state2, next: next2 }) {
      if (node.param) {
        const scope2 = state2.scope.child(true);
        scopes.set(node, scope2);
        for (const id2 of extract_identifiers(node.param)) {
          scope2.declare(id2, "normal", "let");
        }
        next2({ scope: scope2 });
      } else {
        next2();
      }
    },
    EachBlock(node, { state: state2, visit }) {
      visit(node.expression);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      if (node.context) {
        for (const id2 of extract_identifiers(node.context)) {
          const binding = scope2.declare(id2, "each", "const");
          let inside_rest = false;
          let is_rest_id = false;
          walk(node.context, null, {
            Identifier(node2) {
              if (inside_rest && node2 === id2) {
                is_rest_id = true;
              }
            },
            RestElement(_2, { next: next2 }) {
              const prev = inside_rest;
              inside_rest = true;
              next2();
              inside_rest = prev;
            }
          });
          binding.metadata = { inside_rest: is_rest_id };
        }
        visit(node.context, { scope: scope2 });
      }
      if (node.index) {
        const is_keyed = node.key && (node.key.type !== "Identifier" || !node.index || node.key.name !== node.index);
        scope2.declare(id(node.index), is_keyed ? "template" : "static", "const", node);
      }
      if (node.key) visit(node.key, { scope: scope2 });
      for (const child of node.body.nodes) {
        visit(child, { scope: scope2 });
      }
      if (node.fallback) visit(node.fallback, { scope: scope2 });
      node.metadata = {
        expression: new ExpressionMetadata(),
        keyed: false,
        contains_group_binding: false,
        index: scope2.root.unique("$$index"),
        declarations: scope2.declarations,
        is_controlled: false,
        // filled in during analysis
        transitive_deps: /* @__PURE__ */ new Set()
      };
    },
    AwaitBlock(node, context) {
      context.visit(node.expression);
      if (node.pending) {
        context.visit(node.pending);
      }
      if (node.then) {
        context.visit(node.then);
        if (node.value) {
          const then_scope = (
            /** @type {Scope} */
            scopes.get(node.then)
          );
          const value_scope = context.state.scope.child();
          scopes.set(node.value, value_scope);
          context.visit(node.value, { scope: value_scope });
          for (const id2 of extract_identifiers(node.value)) {
            then_scope.declare(id2, "template", "const");
            value_scope.declare(id2, "normal", "const");
          }
        }
      }
      if (node.catch) {
        context.visit(node.catch);
        if (node.error) {
          const catch_scope = (
            /** @type {Scope} */
            scopes.get(node.catch)
          );
          const error_scope = context.state.scope.child();
          scopes.set(node.error, error_scope);
          context.visit(node.error, { scope: error_scope });
          for (const id2 of extract_identifiers(node.error)) {
            catch_scope.declare(id2, "template", "const");
            error_scope.declare(id2, "normal", "const");
          }
        }
      }
    },
    SnippetBlock(node, context) {
      const state2 = context.state;
      let scope2 = state2.scope;
      scope2.declare(node.expression, "normal", "function", node);
      const child_scope = state2.scope.child();
      scopes.set(node, child_scope);
      for (const param of node.parameters) {
        for (const id2 of extract_identifiers(param)) {
          child_scope.declare(id2, "snippet", "let");
        }
      }
      context.next({ scope: child_scope });
    },
    Fragment: (node, context) => {
      const scope2 = context.state.scope.child(node.metadata.transparent);
      scopes.set(node, scope2);
      context.next({ scope: scope2 });
    },
    BindDirective(node, context) {
      if (node.expression.type !== "SequenceExpression") {
        const expression = (
          /** @type {Identifier | MemberExpression} */
          node.expression
        );
        updates.push([context.state.scope, expression, expression]);
      }
      context.next();
    },
    TransitionDirective: SvelteDirective,
    AnimateDirective: SvelteDirective,
    UseDirective: SvelteDirective,
    // using it's own function instead of `SvelteDirective` because
    // StyleDirective doesn't have expressions and are generally already
    // handled by `Identifier`. This is the special case for the shorthand
    // eg <button style:height /> where the variable has the same name of
    // the css property
    StyleDirective(node, { path, state: state2, next: next2 }) {
      if (node.value === true) {
        state2.scope.reference(id(node.name), path.concat(node));
      }
      next2();
    }
    // TODO others
  });
  for (const id2 of possible_implicit_declarations) {
    const binding = scope.get(id2.name);
    if (binding) continue;
    scope.declare(id2, "legacy_reactive", "let");
  }
  for (const [scope2, { node, path }] of references) {
    scope2.reference(node, path);
  }
  for (const [scope2, node, value] of updates) {
    for (const expression of unwrap_pattern(node)) {
      const left = object2(expression);
      const binding = left && scope2.get(left.name);
      if (binding !== null && left !== binding.node) {
        if (left === expression) {
          binding.reassigned = true;
          binding.assignments.push({ value, scope: scope2 });
        } else {
          binding.mutated = true;
        }
      }
    }
  }
  return {
    has_await,
    scope,
    scopes
  };
}
function set_scope(node, { next: next2, state }) {
  const scope = state.scopes.get(node);
  next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
}
function get_rune(node, scope) {
  if (!node) return null;
  if (node.type !== "CallExpression") return null;
  const keypath = get_global_keypath(node.callee, scope);
  if (!keypath || !is_rune(keypath)) return null;
  return keypath;
}
function get_global_keypath(node, scope) {
  let n2 = node;
  let joined = "";
  while (n2.type === "MemberExpression") {
    if (n2.computed) return null;
    if (n2.property.type !== "Identifier") return null;
    joined = "." + n2.property.name + joined;
    n2 = n2.object;
  }
  if (n2.type === "CallExpression" && n2.callee.type === "Identifier") {
    joined = "()" + joined;
    n2 = n2.callee;
  }
  if (n2.type !== "Identifier") return null;
  const binding = scope.get(n2.name);
  if (binding !== null) return null;
  return n2.name + joined;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/utils/check_graph_for_cycles.js
function check_graph_for_cycles(edges) {
  const graph = edges.reduce((g, edge) => {
    const [u, v] = edge;
    if (!g.has(u)) g.set(u, []);
    if (!g.has(v)) g.set(v, []);
    g.get(u).push(v);
    return g;
  }, /* @__PURE__ */ new Map());
  const visited = /* @__PURE__ */ new Set();
  const on_stack = /* @__PURE__ */ new Set();
  const cycles = [];
  function visit(v) {
    visited.add(v);
    on_stack.add(v);
    graph.get(v)?.forEach((w2) => {
      if (!visited.has(w2)) {
        visit(w2);
      } else if (on_stack.has(w2)) {
        cycles.push([...on_stack, w2]);
      }
    });
    on_stack.delete(v);
  }
  graph.forEach((_2, v) => {
    if (!visited.has(v)) {
      visit(v);
    }
  });
  return cycles[0];
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/css.js
var regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
var regex_css_name_boundary = /^[\s,;}]$/;
function remove_css_prefix(name) {
  return name.replace(regex_css_browser_prefix, "");
}
var is_keyframes_node = (node) => remove_css_prefix(node.name) === "keyframes";

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/css/utils.js
var UNKNOWN2 = {};
function gather_possible_values(node, is_class, set2, is_nested = false) {
  if (set2.has(UNKNOWN2)) {
    return;
  }
  if (node.type === "Literal") {
    set2.add(String(node.value));
  } else if (node.type === "ConditionalExpression") {
    gather_possible_values(node.consequent, is_class, set2, is_nested);
    gather_possible_values(node.alternate, is_class, set2, is_nested);
  } else if (node.type === "LogicalExpression") {
    if (node.operator === "&&") {
      const left = /* @__PURE__ */ new Set();
      gather_possible_values(node.left, is_class, left, is_nested);
      if (left.has(UNKNOWN2)) {
        if (!is_class || !is_nested) {
          set2.add("");
          set2.add(false);
          set2.add(NaN);
          set2.add(0);
        }
      } else {
        for (const value of left) {
          if (!value && value != void 0 && (!is_class || !is_nested)) {
            set2.add(value);
          }
        }
      }
      gather_possible_values(node.right, is_class, set2, is_nested);
    } else {
      gather_possible_values(node.left, is_class, set2, is_nested);
      gather_possible_values(node.right, is_class, set2, is_nested);
    }
  } else if (is_class && node.type === "ArrayExpression") {
    for (const entry of node.elements) {
      if (entry) {
        gather_possible_values(entry, is_class, set2, true);
      }
    }
  } else if (is_class && node.type === "ObjectExpression") {
    for (const property of node.properties) {
      if (property.type === "Property" && !property.computed && (property.key.type === "Identifier" || property.key.type === "Literal")) {
        set2.add(
          property.key.type === "Identifier" ? property.key.name : String(property.key.value)
        );
      } else {
        set2.add(UNKNOWN2);
      }
    }
  } else {
    set2.add(UNKNOWN2);
  }
}
function get_possible_values(chunk, is_class) {
  const values = /* @__PURE__ */ new Set();
  if (chunk.type === "Text") {
    values.add(chunk.data);
  } else {
    gather_possible_values(chunk.expression, is_class, values);
  }
  if (values.has(UNKNOWN2)) return null;
  return [...values].map((value) => String(value));
}
function get_parent_rules(rule) {
  const rules = [];
  while (rule) {
    rules.push(rule);
    rule = rule.metadata.parent_rule;
  }
  return rules;
}
function is_global(relative_selector) {
  const first = relative_selector.selectors[0];
  return first.type === "PseudoClassSelector" && first.name === "global" && (first.args === null || // Only these two selector types keep the whole selector global, because e.g.
  // :global(button).x means that the selector is still scoped because of the .x
  relative_selector.selectors.every(
    (selector) => is_unscoped_pseudo_class(selector) || selector.type === "PseudoElementSelector"
  ));
}
function is_unscoped_pseudo_class(selector) {
  return selector.type === "PseudoClassSelector" && // These make the selector scoped
  (selector.name !== "has" && selector.name !== "is" && selector.name !== "where" && // Not is special because we want to scope as specific as possible, but because :not
  // inverses the result, we want to leave the unscoped, too. The exception is more than
  // one selector in the :not (.e.g :not(.x .y)), then .x and .y should be scoped
  (selector.name !== "not" || selector.args === null || selector.args.children.every((c) => c.children.length === 1)) || // selectors with has/is/where/not can also be global if all their children are global
  selector.args === null || selector.args.children.every((c) => c.children.every((r2) => is_global(r2))));
}
function is_outer_global(relative_selector) {
  const first = relative_selector.selectors[0];
  return first.type === "PseudoClassSelector" && first.name === "global" && (first.args === null || // Only these two selector types can keep the whole selector global, because e.g.
  // :global(button).x means that the selector is still scoped because of the .x
  relative_selector.selectors.every(
    (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
  ));
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/css/css-analyze.js
function is_global_block_selector(simple_selector) {
  return simple_selector.type === "PseudoClassSelector" && simple_selector.name === "global" && simple_selector.args === null;
}
function is_unscoped(path) {
  return path.filter((node) => node.type === "Rule").every((node) => node.metadata.has_global_selectors);
}
function is_in_global_block(path) {
  return path.some((node) => node.type === "Rule" && node.metadata.is_global_block);
}
var css_visitors = {
  Atrule(node, context) {
    if (is_keyframes_node(node)) {
      if (!node.prelude.startsWith("-global-") && !is_in_global_block(context.path)) {
        context.state.keyframes.push(node.prelude);
      } else if (node.prelude.startsWith("-global-")) {
        context.state.analysis.css.has_global ||= is_unscoped(context.path);
      }
    }
    context.next();
  },
  ComplexSelector(node, context) {
    context.next();
    {
      const global = node.children.find(is_global);
      if (global) {
        const is_nested = context.path.at(-2)?.type === "PseudoClassSelector";
        if (is_nested && !global.selectors[0].args) {
          css_global_block_invalid_placement(global.selectors[0]);
        }
        const idx = node.children.indexOf(global);
        if (global.selectors[0].args !== null && idx !== 0 && idx !== node.children.length - 1) {
          for (let i = idx + 1; i < node.children.length; i++) {
            if (!is_global(node.children[i])) {
              css_global_invalid_placement(global.selectors[0]);
            }
          }
        }
      }
    }
    for (const relative_selector of node.children) {
      for (let i = 0; i < relative_selector.selectors.length; i++) {
        const selector = relative_selector.selectors[i];
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          const child = selector.args?.children[0].children[0];
          if (child?.selectors[0].type === "TypeSelector" && i !== 0) {
            css_global_invalid_selector_list(selector);
          }
          if (relative_selector.selectors[i + 1]?.type === "TypeSelector") {
            css_type_selector_invalid_placement(relative_selector.selectors[i + 1]);
          }
          if (selector.args !== null && selector.args.children.length > 1 && (node.children.length > 1 || relative_selector.selectors.length > 1)) {
            css_global_invalid_selector(selector);
          }
        }
      }
    }
    node.metadata.rule = context.state.rule;
    node.metadata.is_global = node.children.every(
      ({ metadata }) => metadata.is_global || metadata.is_global_like
    );
    node.metadata.used ||= node.metadata.is_global;
    if (node.metadata.rule?.metadata.parent_rule && node.children[0]?.selectors[0]?.type === "NestingSelector") {
      const first = node.children[0]?.selectors[1];
      const no_nesting_scope = first?.type !== "PseudoClassSelector" || is_unscoped_pseudo_class(first);
      const parent_is_global = node.metadata.rule.metadata.parent_rule.prelude.children.some(
        (child) => child.children.length === 1 && child.children[0].metadata.is_global
      );
      if (no_nesting_scope && parent_is_global) {
        node.metadata.used = true;
      }
    }
  },
  RelativeSelector(node, context) {
    const parent = (
      /** @type {AST.CSS.ComplexSelector} */
      context.path.at(-1)
    );
    if (node.combinator != null && !context.state.rule?.metadata.parent_rule && parent.children[0] === node && context.path.at(-3)?.type !== "PseudoClassSelector") {
      css_selector_invalid(node.combinator);
    }
    node.metadata.is_global = node.selectors.length >= 1 && is_global(node);
    if (node.selectors.length >= 1 && node.selectors.every(
      (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
    )) {
      const first = node.selectors[0];
      node.metadata.is_global_like ||= first.type === "PseudoClassSelector" && first.name === "host" || first.type === "PseudoElementSelector" && [
        "view-transition",
        "view-transition-group",
        "view-transition-old",
        "view-transition-new",
        "view-transition-image-pair"
      ].includes(first.name);
    }
    node.metadata.is_global_like ||= node.selectors.some(
      (child) => child.type === "PseudoClassSelector" && child.name === "root"
    ) && // :root.y:has(.x) is not a global selector because while .y is unscoped, .x inside `:has(...)` should be scoped
    !node.selectors.some((child) => child.type === "PseudoClassSelector" && child.name === "has");
    if (node.metadata.is_global_like || node.metadata.is_global) {
      for (const child of node.selectors) {
        walk(
          /** @type {AST.CSS.Node} */
          child,
          null,
          {
            ComplexSelector(node2, context2) {
              node2.metadata.used = true;
              context2.next();
            }
          }
        );
      }
    }
    context.next();
  },
  Rule(node, context) {
    node.metadata.parent_rule = context.state.rule;
    for (const complex_selector of node.prelude.children) {
      let is_global_block = false;
      for (let selector_idx = 0; selector_idx < complex_selector.children.length; selector_idx++) {
        const child = complex_selector.children[selector_idx];
        const idx = child.selectors.findIndex(is_global_block_selector);
        if (is_global_block) {
          child.metadata.is_global_like = true;
        }
        if (idx === 0) {
          if (child.selectors.length > 1 && selector_idx === 0 && node.metadata.parent_rule === null) {
            css_global_block_invalid_modifier_start(child.selectors[1]);
          } else {
            node.metadata.is_global_block = is_global_block = true;
            for (let i = 1; i < child.selectors.length; i++) {
              walk(
                /** @type {AST.CSS.Node} */
                child.selectors[i],
                null,
                {
                  ComplexSelector(node2) {
                    node2.metadata.used = true;
                  }
                }
              );
            }
            if (child.combinator && child.combinator.name !== " ") {
              css_global_block_invalid_combinator(child, child.combinator.name);
            }
            const declaration2 = node.block.children.find((child2) => child2.type === "Declaration");
            const is_lone_global = complex_selector.children.length === 1 && complex_selector.children[0].selectors.length === 1;
            if (is_lone_global && node.prelude.children.length > 1) {
              css_global_block_invalid_list(node.prelude);
            }
            if (declaration2 && // :global { color: red; } is invalid, but foo :global { color: red; } is valid
            node.prelude.children.length === 1 && is_lone_global) {
              css_global_block_invalid_declaration(declaration2);
            }
          }
        } else if (idx !== -1) {
          css_global_block_invalid_modifier(child.selectors[idx]);
        }
      }
      if (node.metadata.is_global_block && !is_global_block) {
        css_global_block_invalid_list(node.prelude);
      }
    }
    const state = { ...context.state, rule: node };
    context.visit(node.prelude, state);
    for (const selector of node.prelude.children) {
      node.metadata.has_global_selectors ||= selector.metadata.is_global;
      node.metadata.has_local_selectors ||= !selector.metadata.is_global;
    }
    context.state.analysis.css.has_global ||= node.metadata.has_global_selectors && node.block.children.filter((child) => child.type === "Declaration").length > 0 && is_unscoped(context.path);
    context.visit(node.block, state);
  },
  NestingSelector(node, context) {
    const rule = (
      /** @type {AST.CSS.Rule} */
      context.state.rule
    );
    const parent_rule = rule.metadata.parent_rule;
    if (!parent_rule) {
      const children = rule.prelude.children;
      const selectors = children[0].children[0].selectors;
      if (children.length > 1 || selectors.length > 1 || selectors[0].type !== "PseudoClassSelector" || selectors[0].name !== "global" || selectors[0].args?.children[0]?.children[0].selectors[0] !== node) {
        css_nesting_selector_invalid_placement(node);
      }
    } else if (
      // :global { &.foo { ... } } is invalid
      parent_rule.metadata.is_global_block && !parent_rule.metadata.parent_rule && parent_rule.prelude.children[0].children.length === 1 && parent_rule.prelude.children[0].children[0].selectors.length === 1
    ) {
      css_global_block_invalid_modifier_start(node);
    }
    context.next();
  }
};
function analyze_css(stylesheet, analysis) {
  const css_state = {
    keyframes: analysis.css.keyframes,
    rule: null,
    analysis
  };
  walk(stylesheet, css_state, css_visitors);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/css/css-prune.js
var NODE_PROBABLY_EXISTS = 0;
var NODE_DEFINITELY_EXISTS = 1;
var FORWARD = 0;
var BACKWARD = 1;
var whitelist_attribute_selector = /* @__PURE__ */ new Map([
  ["details", ["open"]],
  ["dialog", ["open"]]
]);
var descendant_combinator = {
  type: "Combinator",
  name: " ",
  start: -1,
  end: -1
};
var nesting_selector = {
  type: "RelativeSelector",
  start: -1,
  end: -1,
  combinator: null,
  selectors: [
    {
      type: "NestingSelector",
      name: "&",
      start: -1,
      end: -1
    }
  ],
  metadata: {
    is_global: false,
    is_global_like: false,
    scoped: false
  }
};
var any_selector = {
  type: "RelativeSelector",
  start: -1,
  end: -1,
  combinator: null,
  selectors: [
    {
      type: "TypeSelector",
      name: "*",
      start: -1,
      end: -1
    }
  ],
  metadata: {
    is_global: false,
    is_global_like: false,
    scoped: false
  }
};
var seen = /* @__PURE__ */ new Set();
function prune(stylesheet, element2) {
  walk(
    /** @type {Compiler.AST.CSS.Node} */
    stylesheet,
    null,
    {
      Rule(node, context) {
        if (node.metadata.is_global_block) {
          context.visit(node.prelude);
        } else {
          context.next();
        }
      },
      ComplexSelector(node) {
        const selectors = get_relative_selectors(node);
        seen.clear();
        if (apply_selector(
          selectors,
          /** @type {Compiler.AST.CSS.Rule} */
          node.metadata.rule,
          element2,
          BACKWARD
        )) {
          node.metadata.used = true;
        }
      }
    }
  );
}
function get_relative_selectors(node) {
  const selectors = truncate(node);
  if (node.metadata.rule?.metadata.parent_rule && selectors.length > 0) {
    let has_explicit_nesting_selector = false;
    for (let selector of selectors) {
      walk(selector, null, {
        // @ts-ignore
        NestingSelector() {
          has_explicit_nesting_selector = true;
        }
      });
      if (has_explicit_nesting_selector) break;
    }
    if (!has_explicit_nesting_selector) {
      if (selectors[0].combinator === null) {
        selectors[0] = {
          ...selectors[0],
          combinator: descendant_combinator
        };
      }
      selectors.unshift(nesting_selector);
    }
  }
  return selectors;
}
function truncate(node) {
  const i = node.children.findLastIndex(({ metadata, selectors }) => {
    const first = selectors[0];
    return (
      // not after a :global selector
      !metadata.is_global_like && !(first.type === "PseudoClassSelector" && first.name === "global" && first.args === null) && // not a :global(...) without a :has/is/where(...) modifier that is scoped
      !metadata.is_global
    );
  });
  return node.children.slice(0, i + 1).map((child) => {
    const root = child.selectors.find((s) => s.type === "PseudoClassSelector" && s.name === "root");
    if (!root || child.metadata.is_global_like) return child;
    return {
      ...child,
      selectors: child.selectors.filter((s) => s.type === "PseudoClassSelector" && s.name === "has")
    };
  });
}
function apply_selector(relative_selectors, rule, element2, direction) {
  const rest_selectors = relative_selectors.slice();
  const relative_selector = direction === FORWARD ? rest_selectors.shift() : rest_selectors.pop();
  const matched = !!relative_selector && relative_selector_might_apply_to_node(relative_selector, rule, element2, direction) && apply_combinator(relative_selector, rest_selectors, rule, element2, direction);
  if (matched) {
    if (!is_outer_global(relative_selector)) {
      relative_selector.metadata.scoped = true;
    }
    element2.metadata.scoped = true;
  }
  return matched;
}
function apply_combinator(relative_selector, rest_selectors, rule, node, direction) {
  const combinator = direction == FORWARD ? rest_selectors[0]?.combinator : relative_selector.combinator;
  if (!combinator) return true;
  switch (combinator.name) {
    case " ":
    case ">": {
      const is_adjacent = combinator.name === ">";
      const parents = direction === FORWARD ? get_descendant_elements(node, is_adjacent) : get_ancestor_elements(node, is_adjacent);
      let parent_matched = false;
      for (const parent of parents) {
        if (apply_selector(rest_selectors, rule, parent, direction)) {
          parent_matched = true;
        }
      }
      return parent_matched || direction === BACKWARD && (!is_adjacent || parents.length === 0) && rest_selectors.every((selector) => is_global2(selector, rule));
    }
    case "+":
    case "~": {
      const siblings = get_possible_element_siblings(node, direction, combinator.name === "+");
      let sibling_matched = false;
      for (const possible_sibling of siblings.keys()) {
        if (possible_sibling.type === "RenderTag" || possible_sibling.type === "SlotElement" || possible_sibling.type === "Component") {
          if (rest_selectors.length === 1 && rest_selectors[0].metadata.is_global) {
            sibling_matched = true;
          }
        } else if (apply_selector(rest_selectors, rule, possible_sibling, direction)) {
          sibling_matched = true;
        }
      }
      return sibling_matched || direction === BACKWARD && get_element_parent(node) === null && rest_selectors.every((selector) => is_global2(selector, rule));
    }
    default:
      return true;
  }
}
function is_global2(selector, rule) {
  if (selector.metadata.is_global || selector.metadata.is_global_like) {
    return true;
  }
  let explicitly_global = false;
  for (const s of selector.selectors) {
    let selector_list = null;
    let can_be_global = false;
    let owner = rule;
    if (s.type === "PseudoClassSelector") {
      if ((s.name === "is" || s.name === "where") && s.args) {
        selector_list = s.args;
      } else {
        can_be_global = is_unscoped_pseudo_class(s);
      }
    }
    if (s.type === "NestingSelector") {
      owner = /** @type {Compiler.AST.CSS.Rule} */
      rule.metadata.parent_rule;
      selector_list = owner.prelude;
    }
    const has_global_selectors = !!selector_list?.children.some((complex_selector) => {
      return complex_selector.children.every(
        (relative_selector) => is_global2(relative_selector, owner)
      );
    });
    explicitly_global ||= has_global_selectors;
    if (!has_global_selectors && !can_be_global) {
      return false;
    }
  }
  return explicitly_global || selector.selectors.length === 0;
}
var regex_backslash_and_following_character = /\\(.)/g;
function relative_selector_might_apply_to_node(relative_selector, rule, element2, direction) {
  const has_selectors = [];
  const other_selectors = [];
  for (const selector of relative_selector.selectors) {
    if (selector.type === "PseudoClassSelector" && selector.name === "has" && selector.args) {
      has_selectors.push(selector);
    } else {
      other_selectors.push(selector);
    }
  }
  if (has_selectors.length > 0) {
    const rules = get_parent_rules(rule);
    const include_self = rules.some((r2) => r2.prelude.children.some((c) => c.children.some((s) => is_global2(s, r2)))) || rules[rules.length - 1].prelude.children.some(
      (c) => c.children.some(
        (r2) => r2.selectors.some(
          (s) => s.type === "PseudoClassSelector" && (s.name === "root" || s.name === "global" && s.args)
        )
      )
    );
    for (const has_selector of has_selectors) {
      const complex_selectors = (
        /** @type {Compiler.AST.CSS.SelectorList} */
        has_selector.args.children
      );
      let matched = false;
      for (const complex_selector of complex_selectors) {
        const [first, ...rest2] = truncate(complex_selector);
        if (!first) {
          complex_selector.metadata.used = true;
          matched = true;
          continue;
        }
        if (include_self) {
          const selector_including_self = [
            first.combinator ? { ...first, combinator: null } : first,
            ...rest2
          ];
          if (apply_selector(selector_including_self, rule, element2, FORWARD)) {
            complex_selector.metadata.used = true;
            matched = true;
          }
        }
        const selector_excluding_self = [
          any_selector,
          first.combinator ? first : { ...first, combinator: descendant_combinator },
          ...rest2
        ];
        if (apply_selector(selector_excluding_self, rule, element2, FORWARD)) {
          complex_selector.metadata.used = true;
          matched = true;
        }
      }
      if (!matched) {
        return false;
      }
    }
  }
  for (const selector of other_selectors) {
    if (selector.type === "Percentage" || selector.type === "Nth") continue;
    const name = selector.name.replace(regex_backslash_and_following_character, "$1");
    switch (selector.type) {
      case "PseudoClassSelector": {
        if (name === "host" || name === "root") return false;
        if (name === "global" && selector.args !== null && relative_selector.selectors.length === 1) {
          const args = selector.args;
          const complex_selector = args.children[0];
          return apply_selector(complex_selector.children, rule, element2, BACKWARD);
        }
        if (name === "global" && selector.args === null) return true;
        if (name === "not" && selector.args) {
          for (const complex_selector of selector.args.children) {
            walk(complex_selector, null, {
              ComplexSelector(node, context) {
                node.metadata.used = true;
                context.next();
              }
            });
            const relative = truncate(complex_selector);
            if (complex_selector.children.length > 1) {
              for (const selector2 of relative) {
                selector2.metadata.scoped = true;
              }
              let el = element2;
              while (el) {
                el.metadata.scoped = true;
                el = get_element_parent(el);
              }
            }
          }
          break;
        }
        if ((name === "is" || name === "where") && selector.args) {
          let matched = false;
          for (const complex_selector of selector.args.children) {
            const relative = truncate(complex_selector);
            const is_global3 = relative.length === 0;
            if (is_global3) {
              complex_selector.metadata.used = true;
              matched = true;
            } else if (apply_selector(relative, rule, element2, BACKWARD)) {
              complex_selector.metadata.used = true;
              matched = true;
            } else if (complex_selector.children.length > 1 && (name == "is" || name == "where")) {
              complex_selector.metadata.used = true;
              matched = true;
              for (const selector2 of relative) {
                selector2.metadata.scoped = true;
              }
            }
          }
          if (!matched) {
            return false;
          }
        }
        break;
      }
      case "PseudoElementSelector": {
        break;
      }
      case "AttributeSelector": {
        const whitelisted = whitelist_attribute_selector.get(element2.name.toLowerCase());
        if (!whitelisted?.includes(selector.name.toLowerCase()) && !attribute_matches(
          element2,
          selector.name,
          selector.value && unquote(selector.value),
          selector.matcher,
          selector.flags?.includes("i") ?? false
        )) {
          return false;
        }
        break;
      }
      case "ClassSelector": {
        if (!attribute_matches(element2, "class", name, "~=", false)) {
          return false;
        }
        break;
      }
      case "IdSelector": {
        if (!attribute_matches(element2, "id", name, "=", false)) {
          return false;
        }
        break;
      }
      case "TypeSelector": {
        if (element2.name.toLowerCase() !== name.toLowerCase() && name !== "*" && element2.type !== "SvelteElement") {
          return false;
        }
        break;
      }
      case "NestingSelector": {
        let matched = false;
        const parent = (
          /** @type {Compiler.AST.CSS.Rule} */
          rule.metadata.parent_rule
        );
        for (const complex_selector of parent.prelude.children) {
          if (apply_selector(get_relative_selectors(complex_selector), parent, element2, direction) || complex_selector.children.every((s) => is_global2(s, parent))) {
            complex_selector.metadata.used = true;
            matched = true;
          }
        }
        if (!matched) {
          return false;
        }
        break;
      }
    }
  }
  return true;
}
function test_attribute(operator, expected_value, case_insensitive, value) {
  if (case_insensitive) {
    expected_value = expected_value.toLowerCase();
    value = value.toLowerCase();
  }
  switch (operator) {
    case "=":
      return value === expected_value;
    case "~=":
      return value.split(/\s/).includes(expected_value);
    case "|=":
      return `${value}-`.startsWith(`${expected_value}-`);
    case "^=":
      return value.startsWith(expected_value);
    case "$=":
      return value.endsWith(expected_value);
    case "*=":
      return value.includes(expected_value);
    default:
      throw new Error("this shouldn't happen");
  }
}
function attribute_matches(node, name, expected_value, operator, case_insensitive) {
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") return true;
    if (attribute.type === "BindDirective" && attribute.name === name) return true;
    const name_lower = name.toLowerCase();
    if (attribute.type === "StyleDirective" && name_lower === "style") return true;
    if (attribute.type === "ClassDirective" && name_lower === "class") {
      if (operator === "~=") {
        if (attribute.name === expected_value) return true;
      } else {
        return true;
      }
    }
    if (attribute.type !== "Attribute") continue;
    if (attribute.name.toLowerCase() !== name_lower) continue;
    if (attribute.value === true) return operator === null;
    if (expected_value === null) return true;
    if (is_text_attribute(attribute)) {
      const matches = test_attribute(
        operator,
        expected_value,
        case_insensitive,
        attribute.value[0].data
      );
      if (!matches && (name_lower === "class" || name_lower === "style")) continue;
      return matches;
    }
    const chunks = get_attribute_chunks(attribute.value);
    const possible_values = /* @__PURE__ */ new Set();
    let prev_values = [];
    for (const chunk of chunks) {
      const current_possible_values = get_possible_values(chunk, name_lower === "class");
      if (!current_possible_values) return true;
      if (prev_values.length > 0) {
        const start_with_space = [];
        const remaining = [];
        current_possible_values.forEach((current_possible_value) => {
          if (regex_starts_with_whitespace.test(current_possible_value)) {
            start_with_space.push(current_possible_value);
          } else {
            remaining.push(current_possible_value);
          }
        });
        if (remaining.length > 0) {
          if (start_with_space.length > 0) {
            prev_values.forEach((prev_value) => possible_values.add(prev_value));
          }
          const combined = [];
          prev_values.forEach((prev_value) => {
            remaining.forEach((value) => {
              combined.push(prev_value + value);
            });
          });
          prev_values = combined;
          start_with_space.forEach((value) => {
            if (regex_ends_with_whitespace.test(value)) {
              possible_values.add(value);
            } else {
              prev_values.push(value);
            }
          });
          continue;
        } else {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
          prev_values = [];
        }
      }
      current_possible_values.forEach((current_possible_value) => {
        if (regex_ends_with_whitespace.test(current_possible_value)) {
          possible_values.add(current_possible_value);
        } else {
          prev_values.push(current_possible_value);
        }
      });
      if (prev_values.length < current_possible_values.length) {
        prev_values.push(" ");
      }
      if (prev_values.length > 20) {
        return true;
      }
    }
    prev_values.forEach((prev_value) => possible_values.add(prev_value));
    for (const value of possible_values) {
      if (test_attribute(operator, expected_value, case_insensitive, value)) return true;
    }
  }
  return false;
}
function unquote(str2) {
  if (str2[0] === str2[str2.length - 1] && str2[0] === "'" || str2[0] === '"') {
    return str2.slice(1, str2.length - 1);
  }
  return str2;
}
function get_ancestor_elements(node, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const ancestors = [];
  const path = node.metadata.path;
  let i = path.length;
  while (i--) {
    const parent = path[i];
    if (parent.type === "SnippetBlock") {
      if (!seen2.has(parent)) {
        seen2.add(parent);
        for (const site of parent.metadata.sites) {
          ancestors.push(...get_ancestor_elements(site, adjacent_only, seen2));
        }
      }
      break;
    }
    if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
      ancestors.push(parent);
      if (adjacent_only) {
        break;
      }
    }
  }
  return ancestors;
}
function get_descendant_elements(node, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const descendants = [];
  function walk_children(node2) {
    walk(node2, null, {
      _(node3, context) {
        if (node3.type === "RegularElement" || node3.type === "SvelteElement") {
          descendants.push(node3);
          if (!adjacent_only) {
            context.next();
          }
        } else if (node3.type === "RenderTag") {
          for (const snippet of node3.metadata.snippets) {
            if (seen2.has(snippet)) continue;
            seen2.add(snippet);
            walk_children(snippet.body);
          }
        } else {
          context.next();
        }
      }
    });
  }
  walk_children(node.type === "RenderTag" ? node : node.fragment);
  return descendants;
}
function get_element_parent(node) {
  let path = node.metadata.path;
  let i = path.length;
  while (i--) {
    const parent = path[i];
    if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
      return parent;
    }
  }
  return null;
}
function get_possible_element_siblings(node, direction, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const result = /* @__PURE__ */ new Map();
  const path = node.metadata.path;
  let current2 = node;
  let i = path.length;
  while (i--) {
    const fragment2 = (
      /** @type {Compiler.AST.Fragment} */
      path[i--]
    );
    let j = fragment2.nodes.indexOf(current2) + (direction === FORWARD ? 1 : -1);
    while (j >= 0 && j < fragment2.nodes.length) {
      const node2 = fragment2.nodes[j];
      if (node2.type === "RegularElement") {
        const has_slot_attribute = node2.attributes.some(
          (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"
        );
        if (!has_slot_attribute) {
          result.set(node2, NODE_DEFINITELY_EXISTS);
          if (adjacent_only) {
            return result;
          }
        }
      } else if (is_block(node2) || node2.type === "Component") {
        if (node2.type === "SlotElement" || node2.type === "Component") {
          result.set(node2, NODE_PROBABLY_EXISTS);
        }
        const possible_last_child = get_possible_nested_siblings(node2, direction, adjacent_only);
        add_to_map(possible_last_child, result);
        if (adjacent_only && node2.type !== "Component" && has_definite_elements(possible_last_child)) {
          return result;
        }
      } else if (node2.type === "SvelteElement") {
        result.set(node2, NODE_PROBABLY_EXISTS);
      } else if (node2.type === "RenderTag") {
        result.set(node2, NODE_PROBABLY_EXISTS);
        for (const snippet of node2.metadata.snippets) {
          add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only), result);
        }
      }
      j = direction === FORWARD ? j + 1 : j - 1;
    }
    current2 = path[i];
    if (!current2) break;
    if (current2.type === "Component" || current2.type === "SvelteComponent" || current2.type === "SvelteSelf") {
      continue;
    }
    if (current2.type === "SnippetBlock") {
      if (seen2.has(current2)) break;
      seen2.add(current2);
      for (const site of current2.metadata.sites) {
        const siblings = get_possible_element_siblings(site, direction, adjacent_only, seen2);
        add_to_map(siblings, result);
        if (adjacent_only && current2.metadata.sites.size === 1 && has_definite_elements(siblings)) {
          return result;
        }
      }
    }
    if (!is_block(current2)) break;
    if (current2.type === "EachBlock" && fragment2 === current2.body) {
      add_to_map(get_possible_nested_siblings(current2, direction, adjacent_only), result);
    }
  }
  return result;
}
function get_possible_nested_siblings(node, direction, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  let fragments = [];
  switch (node.type) {
    case "EachBlock":
      fragments.push(node.body, node.fallback);
      break;
    case "IfBlock":
      fragments.push(node.consequent, node.alternate);
      break;
    case "AwaitBlock":
      fragments.push(node.pending, node.then, node.catch);
      break;
    case "KeyBlock":
    case "SlotElement":
      fragments.push(node.fragment);
      break;
    case "SnippetBlock":
      if (seen2.has(node)) {
        return /* @__PURE__ */ new Map();
      }
      seen2.add(node);
      fragments.push(node.body);
      break;
    case "Component":
      fragments.push(node.fragment, ...[...node.metadata.snippets].map((s) => s.body));
      break;
  }
  const result = /* @__PURE__ */ new Map();
  let exhaustive = node.type !== "SlotElement" && node.type !== "SnippetBlock";
  for (const fragment2 of fragments) {
    if (fragment2 == null) {
      exhaustive = false;
      continue;
    }
    const map = loop_child(fragment2.nodes, direction, adjacent_only, seen2);
    exhaustive &&= has_definite_elements(map);
    add_to_map(map, result);
  }
  if (!exhaustive) {
    for (const key2 of result.keys()) {
      result.set(key2, NODE_PROBABLY_EXISTS);
    }
  }
  return result;
}
function has_definite_elements(result) {
  if (result.size === 0) return false;
  for (const exist of result.values()) {
    if (exist === NODE_DEFINITELY_EXISTS) {
      return true;
    }
  }
  return false;
}
function add_to_map(from, to) {
  from.forEach((exist, element2) => {
    to.set(element2, higher_existence(exist, to.get(element2)));
  });
}
function higher_existence(exist1, exist2) {
  if (exist2 === void 0) return exist1;
  return exist1 > exist2 ? exist1 : exist2;
}
function loop_child(children, direction, adjacent_only, seen2) {
  const result = /* @__PURE__ */ new Map();
  let i = direction === FORWARD ? 0 : children.length - 1;
  while (i >= 0 && i < children.length) {
    const child = children[i];
    if (child.type === "RegularElement") {
      result.set(child, NODE_DEFINITELY_EXISTS);
      if (adjacent_only) {
        break;
      }
    } else if (child.type === "SvelteElement") {
      result.set(child, NODE_PROBABLY_EXISTS);
    } else if (child.type === "RenderTag") {
      for (const snippet of child.metadata.snippets) {
        add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only, seen2), result);
      }
    } else if (is_block(child)) {
      const child_result = get_possible_nested_siblings(child, direction, adjacent_only, seen2);
      add_to_map(child_result, result);
      if (adjacent_only && has_definite_elements(child_result)) {
        break;
      }
    }
    i = direction === FORWARD ? i + 1 : i - 1;
  }
  return result;
}
function is_block(node) {
  return node.type === "IfBlock" || node.type === "EachBlock" || node.type === "AwaitBlock" || node.type === "KeyBlock" || node.type === "SlotElement";
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/css/css-warn.js
function warn_unused(stylesheet) {
  walk(stylesheet, { stylesheet }, visitors2);
}
var visitors2 = {
  Atrule(node, context) {
    if (!is_keyframes_node(node)) {
      context.next();
    }
  },
  PseudoClassSelector(node, context) {
    if (node.name === "is" || node.name === "where") {
      context.next();
    }
  },
  ComplexSelector(node, context) {
    if (!node.metadata.used && // prevent double-marking of `.unused:is(.unused)`
    (context.path.at(-2)?.type !== "PseudoClassSelector" || /** @type {AST.CSS.ComplexSelector} */
    context.path.at(-4)?.metadata.used)) {
      const content = context.state.stylesheet.content;
      const text2 = content.styles.substring(node.start - content.start, node.end - content.start);
      css_unused_selector(node, text2);
    }
    context.next();
  },
  Rule(node, context) {
    if (node.metadata.is_global_block) {
      context.visit(node.prelude);
    } else {
      context.next();
    }
  }
};

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/function.js
function visit_function(node, context) {
  if (context.state.expression) {
    for (const [name] of context.state.scope.references) {
      const binding = context.state.scope.get(name);
      if (binding && binding.scope.function_depth < context.state.scope.function_depth) {
        context.state.expression.references.add(binding);
      }
    }
  }
  context.next({
    ...context.state,
    function_depth: context.state.function_depth + 1,
    expression: null
  });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ArrowFunctionExpression.js
function ArrowFunctionExpression(node, context) {
  visit_function(node, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/AssignmentExpression.js
function AssignmentExpression(node, context) {
  validate_assignment(node, node.left, context);
  if (context.state.reactive_statement) {
    const id2 = node.left.type === "MemberExpression" ? object2(node.left) : node.left;
    if (id2 !== null) {
      for (const id3 of extract_identifiers(node.left)) {
        const binding = context.state.scope.get(id3.name);
        if (binding) {
          context.state.reactive_statement.assignments.add(binding);
        }
      }
    }
  }
  if (context.state.expression) {
    context.state.expression.has_assignment = true;
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/AnimateDirective.js
function AnimateDirective(node, context) {
  context.next({ ...context.state, expression: node.metadata.expression });
  if (node.metadata.expression.has_await) {
    illegal_await_expression(node);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/fragment.js
function mark_subtree_dynamic(path) {
  let i = path.length;
  while (i--) {
    const node = path[i];
    if (node.type === "Fragment") {
      if (node.metadata.dynamic) return;
      node.metadata.dynamic = true;
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/AttachTag.js
function AttachTag(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
  if (node.metadata.expression.has_await) {
    illegal_await_expression(node);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/Attribute.js
function Attribute(node, context) {
  context.next();
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  if (parent.type === "RegularElement") {
    if (node.name === "value" && parent.name === "option") {
      mark_subtree_dynamic(context.path);
    }
  }
  if (is_event_attribute(node)) {
    mark_subtree_dynamic(context.path);
  }
  if (cannot_be_set_statically(node.name)) {
    mark_subtree_dynamic(context.path);
  }
  if (node.name === "class" && !Array.isArray(node.value) && node.value !== true && node.value.expression.type !== "Literal" && node.value.expression.type !== "TemplateLiteral" && node.value.expression.type !== "BinaryExpression") {
    mark_subtree_dynamic(context.path);
    node.metadata.needs_clsx = true;
  }
  if (node.value !== true) {
    for (const chunk of get_attribute_chunks(node.value)) {
      if (chunk.type !== "ExpressionTag") continue;
      if (chunk.expression.type === "FunctionExpression" || chunk.expression.type === "ArrowFunctionExpression") {
        continue;
      }
    }
    if (is_event_attribute(node)) {
      const parent2 = context.path.at(-1);
      if (parent2?.type === "RegularElement" || parent2?.type === "SvelteElement") {
        context.state.analysis.uses_event_attributes = true;
      }
      node.metadata.delegated = parent2?.type === "RegularElement" && can_delegate_event(node.name.slice(2));
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/AwaitBlock.js
function AwaitBlock(node, context) {
  validate_block_not_empty(node.pending, context);
  validate_block_not_empty(node.then, context);
  validate_block_not_empty(node.catch, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
    if (node.value) {
      const start = (
        /** @type {number} */
        node.value.start
      );
      const match = context.state.analysis.source.substring(start - 10, start).match(/{(\s*):then\s+$/);
      if (match && match[1] !== "") {
        block_unexpected_character({ start: start - 10, end: start }, ":");
      }
    }
    if (node.error) {
      const start = (
        /** @type {number} */
        node.error.start
      );
      const match = context.state.analysis.source.substring(start - 10, start).match(/{(\s*):catch\s+$/);
      if (match && match[1] !== "") {
        block_unexpected_character({ start: start - 10, end: start }, ":");
      }
    }
  }
  mark_subtree_dynamic(context.path);
  context.visit(node.expression, { ...context.state, expression: node.metadata.expression });
  if (node.pending) context.visit(node.pending);
  if (node.then) context.visit(node.then);
  if (node.catch) context.visit(node.catch);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/AwaitExpression.js
function AwaitExpression(node, context) {
  const tla = context.state.ast_type === "instance" && context.state.function_depth === 1;
  if (is_reactive_expression(
    context.path,
    context.state.derived_function_depth === context.state.function_depth
  ) && !is_last_evaluated_expression(context.path, node)) {
    context.state.analysis.pickled_awaits.add(node);
  }
  let suspend = tla;
  if (context.state.expression) {
    context.state.expression.has_await = true;
    suspend = true;
  }
  if (suspend) {
    if (!context.state.options.experimental.async) {
      experimental_async(node);
    }
    if (!context.state.analysis.runes) {
      legacy_await_invalid(node);
    }
  }
  context.next();
}
function is_reactive_expression(path, in_derived) {
  if (in_derived) return true;
  let i = path.length;
  while (i--) {
    const parent = path[i];
    if (parent.type === "ArrowFunctionExpression" || parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
      return false;
    }
    if (parent.metadata) {
      return true;
    }
  }
  return false;
}
function is_last_evaluated_expression(path, node) {
  let i = path.length;
  while (i--) {
    const parent = path[i];
    if (parent.type === "ConstTag") {
      return false;
    }
    if (parent.metadata) {
      return true;
    }
    switch (parent.type) {
      case "ArrayExpression":
        if (node !== parent.elements.at(-1)) return false;
        break;
      case "AssignmentExpression":
      case "BinaryExpression":
      case "LogicalExpression":
        if (node === parent.left) return false;
        break;
      case "CallExpression":
      case "NewExpression":
        if (node !== parent.arguments.at(-1)) return false;
        break;
      case "ConditionalExpression":
        if (node === parent.test) return false;
        break;
      case "MemberExpression":
        if (parent.computed && node === parent.object) return false;
        break;
      case "ObjectExpression":
        if (node !== parent.properties.at(-1)) return false;
        break;
      case "Property":
        if (node === parent.key) return false;
        break;
      case "SequenceExpression":
        if (node !== parent.expressions.at(-1)) return false;
        break;
      case "TaggedTemplateExpression":
        if (node !== parent.quasi.expressions.at(-1)) return false;
        break;
      case "TemplateLiteral":
        if (node !== parent.expressions.at(-1)) return false;
        break;
      case "VariableDeclarator":
        return true;
      default:
        return false;
    }
    node = parent;
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/bindings.js
var binding_properties = {
  // media
  currentTime: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  duration: {
    valid_elements: ["audio", "video"],
    event: "durationchange",
    omit_in_ssr: true
  },
  focused: {},
  paused: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  buffered: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  seekable: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  played: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  volume: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  muted: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  playbackRate: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  seeking: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  ended: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  readyState: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  // video
  videoHeight: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  videoWidth: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  // img
  naturalWidth: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  naturalHeight: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  // document
  activeElement: {
    valid_elements: ["svelte:document"],
    omit_in_ssr: true
  },
  fullscreenElement: {
    valid_elements: ["svelte:document"],
    event: "fullscreenchange",
    omit_in_ssr: true
  },
  pointerLockElement: {
    valid_elements: ["svelte:document"],
    event: "pointerlockchange",
    omit_in_ssr: true
  },
  visibilityState: {
    valid_elements: ["svelte:document"],
    event: "visibilitychange",
    omit_in_ssr: true
  },
  // window
  innerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  innerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  scrollX: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true,
    bidirectional: true
  },
  scrollY: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true,
    bidirectional: true
  },
  online: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  devicePixelRatio: {
    valid_elements: ["svelte:window"],
    event: "resize",
    omit_in_ssr: true
  },
  // dimensions
  clientWidth: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  clientHeight: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  offsetWidth: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  offsetHeight: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  contentRect: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  contentBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  borderBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  devicePixelContentBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  // checkbox/radio
  indeterminate: {
    event: "change",
    bidirectional: true,
    valid_elements: ["input"],
    omit_in_ssr: true
    // no corresponding attribute
  },
  checked: {
    valid_elements: ["input"],
    bidirectional: true
  },
  group: {
    valid_elements: ["input"],
    bidirectional: true
  },
  // various
  this: {
    omit_in_ssr: true
  },
  innerText: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  innerHTML: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  textContent: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  open: {
    event: "toggle",
    bidirectional: true,
    valid_elements: ["details"]
  },
  value: {
    valid_elements: ["input", "textarea", "select"],
    bidirectional: true
  },
  files: {
    valid_elements: ["input"],
    omit_in_ssr: true,
    bidirectional: true
  }
};

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/BindDirective.js
function BindDirective(node, context) {
  const parent = context.path.at(-1);
  if (parent?.type === "RegularElement" || parent?.type === "SvelteElement" || parent?.type === "SvelteWindow" || parent?.type === "SvelteDocument" || parent?.type === "SvelteBody") {
    if (node.name in binding_properties) {
      const property = binding_properties[node.name];
      if (property.valid_elements && !property.valid_elements.includes(parent.name)) {
        bind_invalid_target(
          node,
          node.name,
          property.valid_elements.map((valid_element) => `\`<${valid_element}>\``).join(", ")
        );
      }
      if (property.invalid_elements && property.invalid_elements.includes(parent.name)) {
        const valid_bindings = Object.entries(binding_properties).filter(([_2, binding_property]) => {
          return binding_property.valid_elements?.includes(parent.name) || !binding_property.valid_elements && !binding_property.invalid_elements?.includes(parent.name);
        }).map(([property_name]) => property_name).sort();
        bind_invalid_name(
          node,
          node.name,
          `Possible bindings for <${parent.name}> are ${valid_bindings.join(", ")}`
        );
      }
      if (parent.name === "input" && node.name !== "this") {
        const type = (
          /** @type {AST.Attribute | undefined} */
          parent.attributes.find((a) => a.type === "Attribute" && a.name === "type")
        );
        if (type && !is_text_attribute(type)) {
          if (node.name !== "value" || type.value === true) {
            attribute_invalid_type(type);
          }
        } else {
          if (node.name === "checked" && type?.value[0].data !== "checkbox") {
            bind_invalid_target(
              node,
              node.name,
              `\`<input type="checkbox">\`${type?.value[0].data === "radio" ? ` \u2014 for \`<input type="radio">\`, use \`bind:group\`` : ""}`
            );
          }
          if (node.name === "files" && type?.value[0].data !== "file") {
            bind_invalid_target(node, node.name, '`<input type="file">`');
          }
        }
      }
      if (parent.name === "select" && node.name !== "this") {
        const multiple = parent.attributes.find(
          (a) => a.type === "Attribute" && a.name === "multiple" && !is_text_attribute(a) && a.value !== true
        );
        if (multiple) {
          attribute_invalid_multiple(multiple);
        }
      }
      if (node.name === "offsetWidth" && is_svg(parent.name)) {
        bind_invalid_target(
          node,
          node.name,
          `non-\`<svg>\` elements. Use \`bind:clientWidth\` for \`<svg>\` instead`
        );
      }
      if (is_content_editable_binding(node.name)) {
        const contenteditable = (
          /** @type {AST.Attribute} */
          parent.attributes.find((a) => a.type === "Attribute" && a.name === "contenteditable")
        );
        if (!contenteditable) {
          attribute_contenteditable_missing(node);
        } else if (!is_text_attribute(contenteditable) && contenteditable.value !== true) {
          attribute_contenteditable_dynamic(contenteditable);
        }
      }
    } else {
      const match = fuzzymatch(node.name, Object.keys(binding_properties));
      if (match) {
        const property = binding_properties[match];
        if (!property.valid_elements || property.valid_elements.includes(parent.name)) {
          bind_invalid_name(node, node.name, `Did you mean '${match}'?`);
        }
      }
      bind_invalid_name(node, node.name);
    }
  }
  if (node.expression.type === "SequenceExpression") {
    if (node.name === "group") {
      bind_group_invalid_expression(node);
    }
    let i = (
      /** @type {number} */
      node.expression.start
    );
    let leading_comments_start = (
      /**@type {any}*/
      node.expression.leadingComments?.at(0)?.start
    );
    let leading_comments_end = (
      /**@type {any}*/
      node.expression.leadingComments?.at(-1)?.end
    );
    while (context.state.analysis.source[--i] !== "{") {
      if (context.state.analysis.source[i] === "(" && // if the parenthesis is in a leading comment we don't need to throw the error
      !(leading_comments_start && leading_comments_end && i <= leading_comments_end && i >= leading_comments_start)) {
        bind_invalid_parens(node, node.name);
      }
    }
    if (node.expression.expressions.length !== 2) {
      bind_invalid_expression(node);
    }
    mark_subtree_dynamic(context.path);
    const [get3, set2] = node.expression.expressions;
    context.visit(get3.type === "ArrowFunctionExpression" ? get3.body : get3, {
      ...context.state,
      expression: node.metadata.expression
    });
    context.visit(set2.type === "ArrowFunctionExpression" ? set2.body : set2, {
      ...context.state,
      expression: node.metadata.expression
    });
    if (node.metadata.expression.has_await) {
      illegal_await_expression(node);
    }
    return;
  }
  validate_assignment(node, node.expression, context);
  const assignee = node.expression;
  const left = object2(assignee);
  if (left === null) {
    bind_invalid_expression(node);
  }
  const binding = context.state.scope.get(left.name);
  node.metadata.binding = binding;
  if (assignee.type === "Identifier") {
    if (node.name !== "this" && // bind:this also works for regular variables
    (!binding || binding.kind !== "state" && binding.kind !== "raw_state" && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "each" && binding.kind !== "store_sub" && !binding.updated)) {
      bind_invalid_value(node.expression);
    }
  }
  if (node.name === "group") {
    if (!binding) {
      throw new Error("Cannot find declaration for bind:group");
    }
    if (binding.kind === "snippet") {
      bind_group_invalid_snippet_parameter(node);
    }
    const each_blocks = [];
    const [keypath, expression_ids] = extract_all_identifiers_from_expression(node.expression);
    let ids = expression_ids;
    let i = context.path.length;
    while (i--) {
      const parent2 = context.path[i];
      if (parent2.type === "EachBlock") {
        const references = ids.filter((id2) => parent2.metadata.declarations.has(id2.name));
        if (references.length > 0) {
          parent2.metadata.contains_group_binding = true;
          each_blocks.push(parent2);
          ids = ids.filter((id2) => !references.includes(id2));
          ids.push(...extract_all_identifiers_from_expression(parent2.expression)[1]);
        }
      }
    }
    const bindings = expression_ids.map((id2) => context.state.scope.get(id2.name));
    let group_name;
    outer: for (const [[key2, b], group] of context.state.analysis.binding_groups) {
      if (b.length !== bindings.length || key2 !== keypath) continue;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        if (bindings[i2] !== b[i2]) continue outer;
      }
      group_name = group;
    }
    if (!group_name) {
      group_name = context.state.scope.root.unique("binding_group");
      context.state.analysis.binding_groups.set([keypath, bindings], group_name);
    }
    node.metadata = {
      binding_group_name: group_name,
      parent_each_blocks: each_blocks,
      expression: node.metadata.expression
    };
  }
  if (binding?.kind === "each" && binding.metadata?.inside_rest) {
    bind_invalid_each_rest(binding.node, binding.node.name);
  }
  context.next({ ...context.state, expression: node.metadata.expression });
  if (node.metadata.expression.has_await) {
    illegal_await_expression(node);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/CallExpression.js
function CallExpression(node, context) {
  const parent = (
    /** @type {AST.SvelteNode} */
    get_parent(context.path, -1)
  );
  const rune = get_rune(node, context.state.scope);
  if (rune && rune !== "$inspect") {
    for (const arg of node.arguments) {
      if (arg.type === "SpreadElement") {
        rune_invalid_spread(node, rune);
      }
    }
  }
  switch (rune) {
    case null:
      if (!is_safe_identifier(node.callee, context.state.scope)) {
        context.state.analysis.needs_context = true;
      }
      break;
    case "$bindable":
      if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, "$bindable", "zero or one arguments");
      }
      if (parent.type !== "AssignmentPattern" || context.path.at(-3)?.type !== "ObjectPattern" || context.path.at(-4)?.type !== "VariableDeclarator" || get_rune(
        /** @type {VariableDeclarator} */
        context.path.at(-4).init,
        context.state.scope
      ) !== "$props") {
        bindable_invalid_location(node);
      }
      context.state.analysis.needs_context = true;
      break;
    case "$host":
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, "$host");
      } else if (context.state.ast_type === "module" || !context.state.analysis.custom_element) {
        host_invalid_placement(node);
      }
      break;
    case "$props":
      if (context.state.has_props_rune) {
        props_duplicate(node, rune);
      }
      context.state.has_props_rune = true;
      if (parent.type !== "VariableDeclarator" || context.state.ast_type !== "instance" || context.state.scope !== context.state.analysis.instance.scope) {
        props_invalid_placement(node);
      }
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, rune);
      }
      break;
    case "$props.id": {
      const grand_parent = get_parent(context.path, -2);
      if (context.state.analysis.props_id) {
        props_duplicate(node, rune);
      }
      if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier" || context.state.ast_type !== "instance" || context.state.scope !== context.state.analysis.instance.scope || grand_parent.type !== "VariableDeclaration") {
        props_id_invalid_placement(node);
      }
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, rune);
      }
      context.state.analysis.props_id = parent.id;
      break;
    }
    case "$state":
    case "$state.raw":
    case "$derived":
    case "$derived.by": {
      const valid2 = is_variable_declaration(parent, context) || is_class_property_definition(parent) || is_class_property_assignment_at_constructor_root(parent, context);
      if (!valid2) {
        state_invalid_placement(node, rune);
      }
      if ((rune === "$derived" || rune === "$derived.by") && node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      } else if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, rune, "zero or one arguments");
      }
      break;
    }
    case "$effect":
    case "$effect.pre":
      if (parent.type !== "ExpressionStatement") {
        effect_invalid_placement(node);
      }
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      context.state.analysis.needs_context = true;
      break;
    case "$effect.tracking":
      if (node.arguments.length !== 0) {
        rune_invalid_arguments(node, rune);
      }
      break;
    case "$effect.root":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$effect.pending":
      if (context.state.expression) {
        context.state.expression.has_state = true;
      }
      break;
    case "$inspect":
      if (node.arguments.length < 1) {
        rune_invalid_arguments_length(node, rune, "one or more arguments");
      }
      break;
    case "$inspect().with":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$inspect.trace": {
      if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, rune, "zero or one arguments");
      }
      const grand_parent = context.path.at(-2);
      const fn = context.path.at(-3);
      if (parent.type !== "ExpressionStatement" || grand_parent?.type !== "BlockStatement" || !(fn?.type === "FunctionDeclaration" || fn?.type === "FunctionExpression" || fn?.type === "ArrowFunctionExpression") || grand_parent.body[0] !== parent) {
        inspect_trace_invalid_placement(node);
      }
      if (fn.generator) {
        inspect_trace_generator(node);
      }
      if (dev) {
        if (node.arguments[0]) {
          context.state.scope.tracing = thunk(
            /** @type {Expression} */
            node.arguments[0]
          );
        } else {
          const label = get_function_label(context.path.slice(0, -2)) ?? "trace";
          const loc = `(${locate_node(fn)})`;
          context.state.scope.tracing = thunk(literal2(label + " " + loc));
        }
        context.state.analysis.tracing = true;
      }
      break;
    }
    case "$state.eager":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$state.snapshot":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
  }
  if (rune === "$derived") {
    const expression = new ExpressionMetadata();
    context.next({
      ...context.state,
      function_depth: context.state.function_depth + 1,
      derived_function_depth: context.state.function_depth + 1,
      expression
    });
    if (expression.has_await) {
      context.state.analysis.async_deriveds.add(node);
    }
  } else if (rune === "$inspect") {
    context.next({ ...context.state, function_depth: context.state.function_depth + 1 });
  } else {
    context.next();
  }
  if (context.state.expression) {
    if (!is_pure(node.callee, context) || context.state.expression.dependencies.size > 0) {
      context.state.expression.has_call = true;
      context.state.expression.has_state = true;
    }
  }
}
function get_function_label(nodes) {
  const fn = (
    /** @type {FunctionExpression | FunctionDeclaration | ArrowFunctionExpression} */
    nodes.at(-1)
  );
  if ((fn.type === "FunctionDeclaration" || fn.type === "FunctionExpression") && fn.id != null) {
    return fn.id.name;
  }
  const parent = nodes.at(-2);
  if (!parent) return;
  if (parent.type === "CallExpression") {
    return source.slice(parent.callee.start, parent.callee.end) + "(...)";
  }
  if (parent.type === "Property" && !parent.computed) {
    return (
      /** @type {Identifier} */
      parent.key.name
    );
  }
  if (parent.type === "VariableDeclarator" && parent.id.type === "Identifier") {
    return parent.id.name;
  }
}
function is_variable_declaration(parent, context) {
  return parent.type === "VariableDeclarator" && get_parent(context.path, -3).type !== "ConstTag";
}
function is_class_property_definition(parent) {
  return parent.type === "PropertyDefinition" && !parent.static && !parent.computed;
}
function is_class_property_assignment_at_constructor_root(node, context) {
  if (node.type === "AssignmentExpression" && node.operator === "=" && node.left.type === "MemberExpression" && node.left.object.type === "ThisExpression" && (node.left.property.type === "Identifier" && !node.left.computed || node.left.property.type === "PrivateIdentifier" || node.left.property.type === "Literal")) {
    const parent = get_parent(context.path, -5);
    return parent?.type === "MethodDefinition" && parent.kind === "constructor";
  }
  return false;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassBody.js
function ClassBody(node, context) {
  if (!context.state.analysis.runes) {
    context.next();
    return;
  }
  const private_ids = [];
  for (const prop2 of node.body) {
    if ((prop2.type === "MethodDefinition" || prop2.type === "PropertyDefinition") && prop2.key.type === "PrivateIdentifier") {
      private_ids.push(prop2.key.name);
    }
  }
  const state_fields = /* @__PURE__ */ new Map();
  const fields = /* @__PURE__ */ new Map();
  context.state.analysis.classes.set(node, state_fields);
  let constructor = null;
  function handle(node2, key2, value) {
    const name = get_name(key2);
    if (name === null) return;
    const rune = get_rune(value, context.state.scope);
    if (rune && is_state_creation_rune(rune)) {
      if (state_fields.has(name)) {
        state_field_duplicate(node2, name);
      }
      const _key = (node2.type === "AssignmentExpression" || !node2.static ? "" : "@") + name;
      const field = fields.get(_key);
      if (field && !(field.length === 1 && field[0] === "prop")) {
        duplicate_class_field(node2, _key);
      }
      state_fields.set(name, {
        node: node2,
        type: rune,
        // @ts-expect-error for public state this is filled out in a moment
        key: key2.type === "PrivateIdentifier" ? key2 : null,
        value: (
          /** @type {CallExpression} */
          value
        )
      });
    }
  }
  for (const child of node.body) {
    if (child.type === "PropertyDefinition" && !child.computed && !child.static) {
      handle(child, child.key, child.value);
      const key2 = (
        /** @type {string} */
        get_name(child.key)
      );
      const field = fields.get(key2);
      if (!field) {
        fields.set(key2, [child.value ? "assigned_prop" : "prop"]);
        continue;
      }
      duplicate_class_field(child, key2);
    }
    if (child.type === "MethodDefinition") {
      if (child.kind === "constructor") {
        constructor = child;
      } else if (!child.computed) {
        const key2 = (child.static ? "@" : "") + get_name(child.key);
        const field = fields.get(key2);
        if (!field) {
          fields.set(key2, [child.kind]);
          continue;
        }
        if (field.includes(child.kind) || field.includes("prop") || field.includes("assigned_prop")) {
          duplicate_class_field(child, key2);
        }
        if (child.kind === "get") {
          if (field.length === 1 && field[0] === "set") {
            field.push("get");
            continue;
          }
        } else if (child.kind === "set") {
          if (field.length === 1 && field[0] === "get") {
            field.push("set");
            continue;
          }
        } else {
          field.push(child.kind);
          continue;
        }
        duplicate_class_field(child, key2);
      }
    }
  }
  if (constructor) {
    for (const statement of constructor.value.body.body) {
      if (statement.type !== "ExpressionStatement") continue;
      if (statement.expression.type !== "AssignmentExpression") continue;
      const { left, right } = statement.expression;
      if (left.type !== "MemberExpression") continue;
      if (left.object.type !== "ThisExpression") continue;
      if (left.computed && left.property.type !== "Literal") continue;
      handle(statement.expression, left.property, right);
    }
  }
  for (const [name, field] of state_fields) {
    if (name[0] === "#") {
      continue;
    }
    let deconflicted = name.replace(regex_invalid_identifier_chars, "_");
    while (private_ids.includes(deconflicted)) {
      deconflicted = "_" + deconflicted;
    }
    private_ids.push(deconflicted);
    field.key = private_id(deconflicted);
  }
  context.next({ ...context.state, state_fields });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassDeclaration.js
function ClassDeclaration(node, context) {
  if (context.state.analysis.runes && node.id !== null) {
    validate_identifier_name(context.state.scope.get(node.id.name));
  }
  const allowed_depth = context.state.ast_type === "module" ? 0 : 1;
  if (context.state.scope.function_depth > allowed_depth) {
    perf_avoid_nested_class(node);
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassDirective.js
function ClassDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/attribute.js
function validate_attribute_name(attribute) {
  if (attribute.name.includes(":") && !attribute.name.startsWith("xmlns:") && !attribute.name.startsWith("xlink:") && !attribute.name.startsWith("xml:")) {
    attribute_illegal_colon(attribute);
  }
}
function validate_attribute(attribute, parent) {
  if (Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "ExpressionTag" && (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf" || parent.type === "RegularElement" && is_custom_element_node(parent))) {
    attribute_quoted(attribute);
  }
  if (attribute.value === true || !Array.isArray(attribute.value) || attribute.value.length === 1) {
    return;
  }
  const is_quoted = attribute.value.at(-1)?.end !== attribute.end;
  if (!is_quoted) {
    attribute_unquoted_sequence(attribute);
  }
}
function validate_slot_attribute(context, attribute, is_component = false) {
  const parent = context.path.at(-2);
  let owner = void 0;
  if (parent?.type === "SnippetBlock") {
    if (!is_text_attribute(attribute)) {
      slot_attribute_invalid(attribute);
    }
    return;
  }
  let i = context.path.length;
  while (i--) {
    const ancestor = context.path[i];
    if (!owner && (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteSelf" || ancestor.type === "SvelteElement" || ancestor.type === "RegularElement" && is_custom_element_node(ancestor))) {
      owner = ancestor;
    }
  }
  if (owner) {
    if (owner.type === "Component" || owner.type === "SvelteComponent" || owner.type === "SvelteSelf") {
      if (owner !== parent) {
        if (!is_component) {
          slot_attribute_invalid_placement(attribute);
        }
      } else {
        if (!is_text_attribute(attribute)) {
          slot_attribute_invalid(attribute);
        }
        const name = attribute.value[0].data;
        if (context.state.component_slots.has(name)) {
          slot_attribute_duplicate(attribute, name, owner.name);
        }
        context.state.component_slots.add(name);
        if (name === "default") {
          for (const node of owner.fragment.nodes) {
            if (node.type === "Text" && regex_only_whitespaces.test(node.data)) {
              continue;
            }
            if (node.type === "RegularElement" || node.type === "SvelteFragment") {
              if (node.attributes.some((a) => a.type === "Attribute" && a.name === "slot")) {
                continue;
              }
            }
            slot_default_duplicate(node);
          }
        }
      }
    }
  } else if (!is_component) {
    slot_attribute_invalid_placement(attribute);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/snippets.js
function is_resolved_snippet(binding) {
  return !binding || binding.declaration_kind === "import" || binding.kind === "prop" || binding.kind === "rest_prop" || binding.kind === "bindable_prop" || binding?.initial?.type === "SnippetBlock";
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/component.js
function visit_component(node, context) {
  node.metadata.path = [...context.path];
  node.metadata.snippets = /* @__PURE__ */ new Set();
  let resolved = true;
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "BindDirective") {
      resolved = false;
      continue;
    }
    if (attribute.type !== "Attribute" || !is_expression_attribute(attribute)) {
      continue;
    }
    const expression = get_attribute_expression(attribute);
    if (expression.type === "Identifier") {
      const binding = context.state.scope.get(expression.name);
      resolved &&= is_resolved_snippet(binding);
      if (binding?.initial?.type === "SnippetBlock") {
        node.metadata.snippets.add(binding.initial);
      }
    } else if (expression.type !== "Literal") {
      resolved = false;
    }
  }
  if (resolved) {
    for (const child of node.fragment.nodes) {
      if (child.type === "SnippetBlock") {
        node.metadata.snippets.add(child);
      }
    }
  }
  context.state.analysis.snippet_renderers.set(node, resolved);
  mark_subtree_dynamic(context.path);
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" && attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective" && attribute.type !== "OnDirective" && attribute.type !== "BindDirective" && attribute.type !== "AttachTag") {
      component_invalid_directive(attribute);
    }
    if (attribute.type === "OnDirective" && (attribute.modifiers.length > 1 || attribute.modifiers.some((m) => m !== "once"))) {
      event_handler_invalid_component_modifier(attribute);
    }
    if (attribute.type === "Attribute") {
      if (context.state.analysis.runes) {
        validate_attribute(attribute, node);
        if (is_expression_attribute(attribute)) {
          disallow_unparenthesized_sequences(
            get_attribute_expression(attribute),
            context.state.analysis.source
          );
        }
      }
      validate_attribute_name(attribute);
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute, true);
      }
    }
    if (attribute.type === "BindDirective" && attribute.name !== "this") {
      context.state.analysis.uses_component_bindings = true;
    }
    if (attribute.type === "AttachTag") {
      disallow_unparenthesized_sequences(attribute.expression, context.state.analysis.source);
    }
  }
  const default_state = determine_slot(node) ? context.state : { ...context.state, scope: node.metadata.scopes.default };
  for (const attribute of node.attributes) {
    context.visit(attribute, attribute.type === "LetDirective" ? default_state : context.state);
  }
  let comments = [];
  const nodes = { default: [] };
  for (const child of node.fragment.nodes) {
    if (child.type === "Comment") {
      comments.push(child);
      continue;
    }
    const slot_name = determine_slot(child) ?? "default";
    (nodes[slot_name] ??= []).push(...comments, child);
    if (slot_name !== "default") comments = [];
  }
  const component_slots = /* @__PURE__ */ new Set();
  for (const slot_name in nodes) {
    const state = {
      ...context.state,
      scope: node.metadata.scopes[slot_name],
      parent_element: null,
      component_slots
    };
    context.visit({ ...node.fragment, nodes: nodes[slot_name] }, state);
  }
}
function disallow_unparenthesized_sequences(expression, source2) {
  if (expression.type === "SequenceExpression") {
    let i = (
      /** @type {number} */
      expression.start
    );
    while (--i > 0) {
      const char = source2[i];
      if (char === "(") break;
      if (char === "{") attribute_invalid_sequence_expression(expression);
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/Component.js
function Component(node, context) {
  const binding = context.state.scope.get(
    node.name.includes(".") ? node.name.slice(0, node.name.indexOf(".")) : node.name
  );
  node.metadata.dynamic = context.state.analysis.runes && // Svelte 4 required you to use svelte:component to switch components
  binding !== null && (binding.kind !== "normal" || node.name.includes("."));
  if (binding) {
    node.metadata.expression.has_state = node.metadata.dynamic;
    node.metadata.expression.dependencies.add(binding);
    node.metadata.expression.references.add(binding);
  }
  visit_component(node, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ConstTag.js
function ConstTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  const parent = context.path.at(-1);
  const grand_parent = context.path.at(-2);
  if (parent?.type !== "Fragment" || grand_parent?.type !== "IfBlock" && grand_parent?.type !== "SvelteFragment" && grand_parent?.type !== "Component" && grand_parent?.type !== "SvelteComponent" && grand_parent?.type !== "EachBlock" && grand_parent?.type !== "AwaitBlock" && grand_parent?.type !== "SnippetBlock" && grand_parent?.type !== "SvelteBoundary" && grand_parent?.type !== "KeyBlock" && (grand_parent?.type !== "RegularElement" && grand_parent?.type !== "SvelteElement" || !grand_parent.attributes.some((a) => a.type === "Attribute" && a.name === "slot"))) {
    const_tag_invalid_placement(node);
  }
  const declaration2 = node.declaration.declarations[0];
  context.visit(declaration2.id);
  context.visit(declaration2.init, {
    ...context.state,
    expression: node.metadata.expression,
    // We're treating this like a $derived under the hood
    function_depth: context.state.function_depth + 1,
    derived_function_depth: context.state.function_depth + 1
  });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/DebugTag.js
function DebugTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/EachBlock.js
function EachBlock(node, context) {
  validate_opening_tag(node, context.state, "#");
  validate_block_not_empty(node.body, context);
  validate_block_not_empty(node.fallback, context);
  const id2 = node.context;
  if (id2?.type === "Identifier" && (id2.name === "$state" || id2.name === "$derived")) {
    state_invalid_placement(node, id2.name);
  }
  if (node.key) {
    node.metadata.keyed = node.key.type !== "Identifier" || !node.index || node.key.name !== node.index;
  }
  if (node.metadata.keyed && !node.context) {
    each_key_without_as(
      /** @type {Expression} */
      node.key
    );
  }
  context.visit(node.expression, {
    ...context.state,
    expression: node.metadata.expression,
    scope: (
      /** @type {Scope} */
      context.state.scope.parent
    )
  });
  context.visit(node.body);
  if (node.key) context.visit(node.key);
  if (node.fallback) context.visit(node.fallback);
  if (!context.state.analysis.runes) {
    let mutated = !!node.context && extract_identifiers(node.context).some((id3) => {
      const binding = context.state.scope.get(id3.name);
      return !!binding?.mutated;
    });
    for (const binding of node.metadata.expression.dependencies) {
      collect_transitive_dependencies(binding, node.metadata.transitive_deps);
    }
    if (mutated) {
      for (const binding of node.metadata.transitive_deps) {
        if (binding.kind === "normal" && (binding.declaration_kind === "const" || binding.declaration_kind === "let" || binding.declaration_kind === "var")) {
          binding.kind = "state";
        }
      }
    }
  }
  mark_subtree_dynamic(context.path);
}
function collect_transitive_dependencies(binding, bindings) {
  if (bindings.has(binding)) {
    return;
  }
  bindings.add(binding);
  if (binding.kind === "legacy_reactive") {
    for (const dep of binding.legacy_dependencies) {
      collect_transitive_dependencies(dep, bindings);
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportDefaultDeclaration.js
function ExportDefaultDeclaration(node, context) {
  if (!context.state.ast_type) {
    if (node.declaration.type === "Identifier") {
      validate_export(node, context.state.scope, node.declaration.name);
    }
  } else {
    module_illegal_default_export(node);
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportNamedDeclaration.js
function ExportNamedDeclaration(node, context) {
  context.next();
  if (context.state.ast_type && node.specifiers.some(
    (specifier) => specifier.exported.type === "Identifier" ? specifier.exported.name === "default" : specifier.exported.value === "default"
  )) {
    module_illegal_default_export(node);
  }
  if (node.declaration?.type === "VariableDeclaration") {
    if (context.state.analysis.runes && context.state.ast_type === "instance" && node.declaration.kind === "let") {
      legacy_export_invalid(node);
    }
    for (const declarator2 of node.declaration.declarations) {
      for (const id2 of extract_identifiers(declarator2.id)) {
        const binding = context.state.scope.get(id2.name);
        if (!binding) continue;
        if (binding.kind === "derived") {
          derived_invalid_export(node);
        }
        if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
          state_invalid_export(node);
        }
      }
    }
  }
  if (context.state.analysis.runes) {
    if (node.declaration && context.state.ast_type === "instance") {
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        context.state.analysis.exports.push({
          name: (
            /** @type {Identifier} */
            node.declaration.id.name
          ),
          alias: null
        });
      } else if (node.declaration.kind === "const") {
        for (const declarator2 of node.declaration.declarations) {
          for (const node2 of extract_identifiers(declarator2.id)) {
            context.state.analysis.exports.push({ name: node2.name, alias: null });
          }
        }
      }
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportSpecifier.js
function ExportSpecifier(node, context) {
  const local_name = node.local.type === "Identifier" ? node.local.name : (
    /** @type {string} */
    node.local.value
  );
  const exported_name = node.exported.type === "Identifier" ? node.exported.name : (
    /** @type {string} */
    node.exported.value
  );
  if (context.state.ast_type === "instance") {
    if (context.state.analysis.runes) {
      context.state.analysis.exports.push({
        name: local_name,
        alias: exported_name
      });
      const binding = context.state.scope.get(local_name);
      if (binding) binding.reassigned = true;
    }
  } else {
    validate_export(node, context.state.scope, local_name);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExpressionStatement.js
function ExpressionStatement(node, context) {
  if (node.expression.type === "NewExpression" && node.expression.callee.type === "Identifier" && node.expression.arguments.length === 1 && node.expression.arguments[0].type === "ObjectExpression" && node.expression.arguments[0].properties.some(
    (p) => p.type === "Property" && p.key.type === "Identifier" && p.key.name === "target"
  )) {
    const binding = context.state.scope.get(node.expression.callee.name);
    if (binding?.kind === "normal" && binding.declaration_kind === "import") {
      const declaration2 = (
        /** @type {ImportDeclaration} */
        binding.initial
      );
      if (
        /** @type {string} */
        declaration2.source.value.endsWith(".svelte") && declaration2.specifiers.find(
          (s) => s.local.name === binding.node.name && s.type === "ImportDefaultSpecifier"
        )
      ) {
        legacy_component_creation(node.expression);
      }
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExpressionTag.js
function ExpressionTag(node, context) {
  const in_template = context.path.at(-1)?.type === "Fragment";
  if (in_template && context.state.parent_element) {
    const message = is_tag_valid_with_parent("#text", context.state.parent_element);
    if (message) {
      node_invalid_placement(node, message);
    }
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/Fragment.js
function Fragment(node, context) {
  context.next({ ...context.state, fragment: node });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/FunctionDeclaration.js
function FunctionDeclaration(node, context) {
  if (context.state.analysis.runes && node.id !== null) {
    validate_identifier_name(context.state.scope.get(node.id.name));
  }
  visit_function(node, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/FunctionExpression.js
function FunctionExpression(node, context) {
  visit_function(node, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/HtmlTag.js
function HtmlTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/utils.js
function is_state_source(binding, analysis) {
  return (binding.kind === "state" || binding.kind === "raw_state") && (!analysis.immutable || binding.reassigned || analysis.accessors);
}
function build_getter(node, state) {
  if (Object.hasOwn(state.transform, node.name)) {
    const binding = state.scope.get(node.name);
    if (node !== binding?.node) {
      return state.transform[node.name].read(node);
    }
  }
  return node;
}
function get_prop_source(binding, state, name, initial) {
  const args = [id("$$props"), literal2(name)];
  let flags = 0;
  if (binding.kind === "bindable_prop") {
    flags |= PROPS_IS_BINDABLE;
  }
  if (state.analysis.immutable) {
    flags |= PROPS_IS_IMMUTABLE;
  }
  if (state.analysis.runes) {
    flags |= PROPS_IS_RUNES;
  }
  if (state.analysis.accessors || (state.analysis.immutable ? binding.reassigned || state.analysis.runes && binding.mutated : binding.updated)) {
    flags |= PROPS_IS_UPDATED;
  }
  let arg;
  if (initial) {
    if (is_simple_expression(initial)) {
      arg = initial;
    } else {
      if (initial.type === "CallExpression" && initial.callee.type === "Identifier" && initial.arguments.length === 0) {
        arg = initial.callee;
      } else {
        arg = thunk(initial);
      }
      flags |= PROPS_IS_LAZY_INITIAL;
    }
  }
  if (flags || arg) {
    args.push(literal2(flags));
    if (arg) args.push(arg);
  }
  return call("$.prop", ...args);
}
function is_prop_source(binding, state) {
  return (binding.kind === "prop" || binding.kind === "bindable_prop") && (!state.analysis.runes || state.analysis.accessors || binding.reassigned || binding.initial || // Until legacy mode is gone, we also need to use the prop source when only mutated is true,
  // because the parent could be a legacy component which needs coarse-grained reactivity
  binding.updated);
}
function should_proxy(node, scope) {
  if (!node || node.type === "Literal" || node.type === "TemplateLiteral" || node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "UnaryExpression" || node.type === "BinaryExpression" || node.type === "Identifier" && node.name === "undefined") {
    return false;
  }
  if (node.type === "Identifier" && scope !== null) {
    const binding = scope.get(node.name);
    if (binding !== null && !binding.reassigned && binding.initial !== null && binding.initial.type !== "FunctionDeclaration" && binding.initial.type !== "ClassDeclaration" && binding.initial.type !== "ImportDeclaration" && binding.initial.type !== "EachBlock" && binding.initial.type !== "SnippetBlock") {
      return should_proxy(binding.initial, null);
    }
  }
  return true;
}
function create_derived(state, expression, async = false) {
  const thunk2 = thunk(expression, async);
  if (async) {
    return save(call("$.async_derived", thunk2));
  } else {
    return call(state.analysis.runes ? "$.derived" : "$.derived_safe_equal", thunk2);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/Identifier.js
function Identifier(node, context) {
  let i = context.path.length;
  let parent = (
    /** @type {Expression} */
    context.path[--i]
  );
  if (!is_reference(node, parent)) {
    return;
  }
  mark_subtree_dynamic(context.path);
  if (node.name === "arguments" && !context.path.some((n2) => n2.type === "FunctionDeclaration" || n2.type === "FunctionExpression")) {
    invalid_arguments_usage(node);
  }
  if (node.name === "$$slots") {
    context.state.analysis.uses_slots = true;
  }
  if (context.state.analysis.runes) {
    if (is_rune(node.name) && context.state.scope.get(node.name) === null && context.state.scope.get(node.name.slice(1))?.kind !== "store_sub") {
      let current2 = node;
      let name = node.name;
      while (parent.type === "MemberExpression") {
        if (parent.computed) rune_invalid_computed_property(parent);
        name += `.${/** @type {Identifier} */
        parent.property.name}`;
        current2 = parent;
        parent = /** @type {Expression} */
        context.path[--i];
        if (!is_rune(name)) {
          if (name === "$effect.active") {
            rune_renamed(parent, "$effect.active", "$effect.tracking");
          }
          if (name === "$state.frozen") {
            rune_renamed(parent, "$state.frozen", "$state.raw");
          }
          if (name === "$state.is") {
            rune_removed(parent, "$state.is");
          }
          rune_invalid_name(parent, name);
        }
      }
      if (parent.type !== "CallExpression") {
        rune_missing_parentheses(current2);
      }
    }
  }
  let binding = context.state.scope.get(node.name);
  if (!context.state.analysis.runes) {
    if (node.name === "$$props") {
      context.state.analysis.uses_props = true;
    }
    if (node.name === "$$restProps") {
      context.state.analysis.uses_rest_props = true;
    }
  }
  if (binding) {
    if (context.state.expression) {
      context.state.expression.dependencies.add(binding);
      context.state.expression.references.add(binding);
      context.state.expression.has_state ||= binding.kind !== "static" && (binding.kind === "prop" || binding.kind === "bindable_prop" || binding.kind === "rest_prop" || !binding.is_function()) && !context.state.scope.evaluate(node).is_known;
    }
    if (context.state.analysis.runes && node !== binding.node && context.state.function_depth === binding.scope.function_depth && // If we have $state that can be proxied or frozen and isn't re-assigned, then that means
    // it's likely not using a primitive value and thus this warning isn't that helpful.
    (binding.kind === "state" && (binding.reassigned || binding.initial?.type === "CallExpression" && binding.initial.arguments.length === 1 && binding.initial.arguments[0].type !== "SpreadElement" && !should_proxy(binding.initial.arguments[0], context.state.scope)) || binding.kind === "raw_state" || binding.kind === "derived") && // We're only concerned with reads here
    (parent.type !== "AssignmentExpression" || parent.left !== node) && parent.type !== "UpdateExpression") {
      let type = "closure";
      let i2 = context.path.length;
      while (i2--) {
        const parent2 = context.path[i2];
        if (parent2.type === "ArrowFunctionExpression" || parent2.type === "FunctionDeclaration" || parent2.type === "FunctionExpression") {
          break;
        }
        if (parent2.type === "CallExpression" && parent2.arguments.includes(
          /** @type {any} */
          context.path[i2 + 1]
        )) {
          const rune = get_rune(parent2, context.state.scope);
          if (rune === "$state" || rune === "$state.raw") {
            type = "derived";
            break;
          }
        }
      }
      state_referenced_locally(node, node.name, type);
    }
    if (context.state.reactive_statement && binding.scope === context.state.analysis.module.scope && binding.reassigned) {
      reactive_declaration_module_script_dependency(node);
    }
    if (binding.metadata?.is_template_declaration && context.state.options.experimental.async) {
      let snippet_name;
      for (let i2 = context.path.length - 1; i2 >= 0; i2--) {
        const parent2 = context.path[i2];
        const grand_parent = context.path[i2 - 1];
        if (parent2.type === "SnippetBlock") {
          snippet_name = parent2.expression.name;
        } else if (snippet_name && grand_parent && parent2.type === "Fragment" && (is_component_node(grand_parent) || grand_parent.type === "SvelteBoundary" && (snippet_name === "failed" || snippet_name === "pending"))) {
          if (is_component_node(grand_parent) ? grand_parent.metadata.scopes.default === binding.scope : context.state.scopes.get(parent2) === binding.scope) {
            const_tag_invalid_reference(node, node.name);
          } else {
            break;
          }
        }
      }
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/IfBlock.js
function IfBlock(node, context) {
  validate_block_not_empty(node.consequent, context);
  validate_block_not_empty(node.alternate, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, node.elseif ? ":" : "#");
  }
  mark_subtree_dynamic(context.path);
  context.visit(node.test, {
    ...context.state,
    expression: node.metadata.expression
  });
  context.visit(node.consequent);
  if (node.alternate) context.visit(node.alternate);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/ImportDeclaration.js
function ImportDeclaration(node, context) {
  if (context.state.analysis.runes) {
    const source2 = (
      /** @type {string} */
      node.source.value
    );
    if (source2.startsWith("svelte/internal")) {
      import_svelte_internal_forbidden(node);
    }
    if (source2 === "svelte") {
      for (const specifier of node.specifiers) {
        if (specifier.type === "ImportSpecifier") {
          if (specifier.imported.type === "Identifier" && (specifier.imported.name === "beforeUpdate" || specifier.imported.name === "afterUpdate")) {
            runes_mode_invalid_import(specifier, specifier.imported.name);
          }
        }
      }
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/KeyBlock.js
function KeyBlock(node, context) {
  validate_block_not_empty(node.fragment, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
  }
  mark_subtree_dynamic(context.path);
  context.visit(node.expression, { ...context.state, expression: node.metadata.expression });
  context.visit(node.fragment);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/LabeledStatement.js
function LabeledStatement(node, context) {
  if (node.label.name === "$") {
    const parent = (
      /** @type {AST.SvelteNode} */
      context.path.at(-1)
    );
    const is_reactive_statement = context.state.ast_type === "instance" && parent.type === "Program";
    if (is_reactive_statement) {
      if (context.state.analysis.runes) {
        legacy_reactive_statement_invalid(node);
      }
      const reactive_statement = {
        assignments: /* @__PURE__ */ new Set(),
        dependencies: []
      };
      context.next({
        ...context.state,
        reactive_statement,
        function_depth: context.state.scope.function_depth + 1
      });
      for (const [name, nodes] of context.state.scope.references) {
        const binding = context.state.scope.get(name);
        if (binding === null) continue;
        for (const { node: node2, path } of nodes) {
          let left = node2;
          let i = path.length - 1;
          let parent2 = (
            /** @type {Expression} */
            path.at(i)
          );
          while (parent2.type === "MemberExpression") {
            left = parent2;
            parent2 = /** @type {Expression} */
            path.at(--i);
          }
          if (parent2.type === "AssignmentExpression" && parent2.operator === "=" && parent2.left === left) {
            continue;
          }
          reactive_statement.dependencies.push(binding);
          break;
        }
      }
      context.state.analysis.reactive_statements.set(node, reactive_statement);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        let ids = extract_identifiers(node.body.expression.left);
        if (node.body.expression.left.type === "MemberExpression") {
          const id2 = object2(node.body.expression.left);
          if (id2 !== null) {
            ids = [id2];
          }
        }
        for (const id2 of ids) {
          const binding = context.state.scope.get(id2.name);
          if (binding?.kind === "legacy_reactive") {
            binding.legacy_dependencies = Array.from(reactive_statement.dependencies);
          }
        }
      }
    } else if (!context.state.analysis.runes) {
      reactive_declaration_invalid_placement(node);
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/LetDirective.js
function LetDirective(node, context) {
  const parent = context.path.at(-1);
  if (parent === void 0 || parent.type !== "Component" && parent.type !== "RegularElement" && parent.type !== "SlotElement" && parent.type !== "SvelteElement" && parent.type !== "SvelteComponent" && parent.type !== "SvelteSelf" && parent.type !== "SvelteFragment") {
    let_directive_invalid_placement(node);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/Literal.js
function Literal(node) {
  if (typeof node.value === "string") {
    if (regex_bidirectional_control_characters.test(node.value)) {
      bidirectional_control_characters(node);
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/MemberExpression.js
function MemberExpression(node, context) {
  if (node.object.type === "Identifier" && node.property.type === "Identifier") {
    const binding = context.state.scope.get(node.object.name);
    if (binding?.kind === "rest_prop" && node.property.name.startsWith("$$")) {
      props_illegal_name(node.property);
    }
  }
  if (context.state.expression) {
    context.state.expression.has_member_expression = true;
    context.state.expression.has_state ||= !is_pure(node, context);
  }
  if (!is_safe_identifier(node, context.state.scope)) {
    context.state.analysis.needs_context = true;
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/NewExpression.js
function NewExpression(node, context) {
  if (node.callee.type === "ClassExpression" && context.state.scope.function_depth > 0) {
    perf_avoid_inline_class(node);
  }
  context.state.analysis.needs_context = true;
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/OnDirective.js
function OnDirective(node, context) {
  if (context.state.analysis.runes) {
    const parent_type = context.path.at(-1)?.type;
    if (parent_type === "RegularElement" || parent_type === "SvelteElement") {
      event_directive_deprecated(node, node.name);
    }
  }
  const parent = context.path.at(-1);
  if (parent?.type === "SvelteElement" || parent?.type === "RegularElement") {
    context.state.analysis.event_directive_node ??= node;
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/PropertyDefinition.js
function PropertyDefinition(node, context) {
  const name = get_name(node.key);
  const field = name && context.state.state_fields.get(name);
  if (field && node !== field.node && node.value) {
    if (
      /** @type {number} */
      node.start < /** @type {number} */
      field.node.start
    ) {
      state_field_invalid_assignment(node);
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/a11y/constants.js
var import_aria_query = __toESM(require_lib(), 1);
var import_axobject_query = __toESM(require_lib2(), 1);
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(
  " "
);
var a11y_required_attributes = {
  a: ["href"],
  area: ["alt", "aria-label", "aria-labelledby"],
  // html-has-lang
  html: ["lang"],
  // iframe-has-title
  iframe: ["title"],
  img: ["alt"],
  object: ["title", "aria-label", "aria-labelledby"]
};
var a11y_distracting_elements2 = ["blink", "marquee"];
var a11y_required_content = [
  // heading-has-content
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6"
];
var a11y_labelable = [
  "button",
  "input",
  "keygen",
  "meter",
  "output",
  "progress",
  "select",
  "textarea"
];
var a11y_interactive_handlers = [
  // Keyboard events
  "keypress",
  "keydown",
  "keyup",
  // Click events
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragenter",
  "dragexit",
  "dragleave",
  "dragover",
  "dragstart",
  "drop",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup"
];
var a11y_recommended_interactive_handlers = [
  "click",
  "mousedown",
  "mouseup",
  "keypress",
  "keydown",
  "keyup"
];
var a11y_nested_implicit_semantics = /* @__PURE__ */ new Map([
  ["header", "banner"],
  ["footer", "contentinfo"]
]);
var a11y_implicit_semantics = /* @__PURE__ */ new Map([
  ["a", "link"],
  ["area", "link"],
  ["article", "article"],
  ["aside", "complementary"],
  ["body", "document"],
  ["button", "button"],
  ["datalist", "listbox"],
  ["dd", "definition"],
  ["dfn", "term"],
  ["dialog", "dialog"],
  ["details", "group"],
  ["dt", "term"],
  ["fieldset", "group"],
  ["figure", "figure"],
  ["form", "form"],
  ["h1", "heading"],
  ["h2", "heading"],
  ["h3", "heading"],
  ["h4", "heading"],
  ["h5", "heading"],
  ["h6", "heading"],
  ["hr", "separator"],
  ["img", "img"],
  ["li", "listitem"],
  ["link", "link"],
  ["main", "main"],
  ["menu", "list"],
  ["meter", "progressbar"],
  ["nav", "navigation"],
  ["ol", "list"],
  ["option", "option"],
  ["optgroup", "group"],
  ["output", "status"],
  ["progress", "progressbar"],
  ["section", "region"],
  ["summary", "button"],
  ["table", "table"],
  ["tbody", "rowgroup"],
  ["textarea", "textbox"],
  ["tfoot", "rowgroup"],
  ["thead", "rowgroup"],
  ["tr", "row"],
  ["ul", "list"]
]);
var menuitem_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["command", "menuitem"],
  ["checkbox", "menuitemcheckbox"],
  ["radio", "menuitemradio"]
]);
var input_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["button", "button"],
  ["image", "button"],
  ["reset", "button"],
  ["submit", "button"],
  ["checkbox", "checkbox"],
  ["radio", "radio"],
  ["range", "slider"],
  ["number", "spinbutton"],
  ["email", "textbox"],
  ["search", "searchbox"],
  ["tel", "textbox"],
  ["text", "textbox"],
  ["url", "textbox"]
]);
var a11y_non_interactive_element_to_interactive_role_exceptions = {
  ul: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  ol: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  li: ["menuitem", "option", "row", "tab", "treeitem"],
  table: ["grid"],
  td: ["gridcell"],
  fieldset: ["radiogroup", "presentation"]
};
var combobox_if_list = ["email", "search", "tel", "text", "url"];
var address_type_tokens = ["shipping", "billing"];
var autofill_field_name_tokens = [
  "",
  "on",
  "off",
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
];
var contact_type_tokens = ["home", "work", "mobile", "fax", "pager"];
var autofill_contact_field_name_tokens = [
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
];
var ElementInteractivity = (
  /** @type {const} */
  {
    Interactive: "interactive",
    NonInteractive: "non-interactive",
    Static: "static"
  }
);
var invisible_elements = ["meta", "html", "script", "style"];
var aria_roles = import_aria_query.roles.keys();
var abstract_roles = aria_roles.filter((role) => import_aria_query.roles.get(role)?.abstract);
var non_abstract_roles = aria_roles.filter((name) => !abstract_roles.includes(name));
var non_interactive_roles = non_abstract_roles.filter((name) => {
  const role = import_aria_query.roles.get(name);
  return (
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
    // 'generic' is meant to have no semantic meaning.
    // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
    !["toolbar", "tabpanel", "generic", "cell"].includes(name) && !role?.superClass.some((classes) => classes.includes("widget") || classes.includes("window"))
  );
}).concat(
  // The `progressbar` is descended from `widget`, but in practice, its
  // value is always `readonly`, so we treat it as a non-interactive role.
  "progressbar"
);
var interactive_roles = non_abstract_roles.filter(
  (name) => !non_interactive_roles.includes(name) && // 'generic' is meant to have no semantic meaning.
  name !== "generic"
);
var presentation_roles = ["presentation", "none"];
var non_interactive_element_role_schemas = [];
var interactive_element_role_schemas = [];
for (const [schema, roles] of import_aria_query.elementRoles.entries()) {
  if ([...roles].every((role) => role !== "generic" && non_interactive_roles.includes(role))) {
    non_interactive_element_role_schemas.push(schema);
  }
  if ([...roles].every((role) => interactive_roles.includes(role))) {
    interactive_element_role_schemas.push(schema);
  }
}
var interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => import_axobject_query.AXObjects.get(name).type === "widget"
);
var interactive_element_ax_object_schemas = [];
var non_interactive_element_ax_object_schemas = [];
var non_interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => ["windows", "structure"].includes(import_axobject_query.AXObjects.get(name).type)
);
for (const [schema, ax_object] of import_axobject_query.elementAXObjects.entries()) {
  if ([...ax_object].every((role) => interactive_ax_objects.includes(role))) {
    interactive_element_ax_object_schemas.push(schema);
  }
  if ([...ax_object].every((role) => non_interactive_ax_objects.includes(role))) {
    non_interactive_element_ax_object_schemas.push(schema);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/a11y/index.js
var import_aria_query2 = __toESM(require_lib(), 1);
var import_axobject_query2 = __toESM(require_lib2(), 1);
function check_element(node, context) {
  const attribute_map = /* @__PURE__ */ new Map();
  const handlers = /* @__PURE__ */ new Set();
  const attributes = [];
  const is_dynamic_element = node.type === "SvelteElement";
  let has_spread = false;
  let has_contenteditable_attr = false;
  let has_contenteditable_binding = false;
  for (const attribute of node.attributes) {
    switch (attribute.type) {
      case "Attribute": {
        if (is_event_attribute(attribute)) {
          handlers.add(attribute.name.slice(2));
        } else {
          attributes.push(attribute);
          attribute_map.set(attribute.name, attribute);
          if (attribute.name === "contenteditable") {
            has_contenteditable_attr = true;
          }
        }
        break;
      }
      case "SpreadAttribute": {
        has_spread = true;
        break;
      }
      case "BindDirective": {
        if (is_content_editable_binding(attribute.name)) {
          has_contenteditable_binding = true;
        }
        break;
      }
      case "OnDirective": {
        handlers.add(attribute.name);
        break;
      }
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") continue;
    const name = attribute.name.toLowerCase();
    if (name.startsWith("aria-")) {
      if (invisible_elements.includes(node.name)) {
        a11y_aria_attributes(attribute, node.name);
      }
      const type = name.slice(5);
      if (!aria_attributes.includes(type)) {
        const match = fuzzymatch(type, aria_attributes);
        a11y_unknown_aria_attribute(attribute, type, match);
      }
      if (name === "aria-hidden" && regex_heading_tags.test(node.name)) {
        a11y_hidden(attribute, node.name);
      }
      let value = get_static_value2(attribute);
      const schema = import_aria_query2.aria.get(
        /** @type {ARIAProperty} */
        name
      );
      if (schema !== void 0) {
        validate_aria_attribute_value(
          attribute,
          /** @type {ARIAProperty} */
          name,
          schema,
          value
        );
      }
      if (name === "aria-activedescendant" && !is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !attribute_map.has("tabindex") && !has_spread) {
        a11y_aria_activedescendant_has_tabindex(attribute);
      }
    }
    switch (name) {
      // aria-role
      case "role": {
        if (invisible_elements.includes(node.name)) {
          a11y_misplaced_role(attribute, node.name);
        }
        const value = get_static_value2(attribute);
        if (typeof value !== "string") {
          break;
        }
        for (const c_r of value.split(regex_whitespaces)) {
          const current_role = (
            /** @type {ARIARoleDefinitionKey} current_role */
            c_r
          );
          if (current_role && is_abstract_role(current_role)) {
            a11y_no_abstract_role(attribute, current_role);
          } else if (current_role && !aria_roles.includes(current_role)) {
            const match = fuzzymatch(current_role, aria_roles);
            a11y_unknown_role(attribute, current_role, match);
          }
          if (current_role === get_implicit_role(node.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
          !["ul", "ol", "li"].includes(node.name) && // <a role="link" /> is ok because without href the a tag doesn't have a role of link
          !(node.name === "a" && !attribute_map.has("href"))) {
            a11y_no_redundant_roles(attribute, current_role);
          }
          const is_parent_section_or_article = is_parent(context.path, ["section", "article"]);
          if (!is_parent_section_or_article) {
            const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(node.name);
            if (has_nested_redundant_role) {
              a11y_no_redundant_roles(attribute, current_role);
            }
          }
          if (!is_dynamic_element && !is_semantic_role_element(current_role, node.name, attribute_map)) {
            const role2 = import_aria_query2.roles.get(current_role);
            if (role2) {
              const required_role_props = Object.keys(role2.requiredProps);
              const has_missing_props = !has_spread && required_role_props.some((prop2) => !attributes.find((a) => a.name === prop2));
              if (has_missing_props) {
                a11y_role_has_required_aria_props(
                  attribute,
                  current_role,
                  list(
                    required_role_props.map((v) => `"${v}"`),
                    "and"
                  )
                );
              }
            }
          }
          if (!has_spread && !has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(node.name, attribute_map) && !attribute_map.get("tabindex")) {
            const has_interactive_handlers = [...handlers].some(
              (handler) => a11y_interactive_handlers.includes(handler)
            );
            if (has_interactive_handlers) {
              a11y_interactive_supports_focus(node, current_role);
            }
          }
          if (!has_spread && is_interactive_element(node.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) {
            a11y_no_interactive_element_to_noninteractive_role(node, node.name, current_role);
          }
          if (!has_spread && is_non_interactive_element(node.name, attribute_map) && is_interactive_roles(current_role) && !a11y_non_interactive_element_to_interactive_role_exceptions[node.name]?.includes(
            current_role
          )) {
            a11y_no_noninteractive_element_to_interactive_role(node, node.name, current_role);
          }
        }
        break;
      }
      // no-access-key
      case "accesskey": {
        a11y_accesskey(attribute);
        break;
      }
      // no-autofocus
      case "autofocus": {
        if (node.name !== "dialog" && !is_parent(context.path, ["dialog"])) {
          a11y_autofocus(attribute);
        }
        break;
      }
      // scope
      case "scope": {
        if (!is_dynamic_element && node.name !== "th") {
          a11y_misplaced_scope(attribute);
        }
        break;
      }
      // tabindex-no-positive
      case "tabindex": {
        const value = get_static_value2(attribute);
        if (!isNaN(value) && +value > 0) {
          a11y_positive_tabindex(attribute);
        }
        break;
      }
    }
  }
  const role = attribute_map.get("role");
  const role_static_value = (
    /** @type {ARIARoleDefinitionKey} */
    get_static_text_value(role)
  );
  if (handlers.has("click")) {
    const is_non_presentation_role = role_static_value !== null && !is_presentation_role(role_static_value);
    if (!is_dynamic_element && !is_hidden_from_screen_reader(node.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(node.name, attribute_map) && !has_spread) {
      const has_key_event = handlers.has("keydown") || handlers.has("keyup") || handlers.has("keypress");
      if (!has_key_event) {
        a11y_click_events_have_key_events(node);
      }
    }
  }
  const role_value = (
    /** @type {ARIARoleDefinitionKey} */
    role ? role_static_value : get_implicit_role(node.name, attribute_map)
  );
  if (!is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value)) {
    const tab_index = attribute_map.get("tabindex");
    const tab_index_value = get_static_text_value(tab_index);
    if (tab_index && (tab_index_value === null || Number(tab_index_value) >= 0)) {
      a11y_no_noninteractive_tabindex(node);
    }
  }
  if (typeof role_value === "string" && import_aria_query2.roles.has(role_value)) {
    const { props } = (
      /** @type {ARIARoleDefinition} */
      import_aria_query2.roles.get(role_value)
    );
    const invalid_aria_props = import_aria_query2.aria.keys().filter((attribute) => !(attribute in props));
    const is_implicit = role_value && role === void 0;
    for (const attr of attributes) {
      if (invalid_aria_props.includes(
        /** @type {ARIAProperty} */
        attr.name
      )) {
        if (is_implicit) {
          a11y_role_supports_aria_props_implicit(attr, attr.name, role_value, node.name);
        } else {
          a11y_role_supports_aria_props(attr, attr.name, role_value);
        }
      }
    }
  }
  if (!has_spread && !has_contenteditable_attr && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && (!is_interactive_element(node.name, attribute_map) && is_non_interactive_roles(role_static_value) || is_non_interactive_element(node.name, attribute_map) && !role)) {
    const has_interactive_handlers = [...handlers].some(
      (handler) => a11y_recommended_interactive_handlers.includes(handler)
    );
    if (has_interactive_handlers) {
      a11y_no_noninteractive_element_interactions(node, node.name);
    }
  }
  if (!has_spread && (!role || role_static_value !== null) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(node.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value)) {
    const interactive_handlers = [...handlers].filter(
      (handler) => a11y_interactive_handlers.includes(handler)
    );
    if (interactive_handlers.length > 0) {
      a11y_no_static_element_interactions(node, node.name, list(interactive_handlers));
    }
  }
  if (!has_spread && handlers.has("mouseover") && !handlers.has("focus")) {
    a11y_mouse_events_have_key_events(node, "mouseover", "focus");
  }
  if (!has_spread && handlers.has("mouseout") && !handlers.has("blur")) {
    a11y_mouse_events_have_key_events(node, "mouseout", "blur");
  }
  const is_labelled = attribute_map.has("aria-label") || attribute_map.has("aria-labelledby") || attribute_map.has("title");
  switch (node.name) {
    case "a":
    case "button": {
      const is_hidden = get_static_value2(attribute_map.get("aria-hidden")) === "true" || get_static_value2(attribute_map.get("inert")) !== null;
      if (!has_spread && !is_hidden && !is_labelled && !has_content(node)) {
        a11y_consider_explicit_label(node);
      }
      if (node.name === "button") {
        break;
      }
      const href = attribute_map.get("href") || attribute_map.get("xlink:href");
      if (href) {
        const href_value = get_static_text_value(href);
        if (href_value !== null) {
          if (href_value === "" || href_value === "#" || regex_js_prefix.test(href_value)) {
            a11y_invalid_attribute(href, href_value, href.name);
          }
        }
      } else if (!has_spread) {
        const id_attribute = get_static_value2(attribute_map.get("id"));
        const name_attribute = get_static_value2(attribute_map.get("name"));
        const aria_disabled_attribute = get_static_value2(attribute_map.get("aria-disabled"));
        if (!id_attribute && !name_attribute && aria_disabled_attribute !== "true") {
          warn_missing_attribute(node, ["href"]);
        }
      }
      break;
    }
    case "input": {
      const type = attribute_map.get("type");
      const type_value = get_static_text_value(type);
      if (type_value === "image" && !has_spread) {
        const required_attributes = ["alt", "aria-label", "aria-labelledby"];
        const has_attribute = required_attributes.some((name) => attribute_map.has(name));
        if (!has_attribute) {
          warn_missing_attribute(node, required_attributes, 'input type="image"');
        }
      }
      const autocomplete = attribute_map.get("autocomplete");
      if (type && autocomplete) {
        const autocomplete_value = get_static_value2(autocomplete);
        if (!is_valid_autocomplete(autocomplete_value)) {
          a11y_autocomplete_valid(
            autocomplete,
            /** @type {string} */
            autocomplete_value,
            type_value ?? "..."
          );
        }
      }
      break;
    }
    case "img": {
      const alt_attribute = get_static_text_value(attribute_map.get("alt"));
      const aria_hidden = get_static_value2(attribute_map.get("aria-hidden"));
      if (alt_attribute && !aria_hidden && !has_spread) {
        if (regex_redundant_img_alt.test(alt_attribute)) {
          a11y_img_redundant_alt(node);
        }
      }
      break;
    }
    case "label": {
      const has_input_child = (node2) => {
        let has = false;
        walk(
          node2,
          {},
          {
            _(node3, { next: next2 }) {
              if (node3.type === "SvelteElement" || node3.type === "SlotElement" || node3.type === "Component" || node3.type === "RenderTag" || node3.type === "RegularElement" && (a11y_labelable.includes(node3.name) || node3.name === "slot")) {
                has = true;
              } else {
                next2();
              }
            }
          }
        );
        return has;
      };
      if (!has_spread && !attribute_map.has("for") && !has_input_child(node)) {
        a11y_label_has_associated_control(node);
      }
      break;
    }
    case "video": {
      const aria_hidden_attribute = attribute_map.get("aria-hidden");
      const aria_hidden_exist = aria_hidden_attribute && get_static_value2(aria_hidden_attribute);
      if (attribute_map.has("muted") || aria_hidden_exist === "true" || has_spread) {
        return;
      }
      let has_caption = false;
      const track = (
        /** @type {AST.RegularElement | undefined} */
        node.fragment.nodes.find((i) => i.type === "RegularElement" && i.name === "track")
      );
      if (track) {
        has_caption = track.attributes.some(
          (a) => a.type === "SpreadAttribute" || a.type === "Attribute" && a.name === "kind" && get_static_value2(a) === "captions"
        );
      }
      if (!has_caption) {
        a11y_media_has_caption(node);
      }
      break;
    }
    case "figcaption": {
      if (!is_parent(context.path, ["figure"])) {
        a11y_figcaption_parent(node);
      }
      break;
    }
    case "figure": {
      const children = node.fragment.nodes.filter((node2) => {
        if (node2.type === "Comment") return false;
        if (node2.type === "Text") return regex_not_whitespace.test(node2.data);
        return true;
      });
      const index = children.findIndex(
        (child) => child.type === "RegularElement" && child.name === "figcaption"
      );
      if (index !== -1 && index !== 0 && index !== children.length - 1) {
        a11y_figcaption_index(children[index]);
      }
      break;
    }
  }
  if (!has_spread && node.name !== "a") {
    const required_attributes = a11y_required_attributes[node.name];
    if (required_attributes) {
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        warn_missing_attribute(node, required_attributes);
      }
    }
  }
  if (a11y_distracting_elements2.includes(node.name)) {
    a11y_distracting_elements(node, node.name);
  }
  if (!has_spread && !is_labelled && !has_contenteditable_binding && a11y_required_content.includes(node.name) && !has_content(node)) {
    a11y_missing_content(node, node.name);
  }
}
function is_presentation_role(role) {
  return presentation_roles.includes(role);
}
function is_hidden_from_screen_reader(tag_name, attribute_map) {
  if (tag_name === "input") {
    const type = get_static_value2(attribute_map.get("type"));
    if (type === "hidden") {
      return true;
    }
  }
  const aria_hidden = attribute_map.get("aria-hidden");
  if (!aria_hidden) return false;
  const aria_hidden_value = get_static_value2(aria_hidden);
  if (aria_hidden_value === null) return true;
  return aria_hidden_value === true || aria_hidden_value === "true";
}
function has_disabled_attribute(attribute_map) {
  const disabled_attr_value = get_static_value2(attribute_map.get("disabled"));
  if (disabled_attr_value) {
    return true;
  }
  const aria_disabled_attr = attribute_map.get("aria-disabled");
  if (aria_disabled_attr) {
    const aria_disabled_attr_value = get_static_value2(aria_disabled_attr);
    if (aria_disabled_attr_value === "true") {
      return true;
    }
  }
  return false;
}
function element_interactivity(tag_name, attribute_map) {
  if (interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map))) {
    return ElementInteractivity.Interactive;
  }
  if (tag_name !== "header" && non_interactive_element_role_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  if (interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.Interactive;
  }
  if (non_interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  return ElementInteractivity.Static;
}
function is_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
}
function is_non_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
}
function is_static_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
}
function is_semantic_role_element(role, tag_name, attribute_map) {
  for (const [schema, ax_object] of import_axobject_query2.elementAXObjects.entries()) {
    if (schema.name === tag_name && (!schema.attributes || schema.attributes.every(
      /** @param {any} attr */
      (attr) => attribute_map.has(attr.name) && get_static_value2(attribute_map.get(attr.name)) === attr.value
    ))) {
      for (const name of ax_object) {
        const roles = import_axobject_query2.AXObjectRoles.get(name);
        if (roles) {
          for (const { name: name2 } of roles) {
            if (name2 === role) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
function is_valid_autocomplete(autocomplete) {
  if (autocomplete === true) {
    return false;
  } else if (!autocomplete) {
    return true;
  }
  const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
  if (typeof tokens[0] === "string" && tokens[0].startsWith("section-")) {
    tokens.shift();
  }
  if (address_type_tokens.includes(tokens[0])) {
    tokens.shift();
  }
  if (autofill_field_name_tokens.includes(tokens[0])) {
    tokens.shift();
  } else {
    if (contact_type_tokens.includes(tokens[0])) {
      tokens.shift();
    }
    if (autofill_contact_field_name_tokens.includes(tokens[0])) {
      tokens.shift();
    } else {
      return false;
    }
  }
  if (tokens[0] === "webauthn") {
    tokens.shift();
  }
  return tokens.length === 0;
}
function input_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute) return;
  const type = get_static_text_value(type_attribute);
  if (!type) return;
  const list_attribute_exists = attribute_map.has("list");
  if (list_attribute_exists && combobox_if_list.includes(type)) {
    return "combobox";
  }
  return input_type_to_implicit_role.get(type);
}
function menuitem_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute) return;
  const type = get_static_text_value(type_attribute);
  if (!type) return;
  return menuitem_type_to_implicit_role.get(type);
}
function get_implicit_role(name, attribute_map) {
  if (name === "menuitem") {
    return menuitem_implicit_role(attribute_map);
  } else if (name === "input") {
    return input_implicit_role(attribute_map);
  } else {
    return a11y_implicit_semantics.get(name);
  }
}
function is_non_interactive_roles(role) {
  return non_interactive_roles.includes(role);
}
function is_interactive_roles(role) {
  return interactive_roles.includes(role);
}
function is_abstract_role(role) {
  return abstract_roles.includes(role);
}
function get_static_text_value(attribute) {
  const value = get_static_value2(attribute);
  if (value === true) return null;
  return value;
}
function get_static_value2(attribute) {
  if (!attribute) return null;
  if (attribute.value === true) return true;
  if (is_text_attribute(attribute)) return attribute.value[0].data;
  return null;
}
function has_content(element2) {
  for (const node of element2.fragment.nodes) {
    if (node.type === "Text") {
      if (node.data.trim() === "") {
        continue;
      }
    }
    if (node.type === "RegularElement" || node.type === "SvelteElement") {
      if (node.name === "img" && node.attributes.some((node2) => node2.type === "Attribute" && node2.name === "alt")) {
        return true;
      }
      if (!has_content(node)) {
        continue;
      }
    }
    return true;
  }
}
function match_schema(schema, tag_name, attribute_map) {
  if (schema.name !== tag_name) return false;
  if (!schema.attributes) return true;
  return schema.attributes.every((schema_attribute) => {
    const attribute = attribute_map.get(schema_attribute.name);
    if (!attribute) return false;
    if (schema_attribute.value && schema_attribute.value !== get_static_text_value(attribute)) {
      return false;
    }
    return true;
  });
}
function is_parent(path, elements) {
  let i = path.length;
  while (i--) {
    const parent = path[i];
    if (parent.type === "SvelteElement") return true;
    if (parent.type === "RegularElement") {
      return elements.includes(parent.name);
    }
  }
  return false;
}
function validate_aria_attribute_value(attribute, name, schema, value) {
  const type = schema.type;
  if (value === null) return;
  if (value === true) value = "";
  switch (type) {
    case "id":
    case "string": {
      if (value === "") {
        a11y_incorrect_aria_attribute_type(attribute, name, "non-empty string");
      }
      break;
    }
    case "number": {
      if (value === "" || isNaN(+value)) {
        a11y_incorrect_aria_attribute_type(attribute, name, "number");
      }
      break;
    }
    case "boolean": {
      if (value !== "true" && value !== "false") {
        a11y_incorrect_aria_attribute_type_boolean(attribute, name);
      }
      break;
    }
    case "idlist": {
      if (value === "") {
        a11y_incorrect_aria_attribute_type_idlist(attribute, name);
      }
      break;
    }
    case "integer": {
      if (value === "" || !Number.isInteger(+value)) {
        a11y_incorrect_aria_attribute_type_integer(attribute, name);
      }
      break;
    }
    case "token": {
      const values = (schema.values ?? []).map((value2) => value2.toString());
      if (!values.includes(value.toLowerCase())) {
        a11y_incorrect_aria_attribute_type_token(
          attribute,
          name,
          list(values.map((v) => `"${v}"`))
        );
      }
      break;
    }
    case "tokenlist": {
      const values = (schema.values ?? []).map((value2) => value2.toString());
      if (value.toLowerCase().split(regex_whitespaces).some((value2) => !values.includes(value2))) {
        a11y_incorrect_aria_attribute_type_tokenlist(
          attribute,
          name,
          list(values.map((v) => `"${v}"`))
        );
      }
      break;
    }
    case "tristate": {
      if (value !== "true" && value !== "false" && value !== "mixed") {
        a11y_incorrect_aria_attribute_type_tristate(attribute, name);
      }
      break;
    }
  }
}
function warn_missing_attribute(node, attributes, name = node.name) {
  const article = regex_starts_with_vowel.test(attributes[0]) || attributes[0] === "href" ? "an" : "a";
  const sequence2 = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
  a11y_missing_attribute(node, name, article, sequence2);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/element.js
var EVENT_MODIFIERS = [
  "preventDefault",
  "stopPropagation",
  "stopImmediatePropagation",
  "capture",
  "once",
  "passive",
  "nonpassive",
  "self",
  "trusted"
];
function validate_element(node, context) {
  let has_animate_directive = false;
  let in_transition = null;
  let out_transition = null;
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      const is_expression = is_expression_attribute(attribute);
      if (context.state.analysis.runes) {
        validate_attribute(attribute, node);
        if (is_expression) {
          const expression = get_attribute_expression(attribute);
          if (expression.type === "SequenceExpression") {
            let i = (
              /** @type {number} */
              expression.start
            );
            while (--i > 0) {
              const char = context.state.analysis.source[i];
              if (char === "(") break;
              if (char === "{") attribute_invalid_sequence_expression(expression);
            }
          }
        }
      }
      if (regex_illegal_attribute_character.test(attribute.name)) {
        attribute_invalid_name(attribute, attribute.name);
      }
      if (attribute.name.startsWith("on") && attribute.name.length > 2) {
        if (!is_expression) {
          attribute_invalid_event_handler(attribute);
        }
        const value = get_attribute_expression(attribute);
        if (value.type === "Identifier" && value.name === attribute.name && !context.state.scope.get(value.name)) {
          attribute_global_event_reference(attribute, attribute.name);
        }
      }
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute);
      }
      if (attribute.name === "is") {
        attribute_avoid_is(attribute);
      }
      const correct_name = react_attributes.get(attribute.name);
      if (correct_name) {
        attribute_invalid_property_name(attribute, attribute.name, correct_name);
      }
      validate_attribute_name(attribute);
    } else if (attribute.type === "AnimateDirective") {
      const parent = context.path.at(-2);
      if (parent?.type !== "EachBlock") {
        animation_invalid_placement(attribute);
      } else if (!parent.key) {
        animation_missing_key(attribute);
      } else if (parent.body.nodes.filter(
        (n2) => n2.type !== "Comment" && n2.type !== "ConstTag" && (n2.type !== "Text" || n2.data.trim() !== "")
      ).length > 1) {
        animation_invalid_placement(attribute);
      }
      if (has_animate_directive) {
        animation_duplicate(attribute);
      } else {
        has_animate_directive = true;
      }
    } else if (attribute.type === "TransitionDirective") {
      const existing = (
        /** @type {AST.TransitionDirective | null} */
        attribute.intro && in_transition || attribute.outro && out_transition
      );
      if (existing) {
        const a = existing.intro ? existing.outro ? "transition" : "in" : "out";
        const b = attribute.intro ? attribute.outro ? "transition" : "in" : "out";
        if (a === b) {
          transition_duplicate(attribute, a);
        } else {
          transition_conflict(attribute, a, b);
        }
      }
      if (attribute.intro) in_transition = attribute;
      if (attribute.outro) out_transition = attribute;
    } else if (attribute.type === "OnDirective") {
      let has_passive_modifier = false;
      let conflicting_passive_modifier = "";
      for (const modifier of attribute.modifiers) {
        if (!EVENT_MODIFIERS.includes(modifier)) {
          const list3 = `${EVENT_MODIFIERS.slice(0, -1).join(", ")} or ${EVENT_MODIFIERS.at(-1)}`;
          event_handler_invalid_modifier(attribute, list3);
        }
        if (modifier === "passive") {
          has_passive_modifier = true;
        } else if (modifier === "nonpassive" || modifier === "preventDefault") {
          conflicting_passive_modifier = modifier;
        }
        if (has_passive_modifier && conflicting_passive_modifier) {
          event_handler_invalid_modifier_combination(
            attribute,
            "passive",
            conflicting_passive_modifier
          );
        }
      }
    }
  }
}
var react_attributes = /* @__PURE__ */ new Map([
  ["className", "class"],
  ["htmlFor", "for"]
]);

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/RegularElement.js
function RegularElement(node, context) {
  validate_element(node, context);
  check_element(node, context);
  node.metadata.path = [...context.path];
  context.state.analysis.elements.push(node);
  if (node.name === "textarea" && node.fragment.nodes.length > 0) {
    for (const attribute of node.attributes) {
      if (attribute.type === "Attribute" && attribute.name === "value") {
        textarea_invalid_content(node);
      }
    }
    if (node.fragment.nodes.length > 1 || node.fragment.nodes[0].type !== "Text") {
      const first = node.fragment.nodes[0];
      if (first.type === "Text") {
        first.data = first.data.replace(regex_starts_with_newline, "");
        first.raw = first.raw.replace(regex_starts_with_newline, "");
      }
      node.attributes.push(
        create_attribute(
          "value",
          /** @type {AST.Text} */
          node.fragment.nodes.at(0).start,
          /** @type {AST.Text} */
          node.fragment.nodes.at(-1).end,
          // @ts-ignore
          node.fragment.nodes
        )
      );
      node.fragment.nodes = [];
    }
  }
  if (node.name === "option" && node.fragment.nodes?.length === 1 && node.fragment.nodes[0].type === "ExpressionTag" && !node.attributes.some(
    (attribute) => attribute.type === "Attribute" && attribute.name === "value"
  )) {
    const child = node.fragment.nodes[0];
    node.metadata.synthetic_value_node = child;
  }
  const binding = context.state.scope.get(node.name);
  if (binding !== null && binding.declaration_kind === "import" && binding.references.length === 0) {
    component_name_lowercase(node, node.name);
  }
  node.metadata.has_spread = node.attributes.some(
    (attribute) => attribute.type === "SpreadAttribute"
  );
  const is_svg_element = () => {
    if (is_svg(node.name)) {
      return true;
    }
    if (node.name === "a" || node.name === "title") {
      let i = context.path.length;
      while (i--) {
        const ancestor = context.path[i];
        if (ancestor.type === "RegularElement") {
          return ancestor.metadata.svg;
        }
      }
    }
    return false;
  };
  node.metadata.svg = is_svg_element();
  node.metadata.mathml = is_mathml(node.name);
  if (is_custom_element_node(node) && node.attributes.length > 0) {
    mark_subtree_dynamic(context.path);
  }
  if (context.state.parent_element) {
    let past_parent = false;
    let only_warn = false;
    const ancestors = [context.state.parent_element];
    for (let i = context.path.length - 1; i >= 0; i--) {
      const ancestor = context.path[i];
      if (ancestor.type === "IfBlock" || ancestor.type === "EachBlock" || ancestor.type === "AwaitBlock" || ancestor.type === "KeyBlock") {
        only_warn = true;
      }
      if (!past_parent) {
        if (ancestor.type === "RegularElement" && ancestor.name === context.state.parent_element) {
          const message = is_tag_valid_with_parent(node.name, context.state.parent_element);
          if (message) {
            if (only_warn) {
              node_invalid_placement_ssr(node, message);
            } else {
              node_invalid_placement(node, message);
            }
          }
          past_parent = true;
        }
      } else if (ancestor.type === "RegularElement") {
        ancestors.push(ancestor.name);
        const message = is_tag_valid_with_ancestor(node.name, ancestors);
        if (message) {
          if (only_warn) {
            node_invalid_placement_ssr(node, message);
          } else {
            node_invalid_placement(node, message);
          }
        }
      } else if (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteElement" || ancestor.type === "SvelteSelf" || ancestor.type === "SnippetBlock") {
        break;
      }
    }
  }
  const node_name = node.name.replace(/[a-zA-Z-]*:/g, "");
  if (context.state.analysis.source[node.end - 2] === "/" && !is_void(node_name) && !is_svg(node_name) && !is_mathml(node_name)) {
    element_invalid_self_closing_tag(node, node.name);
  }
  context.next({ ...context.state, parent_element: node.name });
  if (node.name === "a" && !context.state.parent_element) {
    for (const child of node.fragment.nodes) {
      if (child.type === "RegularElement") {
        if (child.metadata.svg && child.name !== "svg") {
          node.metadata.svg = true;
          break;
        }
      }
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/RenderTag.js
function RenderTag(node, context) {
  validate_opening_tag(node, context.state, "@");
  node.metadata.path = [...context.path];
  const expression = unwrap_optional(node.expression);
  const callee = expression.callee;
  const binding = callee.type === "Identifier" ? context.state.scope.get(callee.name) : null;
  node.metadata.dynamic = binding?.kind !== "normal";
  let resolved = callee.type === "Identifier" && is_resolved_snippet(binding);
  if (binding?.initial?.type === "SnippetBlock") {
    node.metadata.snippets.add(binding.initial);
  }
  context.state.analysis.snippet_renderers.set(node, resolved);
  context.state.analysis.uses_render_tags = true;
  const raw_args = unwrap_optional(node.expression).arguments;
  for (const arg of raw_args) {
    if (arg.type === "SpreadElement") {
      render_tag_invalid_spread_argument(arg);
    }
  }
  if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && ["bind", "apply", "call"].includes(callee.property.name)) {
    render_tag_invalid_call_expression(node);
  }
  mark_subtree_dynamic(context.path);
  context.visit(callee, { ...context.state, expression: node.metadata.expression });
  for (const arg of expression.arguments) {
    const metadata = new ExpressionMetadata();
    node.metadata.arguments.push(metadata);
    context.visit(arg, {
      ...context.state,
      expression: metadata
    });
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SlotElement.js
function SlotElement(node, context) {
  if (context.state.analysis.runes && !context.state.analysis.custom_element) {
    slot_element_deprecated(node);
  }
  mark_subtree_dynamic(context.path);
  let name = "default";
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "name") {
        if (!is_text_attribute(attribute)) {
          slot_element_invalid_name(attribute);
        }
        name = attribute.value[0].data;
        if (name === "default") {
          slot_element_invalid_name_default(attribute);
        }
      }
    } else if (attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective") {
      slot_element_invalid_attribute(attribute);
    }
  }
  context.state.analysis.slot_names.set(name, node);
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SnippetBlock.js
function SnippetBlock(node, context) {
  context.state.analysis.snippets.add(node);
  validate_block_not_empty(node.body, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
  }
  for (const arg of node.parameters) {
    if (arg.type === "RestElement") {
      snippet_invalid_rest_parameter(arg);
    }
  }
  context.next({ ...context.state, parent_element: null });
  const can_hoist = context.path.length === 1 && context.path[0].type === "Fragment" && can_hoist_snippet(context.state.scope, context.state.scopes);
  const name = node.expression.name;
  if (can_hoist) {
    const binding = (
      /** @type {Binding} */
      context.state.scope.get(name)
    );
    context.state.analysis.module.scope.declarations.set(name, binding);
  }
  node.metadata.can_hoist = can_hoist;
  const { path } = context;
  const parent = path.at(-2);
  if (!parent) return;
  if (parent.type === "Component" && parent.attributes.some(
    (attribute) => (attribute.type === "Attribute" || attribute.type === "BindDirective") && attribute.name === node.expression.name
  )) {
    snippet_shadowing_prop(node, node.expression.name);
  }
  if (node.expression.name !== "children") return;
  if (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf") {
    if (parent.fragment.nodes.some(
      (node2) => node2.type !== "SnippetBlock" && (node2.type !== "Text" || node2.data.trim()) && node2.type !== "Comment"
    )) {
      snippet_conflict(node);
    }
  }
}
function can_hoist_snippet(scope, scopes, visited = /* @__PURE__ */ new Set()) {
  for (const [reference] of scope.references) {
    const binding = scope.get(reference);
    if (!binding) continue;
    if (binding.blocker) {
      return false;
    }
    if (binding.scope.function_depth === 0) {
      continue;
    }
    if (binding.scope.function_depth >= scope.function_depth) {
      continue;
    }
    if (binding.initial?.type === "SnippetBlock") {
      if (visited.has(binding)) continue;
      visited.add(binding);
      const snippet_scope = (
        /** @type {Scope} */
        scopes.get(binding.initial)
      );
      if (can_hoist_snippet(snippet_scope, scopes, visited)) {
        continue;
      }
    }
    return false;
  }
  return true;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SpreadAttribute.js
function SpreadAttribute(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SpreadElement.js
function SpreadElement(node, context) {
  if (context.state.expression) {
    context.state.expression.has_call = true;
    context.state.expression.has_state = true;
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/StyleDirective.js
function StyleDirective(node, context) {
  if (node.modifiers.length > 1 || node.modifiers.length && node.modifiers[0] !== "important") {
    style_directive_invalid_modifier(node);
  }
  mark_subtree_dynamic(context.path);
  if (node.value === true) {
    let binding = context.state.scope.get(node.name);
    if (binding) {
      if (binding.kind !== "normal") {
        node.metadata.expression.has_state = true;
      }
      if (binding.blocker) {
        node.metadata.expression.dependencies.add(binding);
      }
    }
  } else {
    context.next();
    for (const chunk of get_attribute_chunks(node.value)) {
      if (chunk.type !== "ExpressionTag") continue;
      node.metadata.expression.merge(chunk.metadata.expression);
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteBody.js
function SvelteBody(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      svelte_body_illegal_attribute(attribute);
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteComponent.js
function SvelteComponent(node, context) {
  if (context.state.analysis.runes) {
    svelte_component_deprecated(node);
  }
  context.visit(node.expression, { ...context.state, expression: node.metadata.expression });
  visit_component(node, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteDocument.js
function SvelteDocument(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      illegal_element_attribute(attribute, "svelte:document");
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteElement.js
function SvelteElement(node, context) {
  validate_element(node, context);
  check_element(node, context);
  node.metadata.path = [...context.path];
  context.state.analysis.elements.push(node);
  const xmlns = (
    /** @type {AST.Attribute & { value: [AST.Text] } | undefined} */
    node.attributes.find(
      (a) => a.type === "Attribute" && a.name === "xmlns" && is_text_attribute(a)
    )
  );
  if (xmlns) {
    node.metadata.svg = xmlns.value[0].data === NAMESPACE_SVG;
    node.metadata.mathml = xmlns.value[0].data === NAMESPACE_MATHML;
  } else {
    let i = context.path.length;
    while (i--) {
      const ancestor = context.path[i];
      if (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteFragment" || ancestor.type === "SnippetBlock" || i === 0) {
        node.metadata.svg = context.state.options.namespace === "svg";
        node.metadata.mathml = context.state.options.namespace === "mathml";
        break;
      }
      if (ancestor.type === "SvelteElement" || ancestor.type === "RegularElement") {
        node.metadata.svg = ancestor.type === "RegularElement" && ancestor.name === "foreignObject" ? false : ancestor.metadata.svg;
        node.metadata.mathml = ancestor.type === "RegularElement" && ancestor.name === "foreignObject" ? false : ancestor.metadata.mathml;
        break;
      }
    }
  }
  mark_subtree_dynamic(context.path);
  context.visit(node.tag, {
    ...context.state,
    expression: node.metadata.expression
  });
  for (const attribute of node.attributes) {
    context.visit(attribute);
  }
  context.visit(node.fragment, {
    ...context.state,
    parent_element: null
  });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteFragment.js
function SvelteFragment(node, context) {
  const parent = context.path.at(-2);
  if (parent?.type !== "Component" && parent?.type !== "SvelteComponent") {
    svelte_fragment_invalid_placement(node);
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute);
      }
    } else if (attribute.type !== "LetDirective") {
      svelte_fragment_invalid_attribute(attribute);
    }
  }
  context.next({ ...context.state, parent_element: null });
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteHead.js
function SvelteHead(node, context) {
  for (const attribute of node.attributes) {
    svelte_head_illegal_attribute(attribute);
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteSelf.js
function SvelteSelf(node, context) {
  const valid2 = context.path.some(
    (node2) => node2.type === "IfBlock" || node2.type === "EachBlock" || node2.type === "Component" || node2.type === "SnippetBlock"
  );
  if (!valid2) {
    svelte_self_invalid_placement(node);
  }
  if (context.state.analysis.runes) {
    const name = filename === UNKNOWN_FILENAME ? "Self" : context.state.analysis.name;
    const basename = filename === UNKNOWN_FILENAME ? "Self.svelte" : (
      /** @type {string} */
      filename.split(/[/\\]/).pop()
    );
    svelte_self_deprecated(node, name, basename);
  }
  visit_component(node, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteWindow.js
function SvelteWindow(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      illegal_element_attribute(attribute, "svelte:window");
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteBoundary.js
var valid = ["onerror", "failed", "pending"];
function SvelteBoundary(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" || !valid.includes(attribute.name)) {
      svelte_boundary_invalid_attribute(attribute);
    }
    if (attribute.value === true || Array.isArray(attribute.value) && (attribute.value.length !== 1 || attribute.value[0].type !== "ExpressionTag")) {
      svelte_boundary_invalid_attribute_value(attribute);
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/TaggedTemplateExpression.js
function TaggedTemplateExpression(node, context) {
  if (context.state.expression && !is_pure(node.tag, context)) {
    context.state.expression.has_call = true;
    context.state.expression.has_state = true;
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/TemplateElement.js
function TemplateElement(node) {
  if (regex_bidirectional_control_characters.test(node.value.cooked ?? "")) {
    bidirectional_control_characters(node);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/Text.js
function Text(node, context) {
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  if (parent.type === "Fragment" && context.state.parent_element && regex_not_whitespace.test(node.data)) {
    const message = is_tag_valid_with_parent("#text", context.state.parent_element);
    if (message) {
      node_invalid_placement(node, message);
    }
  }
  regex_bidirectional_control_characters.lastIndex = 0;
  for (const match of node.data.matchAll(regex_bidirectional_control_characters)) {
    let is_ignored2 = false;
    if (parent.type === "Fragment") {
      for (const child of parent.nodes) {
        if (child === node) break;
        if (child.type === "Comment") {
          is_ignored2 ||= extract_svelte_ignore(
            child.start + 4,
            child.data,
            context.state.analysis.runes
          ).includes("bidirectional_control_characters");
        }
      }
    }
    if (!is_ignored2) {
      let start = match.index + node.start;
      bidirectional_control_characters({ start, end: start + match[0].length });
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/TitleElement.js
function TitleElement(node, context) {
  for (const attribute of node.attributes) {
    title_illegal_attribute(attribute);
  }
  for (const child of node.fragment.nodes) {
    if (child.type !== "Text" && child.type !== "ExpressionTag") {
      title_invalid_content(child);
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/TransitionDirective.js
function TransitionDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
  if (node.metadata.expression.has_await) {
    illegal_await_expression(node);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/UpdateExpression.js
function UpdateExpression(node, context) {
  validate_assignment(node, node.argument, context);
  if (context.state.reactive_statement) {
    const id2 = node.argument.type === "MemberExpression" ? object2(node.argument) : node.argument;
    if (id2?.type === "Identifier") {
      const binding = context.state.scope.get(id2.name);
      if (binding) {
        context.state.reactive_statement.assignments.add(binding);
      }
    }
  }
  if (context.state.expression) {
    context.state.expression.has_assignment = true;
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/UseDirective.js
function UseDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
  if (node.metadata.expression.has_await) {
    illegal_await_expression(node);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/assert.js
function equal(actual, expected) {
  if (actual !== expected) throw new Error("Assertion failed");
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/visitors/VariableDeclarator.js
function VariableDeclarator(node, context) {
  ensure_no_module_import_conflict(node, context.state);
  if (context.state.analysis.runes) {
    const init3 = node.init;
    const rune = get_rune(init3, context.state.scope);
    const { paths } = extract_paths(node.id, id("dummy"));
    for (const path of paths) {
      validate_identifier_name(context.state.scope.get(
        /** @type {Identifier} */
        path.node.name
      ));
    }
    if (rune === "$state" || rune === "$state.raw" || rune === "$derived" || rune === "$derived.by" || rune === "$props") {
      for (const path of paths) {
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(path.node.name)
        );
        binding.kind = rune === "$state" ? "state" : rune === "$state.raw" ? "raw_state" : rune === "$derived" || rune === "$derived.by" ? "derived" : path.is_rest ? "rest_prop" : "prop";
        if (rune === "$props" && binding.kind === "rest_prop" && node.id.type === "ObjectPattern") {
          const { properties } = node.id;
          const exclude_props = [];
          for (const property of properties) {
            if (property.type === "RestElement") {
              continue;
            }
            const key2 = (
              /** @type {Identifier | Literal & { value: string | number }} */
              property.key
            );
            exclude_props.push(key2.type === "Identifier" ? key2.name : key2.value.toString());
          }
          (binding.metadata ??= {}).exclude_props = exclude_props;
        }
      }
    }
    if (rune === "$props") {
      if (node.id.type !== "ObjectPattern" && node.id.type !== "Identifier") {
        props_invalid_identifier(node);
      }
      if (context.state.analysis.custom_element && context.state.options.customElementOptions?.props == null) {
        let warn_on;
        if (node.id.type === "Identifier" || (warn_on = node.id.properties.find((p) => p.type === "RestElement")) != null) {
          custom_element_props_identifier(warn_on ?? node.id);
        }
      }
      context.state.analysis.needs_props = true;
      if (node.id.type === "Identifier") {
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(node.id.name)
        );
        binding.initial = null;
        binding.kind = "rest_prop";
      } else {
        equal(node.id.type, "ObjectPattern");
        for (const property of node.id.properties) {
          if (property.type !== "Property") continue;
          if (property.computed) {
            props_invalid_pattern(property);
          }
          if (property.key.type === "Identifier" && property.key.name.startsWith("$$")) {
            props_illegal_name(property);
          }
          const value = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
          if (value.type !== "Identifier") {
            props_invalid_pattern(property);
          }
          const alias = property.key.type === "Identifier" ? property.key.name : String(
            /** @type {Literal} */
            property.key.value
          );
          let initial = property.value.type === "AssignmentPattern" ? property.value.right : null;
          const binding = (
            /** @type {Binding} */
            context.state.scope.get(value.name)
          );
          binding.prop_alias = alias;
          if (initial?.type === "CallExpression" && initial.callee.type === "Identifier" && initial.callee.name === "$bindable") {
            binding.initial = /** @type {Expression | null} */
            initial.arguments[0] ?? null;
            binding.kind = "bindable_prop";
          } else {
            binding.initial = initial;
          }
        }
      }
    }
  } else {
    if (node.init?.type === "CallExpression") {
      const callee = node.init.callee;
      if (callee.type === "Identifier" && (callee.name === "$state" || callee.name === "$derived" || callee.name === "$props") && context.state.scope.get(callee.name)?.kind !== "store_sub") {
        rune_invalid_usage(node.init, callee.name);
      }
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/2-analyze/index.js
var visitors3 = {
  _(node, { state, next: next2, path }) {
    const parent = path.at(-1);
    const ignores = [];
    if (parent?.type === "Fragment" && node.type !== "Comment" && node.type !== "Text") {
      const idx = parent.nodes.indexOf(
        /** @type {any} */
        node
      );
      for (let i = idx - 1; i >= 0; i--) {
        const prev = parent.nodes[i];
        if (prev.type === "Comment") {
          ignores.push(
            ...extract_svelte_ignore(
              prev.start + 4,
              prev.data,
              state.analysis.runes
            )
          );
        } else if (prev.type !== "Text") {
          break;
        }
      }
    } else {
      const comments = (
        /** @type {any} */
        node.leadingComments
      );
      if (comments) {
        for (const comment of comments) {
          ignores.push(
            ...extract_svelte_ignore(
              comment.start + 2,
              comment.value,
              state.analysis.runes
            )
          );
        }
      }
    }
    if (ignores.length > 0) {
      push_ignore(ignores);
    }
    ignore_map.set(node, structuredClone(ignore_stack));
    const scope = state.scopes.get(node);
    next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
    if (ignores.length > 0) {
      pop_ignore();
    }
  },
  AnimateDirective,
  ArrowFunctionExpression,
  AssignmentExpression,
  AttachTag,
  Attribute,
  AwaitBlock,
  AwaitExpression,
  BindDirective,
  CallExpression,
  ClassBody,
  ClassDeclaration,
  ClassDirective,
  Component,
  ConstTag,
  DebugTag,
  EachBlock,
  ExportDefaultDeclaration,
  ExportNamedDeclaration,
  ExportSpecifier,
  ExpressionStatement,
  ExpressionTag,
  Fragment,
  FunctionDeclaration,
  FunctionExpression,
  HtmlTag,
  Identifier,
  IfBlock,
  ImportDeclaration,
  KeyBlock,
  LabeledStatement,
  LetDirective,
  Literal,
  MemberExpression,
  NewExpression,
  OnDirective,
  PropertyDefinition,
  RegularElement,
  RenderTag,
  SlotElement,
  SnippetBlock,
  SpreadAttribute,
  SpreadElement,
  StyleDirective,
  SvelteBody,
  SvelteComponent,
  SvelteDocument,
  SvelteElement,
  SvelteFragment,
  SvelteHead,
  SvelteSelf,
  SvelteWindow,
  SvelteBoundary,
  TaggedTemplateExpression,
  TemplateElement,
  Text,
  TransitionDirective,
  TitleElement,
  UpdateExpression,
  UseDirective,
  VariableDeclarator
};
function js(script, root, allow_reactive_declarations, parent) {
  const ast = script?.content ?? {
    type: "Program",
    sourceType: "module",
    start: -1,
    end: -1,
    body: []
  };
  const { scope, scopes, has_await } = create_scopes(
    ast,
    root,
    allow_reactive_declarations,
    parent
  );
  return { ast, scope, scopes, has_await };
}
function get_component_name(filename2) {
  const parts = filename2.split(/[/\\]/);
  const basename = (
    /** @type {string} */
    parts.pop()
  );
  const last_dir = (
    /** @type {string} */
    parts.at(-1)
  );
  let name = basename.replace(".svelte", "");
  if (name === "index" && last_dir && last_dir !== "src") {
    name = last_dir;
  }
  return name[0].toUpperCase() + name.slice(1);
}
var RESERVED = ["$$props", "$$restProps", "$$slots"];
function analyze_component(root, source2, options) {
  const scope_root = new ScopeRoot();
  const module = js(root.module, scope_root, false, null);
  const instance = js(root.instance, scope_root, true, module.scope);
  const { scope, scopes, has_await } = create_scopes(
    root.fragment,
    scope_root,
    false,
    instance.scope
  );
  const template2 = { ast: root.fragment, scope, scopes };
  let synthetic_stores_legacy_check = [];
  for (const [name2, references] of module.scope.references) {
    if (name2[0] !== "$" || RESERVED.includes(name2)) continue;
    if (name2 === "$" || name2[1] === "$") {
      global_reference_invalid(references[0].node, name2);
    }
    const store_name = name2.slice(1);
    const declaration2 = instance.scope.get(store_name);
    const init3 = (
      /** @type {ESTree.Node | undefined} */
      declaration2?.initial
    );
    if (options.runes === false || !is_rune(name2) || declaration2 !== null && // const state = $state(0) is valid
    (get_rune(init3, instance.scope) === null || // rune-line names received as props are valid too (but we have to protect against $props as store)
    store_name !== "props" && get_rune(init3, instance.scope) === "$props") && // allow `import { derived } from 'svelte/store'` in the same file as `const x = $derived(..)` because one is not a subscription to the other
    !(name2 === "$derived" && declaration2.initial?.type === "ImportDeclaration" && declaration2.initial.source.value === "svelte/store")) {
      let is_nested_store_subscription_node = void 0;
      search: for (const reference of references) {
        for (let i = reference.path.length - 1; i >= 0; i--) {
          const scope2 = scopes.get(reference.path[i]) || module.scopes.get(reference.path[i]) || instance.scopes.get(reference.path[i]);
          if (scope2) {
            const owner = scope2?.owner(store_name);
            if (!!owner && owner !== module.scope && owner !== instance.scope) {
              is_nested_store_subscription_node = reference.node;
              break search;
            }
            break;
          }
        }
      }
      if (is_nested_store_subscription_node) {
        store_invalid_scoped_subscription(is_nested_store_subscription_node);
      }
      if (options.runes !== false) {
        if (declaration2 === null && /[a-z]/.test(store_name[0])) {
          global_reference_invalid(references[0].node, name2);
        } else if (declaration2 !== null && is_rune(name2)) {
          for (const { node, path } of references) {
            if (path.at(-1)?.type === "CallExpression") {
              store_rune_conflict(node, store_name);
            }
          }
        }
      }
      if (module.ast) {
        for (const { node, path } of references) {
          if (
            /** @type {number} */
            node.start > /** @type {number} */
            module.ast.start && /** @type {number} */
            node.end < /** @type {number} */
            module.ast.end && // const state = $state(0) is valid
            get_rune(
              /** @type {ESTree.Node} */
              path.at(-1),
              module.scope
            ) === null
          ) {
            store_invalid_subscription(node);
          }
        }
      }
      synthetic_stores_legacy_check.push(() => {
        if (declaration2 !== null && declaration2.kind === "normal" && declaration2.declaration_kind === "let" && declaration2.reassigned) {
          declaration2.kind = "state";
        }
      });
      const binding = instance.scope.declare(id(name2), "store_sub", "synthetic");
      binding.references = references;
      instance.scope.references.set(name2, references);
      module.scope.references.delete(name2);
    }
  }
  const component_name2 = get_component_name(options.filename);
  const runes2 = options.runes ?? (has_await || instance.has_await || Array.from(module.scope.references.keys()).some(is_rune));
  if (!runes2) {
    for (let check of synthetic_stores_legacy_check) {
      check();
    }
  }
  if (runes2 && root.module) {
    const context = root.module.attributes.find((attribute) => attribute.name === "context");
    if (context) {
      script_context_deprecated(context);
    }
  }
  const is_custom_element = !!options.customElementOptions || options.customElement;
  const name = module.scope.generate(options.name ?? component_name2);
  adjust({
    component_name: name,
    dev: options.dev,
    rootDir: options.rootDir,
    runes: runes2
  });
  const analysis = {
    name,
    root: scope_root,
    module,
    instance,
    template: template2,
    comments: root.comments,
    elements: [],
    runes: runes2,
    // if we are not in runes mode but we have no reserved references ($$props, $$restProps)
    // and no `export let` we might be in a wannabe runes component that is using runes in an external
    // module...we need to fallback to the runic behavior
    maybe_runes: !runes2 && // if they explicitly disabled runes, use the legacy behavior
    options.runes !== false && ![...module.scope.references.keys()].some(
      (name2) => ["$$props", "$$restProps"].includes(name2)
    ) && !instance.ast.body.some(
      (node) => node.type === "LabeledStatement" || node.type === "ExportNamedDeclaration" && (node.declaration && node.declaration.type === "VariableDeclaration" && node.declaration.kind === "let" || node.specifiers.some(
        (specifier) => specifier.local.type === "Identifier" && instance.scope.get(specifier.local.name)?.declaration_kind === "let"
      ))
    ),
    tracing: false,
    classes: /* @__PURE__ */ new Map(),
    immutable: runes2 || options.immutable,
    exports: [],
    uses_props: false,
    props_id: null,
    uses_rest_props: false,
    uses_slots: false,
    uses_component_bindings: false,
    uses_render_tags: false,
    needs_context: false,
    needs_mutation_validation: false,
    needs_props: false,
    event_directive_node: null,
    uses_event_attributes: false,
    custom_element: is_custom_element,
    inject_styles: options.css === "injected" || is_custom_element,
    accessors: is_custom_element || (runes2 ? false : !!options.accessors) || // because $set method needs accessors
    options.compatibility?.componentApi === 4,
    reactive_statements: /* @__PURE__ */ new Map(),
    binding_groups: /* @__PURE__ */ new Map(),
    slot_names: /* @__PURE__ */ new Map(),
    css: {
      ast: root.css,
      hash: root.css ? options.cssHash({
        css: root.css.content.styles,
        filename,
        name: component_name2,
        hash
      }) : "",
      keyframes: [],
      has_global: false
    },
    source: source2,
    snippet_renderers: /* @__PURE__ */ new Map(),
    snippets: /* @__PURE__ */ new Set(),
    async_deriveds: /* @__PURE__ */ new Set(),
    pickled_awaits: /* @__PURE__ */ new Set(),
    instance_body: {
      sync: [],
      async: [],
      declarations: [],
      hoisted: []
    }
  };
  if (!runes2) {
    for (const node of instance.ast.body) {
      if (node.type !== "ExportNamedDeclaration") continue;
      analysis.needs_props = true;
      if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          analysis.exports.push({
            name: (
              /** @type {import('estree').Identifier} */
              node.declaration.id.name
            ),
            alias: null
          });
        } else if (node.declaration.type === "VariableDeclaration") {
          if (node.declaration.kind === "const") {
            for (const declarator2 of node.declaration.declarations) {
              for (const node2 of extract_identifiers(declarator2.id)) {
                analysis.exports.push({ name: node2.name, alias: null });
              }
            }
          } else {
            for (const declarator2 of node.declaration.declarations) {
              for (const id2 of extract_identifiers(declarator2.id)) {
                const binding = (
                  /** @type {Binding} */
                  instance.scope.get(id2.name)
                );
                binding.kind = "bindable_prop";
              }
            }
          }
        }
      } else {
        for (const specifier of node.specifiers) {
          if (specifier.local.type !== "Identifier" || specifier.exported.type !== "Identifier") {
            continue;
          }
          const binding = instance.scope.get(specifier.local.name);
          if (binding && (binding.declaration_kind === "var" || binding.declaration_kind === "let")) {
            binding.kind = "bindable_prop";
            if (specifier.exported.name !== specifier.local.name) {
              binding.prop_alias = specifier.exported.name;
            }
          } else {
            analysis.exports.push({ name: specifier.local.name, alias: specifier.exported.name });
          }
        }
      }
    }
    for (const binding of instance.scope.declarations.values()) {
      if (binding.kind !== "normal") continue;
      for (const { node, path } of binding.references) {
        if (node === binding.node) continue;
        if (binding.updated) {
          if (path[path.length - 1].type === "StyleDirective" || path.some((node2) => node2.type === "Fragment") || path[1].type === "LabeledStatement" && path[1].label.name === "$") {
            binding.kind = "state";
          }
        }
      }
    }
    walk(
      /** @type {AST.SvelteNode} */
      template2.ast,
      null,
      {
        EachBlock(node) {
          const scope2 = (
            /** @type {Scope} */
            template2.scopes.get(node)
          );
          for (const binding of scope2.declarations.values()) {
            if (binding.updated) {
              const state = { scope: (
                /** @type {Scope} */
                scope2.parent
              ), scopes: template2.scopes };
              walk(node.expression, state, {
                // @ts-expect-error
                _: set_scope,
                Identifier(node2, context) {
                  const parent = (
                    /** @type {ESTree.Expression} */
                    context.path.at(-1)
                  );
                  if (is_reference(node2, parent)) {
                    const binding2 = context.state.scope.get(node2.name);
                    if (binding2 && binding2.kind === "normal" && binding2.declaration_kind !== "import") {
                      binding2.kind = "state";
                      binding2.mutated = true;
                    }
                  }
                }
              });
              break;
            }
          }
        }
      }
    );
  }
  if (root.options) {
    for (const attribute of root.options.attributes) {
      if (attribute.name === "accessors" && analysis.runes) {
        options_deprecated_accessors(attribute);
      }
      if (attribute.name === "customElement" && !options.customElement) {
        options_missing_custom_element(attribute);
      }
      if (attribute.name === "immutable" && analysis.runes) {
        options_deprecated_immutable(attribute);
      }
    }
  }
  calculate_blockers(instance, scopes, analysis);
  if (analysis.runes) {
    const props_refs = module.scope.references.get("$$props");
    if (props_refs) {
      legacy_props_invalid(props_refs[0].node);
    }
    const rest_props_refs = module.scope.references.get("$$restProps");
    if (rest_props_refs) {
      legacy_rest_props_invalid(rest_props_refs[0].node);
    }
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template2]) {
      const state = {
        scope: scope2,
        scopes: scopes2,
        analysis,
        options,
        ast_type: ast === instance.ast ? "instance" : ast === template2.ast ? "template" : "module",
        fragment: ast === template2.ast ? ast : null,
        parent_element: null,
        has_props_rune: false,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null,
        state_fields: /* @__PURE__ */ new Map(),
        function_depth: scope2.function_depth,
        reactive_statement: null,
        derived_function_depth: -1
      };
      walk(
        /** @type {AST.SvelteNode} */
        ast,
        state,
        visitors3
      );
    }
    for (const scope2 of [module.scope, instance.scope]) {
      outer: for (const [name2, binding] of scope2.declarations) {
        if (binding.kind === "normal" && binding.reassigned) {
          inner: for (const { path } of binding.references) {
            if (path[0].type !== "Fragment") continue;
            for (let i = 1; i < path.length; i += 1) {
              const type = path[i].type;
              if (type === "FunctionDeclaration" || type === "FunctionExpression" || type === "ArrowFunctionExpression") {
                continue inner;
              }
              if (type === "BindDirective" && /** @type {AST.BindDirective} */
              path[i].name === "this") {
                for (let j = i - 1; j >= 0; j -= 1) {
                  const type2 = path[j].type;
                  if (type2 === "IfBlock" || type2 === "EachBlock" || type2 === "AwaitBlock" || type2 === "KeyBlock") {
                    non_reactive_update(binding.node, name2);
                    continue outer;
                  }
                }
                continue inner;
              }
            }
            non_reactive_update(binding.node, name2);
            continue outer;
          }
        }
      }
    }
  } else {
    instance.scope.declare(id("$$props"), "rest_prop", "synthetic");
    instance.scope.declare(id("$$restProps"), "rest_prop", "synthetic");
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template2]) {
      const state = {
        scope: scope2,
        scopes: scopes2,
        analysis,
        options,
        fragment: ast === template2.ast ? ast : null,
        parent_element: null,
        has_props_rune: false,
        ast_type: ast === instance.ast ? "instance" : ast === template2.ast ? "template" : "module",
        reactive_statement: null,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null,
        state_fields: /* @__PURE__ */ new Map(),
        function_depth: scope2.function_depth,
        derived_function_depth: -1
      };
      walk(
        /** @type {AST.SvelteNode} */
        ast,
        state,
        visitors3
      );
    }
    for (const [name2, binding] of instance.scope.declarations) {
      if ((binding.kind === "prop" || binding.kind === "bindable_prop") && binding.node.name !== "$$props") {
        const references = binding.references.filter(
          (r2) => r2.node !== binding.node && r2.path.at(-1)?.type !== "ExportSpecifier"
        );
        if (!references.length && !instance.scope.declarations.has(`$${name2}`)) {
          export_let_unused(binding.node, name2);
        }
      }
    }
    analysis.reactive_statements = order_reactive_statements(analysis.reactive_statements);
  }
  for (const node of analysis.module.ast.body) {
    if (node.type === "ExportNamedDeclaration" && node.specifiers !== null && node.source == null) {
      for (const specifier of node.specifiers) {
        if (specifier.local.type !== "Identifier") continue;
        const name2 = specifier.local.name;
        const binding = analysis.module.scope.get(name2);
        if (!binding) {
          if ([...analysis.snippets].find((snippet) => snippet.expression.name === name2)) {
            snippet_invalid_export(specifier);
          } else {
            export_undefined(specifier, name2);
          }
        }
      }
    }
  }
  if (analysis.event_directive_node && analysis.uses_event_attributes) {
    mixed_event_handler_syntaxes(
      analysis.event_directive_node,
      analysis.event_directive_node.name
    );
  }
  for (const [node, resolved] of analysis.snippet_renderers) {
    if (!resolved) {
      node.metadata.snippets = analysis.snippets;
    }
    for (const snippet of node.metadata.snippets) {
      snippet.metadata.sites.add(node);
    }
  }
  if (analysis.uses_render_tags && (analysis.uses_slots || !analysis.custom_element && analysis.slot_names.size > 0)) {
    const pos = analysis.slot_names.values().next().value ?? analysis.source.indexOf("$$slot");
    slot_snippet_conflict(pos);
  }
  if (analysis.css.ast) {
    analyze_css(analysis.css.ast, analysis);
    for (const node of analysis.elements) {
      prune(analysis.css.ast, node);
    }
    const { comment } = analysis.css.ast.content;
    const should_ignore_unused = comment && extract_svelte_ignore(comment.start, comment.data, analysis.runes).includes(
      "css_unused_selector"
    );
    if (!should_ignore_unused) {
      warn_unused(analysis.css.ast);
    }
  }
  for (const node of analysis.elements) {
    if (node.metadata.scoped && is_custom_element_node(node)) {
      mark_subtree_dynamic(node.metadata.path);
    }
    let has_class = false;
    let has_style = false;
    let has_spread = false;
    let has_class_directive = false;
    let has_style_directive = false;
    for (const attribute of node.attributes) {
      if (attribute.type === "SpreadAttribute") {
        has_spread = true;
        break;
      } else if (attribute.type === "Attribute") {
        has_class ||= attribute.name.toLowerCase() === "class";
        has_style ||= attribute.name.toLowerCase() === "style";
      } else if (attribute.type === "ClassDirective") {
        has_class_directive = true;
      } else if (attribute.type === "StyleDirective") {
        has_style_directive = true;
      }
    }
    if (!has_spread && !has_class && (node.metadata.scoped || has_class_directive)) {
      node.attributes.push(
        create_attribute("class", -1, -1, [
          {
            type: "Text",
            data: "",
            raw: "",
            start: -1,
            end: -1
          }
        ])
      );
    }
    if (!has_spread && !has_style && has_style_directive) {
      node.attributes.push(
        create_attribute("style", -1, -1, [
          {
            type: "Text",
            data: "",
            raw: "",
            start: -1,
            end: -1
          }
        ])
      );
    }
  }
  return analysis;
}
function calculate_blockers(instance, scopes, analysis) {
  const touch = (expression, scope, touched, seen2 = /* @__PURE__ */ new Set()) => {
    if (seen2.has(expression)) return;
    seen2.add(expression);
    walk(
      expression,
      { scope },
      {
        ImportDeclaration(node) {
        },
        Identifier(node, context) {
          const parent = (
            /** @type {ESTree.Node} */
            context.path.at(-1)
          );
          if (is_reference(node, parent)) {
            const binding = context.state.scope.get(node.name);
            if (binding) {
              touched.add(binding);
              for (const assignment2 of binding.assignments) {
                touch(assignment2.value, assignment2.scope, touched, seen2);
              }
            }
          }
        }
      }
    );
  };
  const trace_references = (node, reads, writes, seen2 = /* @__PURE__ */ new Set()) => {
    if (seen2.has(node)) return;
    seen2.add(node);
    function update2(node2, scope) {
      for (const pattern of unwrap_pattern(node2)) {
        const node3 = object2(pattern);
        if (!node3) return;
        const binding = scope.get(node3.name);
        if (!binding) return;
        writes.add(binding);
      }
    }
    walk(
      node,
      { scope: instance.scope },
      {
        _(node2, context) {
          const scope = scopes.get(node2);
          if (scope) {
            context.next({ scope });
          } else {
            context.next();
          }
        },
        AssignmentExpression(node2, context) {
          update2(node2.left, context.state.scope);
        },
        UpdateExpression(node2, context) {
          update2(
            /** @type {ESTree.Identifier | ESTree.MemberExpression} */
            node2.argument,
            context.state.scope
          );
        },
        CallExpression(node2, context) {
          const rune = get_rune(node2, context.state.scope);
          if (rune === "$effect") return;
          const touched = /* @__PURE__ */ new Set();
          touch(node2, context.state.scope, touched);
          for (const b of touched) {
            writes.add(b);
          }
        },
        // don't look inside functions until they are called
        ArrowFunctionExpression(_2, context) {
        },
        FunctionDeclaration(_2, context) {
        },
        FunctionExpression(_2, context) {
        },
        Identifier(node2, context) {
          const parent = (
            /** @type {ESTree.Node} */
            context.path.at(-1)
          );
          if (is_reference(node2, parent)) {
            const binding = context.state.scope.get(node2.name);
            if (binding) {
              reads.add(binding);
            }
          }
        }
      }
    );
  };
  let awaited = false;
  const promises = id("$$promises");
  function push_declaration(id2, blocker) {
    analysis.instance_body.declarations.push(id2);
    const binding = (
      /** @type {Binding} */
      instance.scope.get(id2.name)
    );
    binding.blocker = blocker;
  }
  const functions = [];
  for (let node of instance.ast.body) {
    if (node.type === "ImportDeclaration") {
      analysis.instance_body.hoisted.push(node);
      continue;
    }
    if (node.type === "ExportDefaultDeclaration" || node.type === "ExportAllDeclaration") {
      continue;
    }
    if (node.type === "ExportNamedDeclaration") {
      if (node.declaration) {
        node = node.declaration;
      } else {
        continue;
      }
    }
    const has_await = has_await_expression(node);
    awaited ||= has_await;
    if (node.type === "FunctionDeclaration") {
      analysis.instance_body.sync.push(node);
      functions.push(node);
    } else if (node.type === "VariableDeclaration") {
      for (const declarator2 of node.declarations) {
        if (declarator2.init?.type === "ArrowFunctionExpression" || declarator2.init?.type === "FunctionExpression") {
          analysis.instance_body.sync.push(
            node.declarations.length === 1 ? node : declaration(node.kind, [declarator2])
          );
          functions.push(declarator2);
        } else if (!awaited) {
          analysis.instance_body.sync.push(
            node.declarations.length === 1 ? node : declaration(node.kind, [declarator2])
          );
        } else {
          const reads = /* @__PURE__ */ new Set();
          const writes = /* @__PURE__ */ new Set();
          trace_references(declarator2, reads, writes);
          const blocker = (
            /** @type {NonNullable<Binding['blocker']>} */
            member(promises, literal2(analysis.instance_body.async.length), true)
          );
          for (const binding of writes) {
            binding.blocker = blocker;
          }
          for (const id2 of extract_identifiers(declarator2.id)) {
            push_declaration(id2, blocker);
          }
          analysis.instance_body.async.push({
            node: declarator2,
            has_await
          });
        }
      }
    } else if (awaited) {
      const reads = /* @__PURE__ */ new Set();
      const writes = /* @__PURE__ */ new Set();
      trace_references(node, reads, writes);
      const blocker = (
        /** @type {NonNullable<Binding['blocker']>} */
        member(promises, literal2(analysis.instance_body.async.length), true)
      );
      for (const binding of writes) {
        binding.blocker = blocker;
      }
      if (node.type === "ClassDeclaration") {
        push_declaration(node.id, blocker);
        analysis.instance_body.async.push({ node, has_await });
      } else {
        analysis.instance_body.async.push({ node, has_await });
      }
    } else {
      analysis.instance_body.sync.push(node);
    }
  }
  for (const fn of functions) {
    const reads_writes = /* @__PURE__ */ new Set();
    const body = fn.type === "VariableDeclarator" ? (
      /** @type {ESTree.FunctionExpression | ESTree.ArrowFunctionExpression} */
      fn.init.body
    ) : fn.body;
    trace_references(body, reads_writes, reads_writes);
    const max = [...reads_writes].reduce((max2, binding2) => {
      if (binding2.blocker) {
        let property = (
          /** @type {ESTree.SimpleLiteral & { value: number }} */
          binding2.blocker.property
        );
        return Math.max(property.value, max2);
      }
      return max2;
    }, -1);
    if (max === -1) continue;
    const blocker = member(promises, literal2(max), true);
    const binding = (
      /** @type {Binding} */
      fn.type === "FunctionDeclaration" ? instance.scope.get(fn.id.name) : instance.scope.get(
        /** @type {ESTree.Identifier} */
        fn.id.name
      )
    );
    binding.blocker = /** @type {typeof binding['blocker']} */
    blocker;
  }
}
function order_reactive_statements(unsorted_reactive_declarations) {
  const lookup = /* @__PURE__ */ new Map();
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    for (const binding of declaration2.assignments) {
      const statements = lookup.get(binding.node.name) ?? [];
      statements.push([node, declaration2]);
      lookup.set(binding.node.name, statements);
    }
  }
  const edges = [];
  for (const [, { assignments, dependencies }] of unsorted_reactive_declarations) {
    for (const assignment2 of assignments) {
      for (const dependency2 of dependencies) {
        if (!assignments.has(dependency2)) {
          edges.push([assignment2.node.name, dependency2.node.name]);
        }
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle?.length) {
    const declaration2 = (
      /** @type {Tuple[]} */
      lookup.get(cycle[0])[0]
    );
    reactive_declaration_cycle(declaration2[0], cycle.join(" \u2192 "));
  }
  const reactive_declarations = /* @__PURE__ */ new Map();
  const add_declaration = (node, declaration2) => {
    if ([...reactive_declarations.values()].includes(declaration2)) return;
    for (const binding of declaration2.dependencies) {
      if (declaration2.assignments.has(binding)) continue;
      for (const [node2, earlier] of lookup.get(binding.node.name) ?? []) {
        add_declaration(node2, earlier);
      }
    }
    reactive_declarations.set(node, declaration2);
  };
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    add_declaration(node, declaration2);
  }
  return reactive_declarations;
}

// node_modules/.deno/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function decodeInteger(reader, relative) {
  let value = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = reader.next();
    integer = charToInt[c];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative + value;
}
function encodeInteger(builder, num, relative) {
  let delta = num - relative;
  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
  do {
    let clamped = delta & 31;
    delta >>>= 5;
    if (delta > 0) clamped |= 32;
    builder.write(intToChar[clamped]);
  } while (delta > 0);
  return num;
}
function hasMoreVlq(reader, max) {
  if (reader.pos >= max) return false;
  return reader.peek() !== comma;
}
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var StringWriter = class {
  constructor() {
    this.pos = 0;
    this.out = "";
    this.buffer = new Uint8Array(bufLength);
  }
  write(v) {
    const { buffer } = this;
    buffer[this.pos++] = v;
    if (this.pos === bufLength) {
      this.out += td.decode(buffer);
      this.pos = 0;
    }
  }
  flush() {
    const { buffer, out, pos } = this;
    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
  }
};
var StringReader = class {
  constructor(buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer, pos } = this;
    const idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};
function decode(mappings) {
  const { length } = mappings;
  const reader = new StringReader(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(";");
    const line = [];
    let sorted = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      let seg;
      genColumn = decodeInteger(reader, genColumn);
      if (genColumn < lastCol) sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader, semi)) {
        sourcesIndex = decodeInteger(reader, sourcesIndex);
        sourceLine = decodeInteger(reader, sourceLine);
        sourceColumn = decodeInteger(reader, sourceColumn);
        if (hasMoreVlq(reader, semi)) {
          namesIndex = decodeInteger(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted) sort(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[0] - b[0];
}
function encode(decoded) {
  const writer = new StringWriter();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) writer.write(semicolon);
    if (line.length === 0) continue;
    let genColumn = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (j > 0) writer.write(comma);
      genColumn = encodeInteger(writer, segment[0], genColumn);
      if (segment.length === 1) continue;
      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
      if (segment.length === 4) continue;
      namesIndex = encodeInteger(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}

// node_modules/.deno/esrap@2.1.3/node_modules/esrap/src/context.js
var margin = 0;
var newline = 1;
var indent = 2;
var dedent = 3;
var space = 4;
var Context = class _Context {
  #visitors;
  #commands;
  #has_newline = false;
  multiline = false;
  /**
   *
   * @param {Visitors} visitors
   * @param {Command[]} commands
   */
  constructor(visitors6, commands = []) {
    this.#visitors = visitors6;
    this.#commands = commands;
  }
  indent() {
    this.#commands.push(indent);
  }
  dedent() {
    this.#commands.push(dedent);
  }
  margin() {
    this.#commands.push(margin);
  }
  newline() {
    this.#has_newline = true;
    this.#commands.push(newline);
  }
  space() {
    this.#commands.push(space);
  }
  /**
   * @param {Context} context
   */
  append(context) {
    this.#commands.push(context.#commands);
    if (this.#has_newline) {
      this.multiline = true;
    }
  }
  /**
   *
   * @param {string} content
   * @param {BaseNode} [node]
   */
  write(content, node) {
    if (node?.loc) {
      this.location(node.loc.start.line, node.loc.start.column);
      this.#commands.push(content);
      this.location(node.loc.end.line, node.loc.end.column);
    } else {
      this.#commands.push(content);
    }
    if (this.#has_newline) {
      this.multiline = true;
    }
  }
  /**
   *
   * @param {number} line
   * @param {number} column
   */
  location(line, column) {
    this.#commands.push({ type: "Location", line, column });
  }
  /**
   * @param {{ type: string }} node
   */
  visit(node) {
    const visitor = this.#visitors[node.type];
    if (!visitor) {
      let message = `Not implemented: ${node.type}`;
      if (node.type.includes("TS")) {
        message += ` (consider using 'esrap/languages/ts')`;
      }
      if (node.type.includes("JSX")) {
        message += ` (consider using 'esrap/languages/tsx')`;
      }
      throw new Error(message);
    }
    if (this.#visitors._) {
      this.#visitors._(node, this, (node2) => visitor(node2, this));
    } else {
      visitor(node, this);
    }
  }
  empty() {
    return !this.#commands.some(has_content2);
  }
  measure() {
    return measure(this.#commands);
  }
  new() {
    return new _Context(this.#visitors);
  }
};
function measure(commands, from = 0, to = commands.length) {
  let total = 0;
  for (let i = from; i < to; i += 1) {
    const command = commands[i];
    if (typeof command === "string") {
      total += command.length;
    } else if (Array.isArray(command)) {
      total += measure(command);
    }
  }
  return total;
}
function has_content2(command) {
  if (Array.isArray(command)) {
    return command.some(has_content2);
  }
  if (typeof command === "string") {
    return command.length > 0;
  }
  return false;
}

// node_modules/.deno/esrap@2.1.3/node_modules/esrap/src/index.js
var btoa2 = () => {
  throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa2 = (str2) => window.btoa(unescape(encodeURIComponent(str2)));
} else if (typeof Buffer === "function") {
  btoa2 = (str2) => Buffer.from(str2, "utf-8").toString("base64");
}
var SourceMap = class {
  version = 3;
  /** @type {string[]} */
  names = [];
  /**
   * @param {[number, number, number, number][][]} mappings
   * @param {PrintOptions} opts
   */
  constructor(mappings, opts) {
    this.sources = [opts.sourceMapSource || null];
    this.sourcesContent = [opts.sourceMapContent || null];
    this.mappings = opts.sourceMapEncodeMappings === false ? mappings : encode(mappings);
  }
  /**
   * Returns a JSON representation suitable for saving as a `*.map` file
   */
  toString() {
    return JSON.stringify(this);
  }
  /**
   * Returns a base64-encoded JSON representation suitable for inlining at the bottom of a file with `//# sourceMappingURL={...}`
   */
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa2(this.toString());
  }
};
function print(node, visitors6, opts = {}) {
  const commands = [];
  const context = new Context(visitors6, commands);
  context.visit(node);
  let code = "";
  let current_column = 0;
  let mappings = [];
  let current_line = [];
  function append(str2) {
    code += str2;
    for (let i = 0; i < str2.length; i += 1) {
      if (str2[i] === "\n") {
        mappings.push(current_line);
        current_line = [];
        current_column = 0;
      } else {
        current_column += 1;
      }
    }
  }
  let current_newline = "\n";
  const indent_str = opts.indent ?? "	";
  let needs_newline = false;
  let needs_margin = false;
  let needs_space = false;
  function run(command) {
    if (Array.isArray(command)) {
      for (let i = 0; i < command.length; i += 1) {
        run(command[i]);
      }
      return;
    }
    if (typeof command === "number") {
      if (command === newline) {
        needs_newline = true;
      } else if (command === margin) {
        needs_margin = true;
      } else if (command === space) {
        needs_space = true;
      } else if (command === indent) {
        current_newline += indent_str;
      } else if (command === dedent) {
        current_newline = current_newline.slice(0, -indent_str.length);
      }
      return;
    }
    if (needs_newline) {
      append(needs_margin ? "\n" + current_newline : current_newline);
    } else if (needs_space) {
      append(" ");
    }
    needs_margin = needs_newline = needs_space = false;
    if (typeof command === "string") {
      append(command);
      return;
    }
    if (command.type === "Location") {
      current_line.push([
        current_column,
        0,
        // source index is always zero
        command.line - 1,
        command.column
      ]);
    }
  }
  for (let i = 0; i < commands.length; i += 1) {
    run(commands[i]);
  }
  mappings.push(current_line);
  let map;
  return {
    code,
    // create sourcemap lazily in case we don't need it
    get map() {
      return map ??= new SourceMap(mappings, opts);
    }
  };
}

// node_modules/.deno/esrap@2.1.3/node_modules/esrap/src/languages/ts/index.js
var EXPRESSIONS_PRECEDENCE = {
  JSXFragment: 20,
  JSXElement: 20,
  ArrayPattern: 20,
  ObjectPattern: 20,
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  MetaProperty: 19,
  CallExpression: 19,
  ChainExpression: 19,
  ImportExpression: 19,
  NewExpression: 19,
  Literal: 18,
  TSSatisfiesExpression: 18,
  TSInstantiationExpression: 18,
  TSNonNullExpression: 18,
  TSTypeAssertion: 18,
  AwaitExpression: 17,
  ClassExpression: 17,
  FunctionExpression: 17,
  ObjectExpression: 17,
  TSAsExpression: 16,
  UpdateExpression: 16,
  UnaryExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  ArrowFunctionExpression: 3,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "&&": 3,
  "??": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
function write_comment(comment, context) {
  if (comment.type === "Line") {
    context.write(`//${comment.value}`);
  } else {
    context.write("/*");
    const lines = comment.value.split("\n");
    for (let i = 0; i < lines.length; i += 1) {
      if (i > 0) context.newline();
      context.write(lines[i]);
    }
    context.write("*/");
  }
}
var ts_default = (options = {}) => {
  const quote_char = options.quotes === "double" ? '"' : "'";
  const comments = options.comments ?? [];
  let comment_index = 0;
  function reset_comment_index(node) {
    if (!node.loc) {
      comment_index = comments.length;
      return;
    }
    let previous = comments[comment_index - 1];
    let comment = comments[comment_index];
    if (comment && comment.loc && !before(comment.loc.start, node.loc.start) && (!previous || previous.loc && before(previous.loc.start, node.loc.start))) {
      return;
    }
    comment_index = comments.findIndex(
      (comment2) => comment2.loc && node.loc && !before(comment2.loc.start, node.loc.start)
    );
    if (comment_index === -1) comment_index = comments.length;
  }
  function flush_trailing_comments(context, prev, next2) {
    while (comment_index < comments.length) {
      const comment = comments[comment_index];
      if (comment && prev && comment.loc.start.line === prev.line && (next2 === null || before(comment.loc.end, next2))) {
        context.write(" ");
        write_comment(comment, context);
        comment_index += 1;
        if (comment.type === "Line") {
          context.newline();
        } else {
          continue;
        }
      }
      break;
    }
  }
  function flush_comments_until(context, from, to, pad) {
    let first = true;
    while (comment_index < comments.length) {
      const comment = comments[comment_index];
      if (comment && comment.loc && to && before(comment.loc.start, to)) {
        if (first && from !== null && comment.loc.start.line > from.line) {
          context.margin();
          context.newline();
        }
        first = false;
        write_comment(comment, context);
        if (comment.loc.end.line < to.line) {
          context.newline();
        } else if (pad) {
          context.write(" ");
        }
        comment_index += 1;
      } else {
        break;
      }
    }
  }
  function sequence2(context, nodes, until, pad, separator = ",") {
    let multiline = false;
    let length = -1;
    const multiline_nodes = [];
    const children = nodes.map((child, i) => {
      const child_context = context.new();
      if (child) child_context.visit(child);
      multiline_nodes[i] = child_context.multiline;
      if (i < nodes.length - 1 || !child) {
        child_context.write(separator);
      }
      const next2 = i === nodes.length - 1 ? until : nodes[i + 1]?.loc?.start || null;
      flush_trailing_comments(child_context, child?.loc?.end || null, next2);
      length += child_context.measure() + 1;
      multiline ||= child_context.multiline;
      return child_context;
    });
    multiline ||= length > 60;
    if (multiline) {
      context.indent();
      context.newline();
    } else if (pad && length > 0) {
      context.write(" ");
    }
    let prev = null;
    for (let i = 0; i < nodes.length; i += 1) {
      const child = children[i];
      if (prev !== null) {
        if (multiline_nodes[i - 1] || multiline_nodes[i]) {
          context.margin();
        }
        if (nodes[i]) {
          if (multiline) {
            context.newline();
          } else {
            context.write(" ");
          }
        }
      }
      context.append(child);
      prev = child;
    }
    flush_comments_until(context, nodes[nodes.length - 1]?.loc?.end ?? null, until, false);
    if (multiline) {
      context.dedent();
      context.newline();
    } else if (pad && length > 0) {
      context.write(" ");
    }
  }
  function body(context, node) {
    reset_comment_index(node);
    let prev_type = null;
    let prev_multiline = false;
    for (let i = 0; i < node.body.length; i += 1) {
      const child = node.body[i];
      if (child.type === "EmptyStatement") continue;
      const child_context = context.new();
      child_context.visit(child);
      if (prev_type !== null) {
        if (child_context.multiline || prev_multiline || child.type !== prev_type) {
          context.margin();
        }
        context.newline();
      }
      context.append(child_context);
      flush_trailing_comments(
        context,
        child.loc?.end || null,
        node.body[i + 1]?.loc?.end ?? node.loc?.end ?? null
      );
      prev_type = child.type;
      prev_multiline = child_context.multiline;
    }
    if (node.loc) {
      context.newline();
      flush_comments_until(
        context,
        node.body[node.body.length - 1]?.loc?.end ?? null,
        node.loc.end,
        false
      );
    }
  }
  const shared = {
    /**
     * @param {TSESTree.ArrayExpression | TSESTree.ArrayPattern} node
     * @param {Context} context
     */
    "ArrayExpression|ArrayPattern": (node, context) => {
      context.write("[");
      sequence2(
        context,
        /** @type {TSESTree.Node[]} */
        node.elements,
        node.loc?.end ?? null,
        false
      );
      context.write("]");
    },
    /**
     * @param {TSESTree.BinaryExpression | TSESTree.LogicalExpression} node
     * @param {Context} context
     */
    "BinaryExpression|LogicalExpression": (node, context) => {
      if (needs_parens(node.left, node, false)) {
        context.write("(");
        context.visit(node.left);
        context.write(")");
      } else {
        context.visit(node.left);
      }
      context.write(` ${node.operator} `);
      if (needs_parens(node.right, node, true)) {
        context.write("(");
        context.visit(node.right);
        context.write(")");
      } else {
        context.visit(node.right);
      }
    },
    /**
     * @param {TSESTree.BlockStatement | TSESTree.ClassBody} node
     * @param {Context} context
     */
    "BlockStatement|ClassBody": (node, context) => {
      if (node.loc) {
        const { line, column } = node.loc.start;
        context.location(line, column);
        context.write("{");
        context.location(line, column + 1);
      } else {
        context.write("{");
      }
      const child_context = context.new();
      body(child_context, node);
      if (!child_context.empty()) {
        context.indent();
        context.newline();
        context.append(child_context);
        context.dedent();
        context.newline();
      }
      if (node.loc) {
        const { line, column } = node.loc.end;
        context.location(line, column - 1);
        context.write("}");
        context.location(line, column);
      } else {
        context.write("}");
      }
    },
    /**
     * @param {TSESTree.CallExpression | TSESTree.NewExpression} node
     * @param {Context} context
     */
    "CallExpression|NewExpression": (node, context) => {
      if (node.type === "NewExpression") {
        context.write("new ");
      }
      const needs_parens2 = EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || node.type === "NewExpression" && has_call_expression(node.callee);
      if (needs_parens2) {
        context.write("(");
        context.visit(node.callee);
        context.write(")");
      } else {
        context.visit(node.callee);
      }
      if (
        /** @type {TSESTree.CallExpression} */
        node.optional
      ) {
        context.write("?.");
      }
      if (node.typeArguments) context.visit(node.typeArguments);
      const open2 = context.new();
      const join = context.new();
      context.write("(");
      context.append(open2);
      const child_context = context.new();
      const final_context = context.new();
      context.append(child_context);
      context.append(final_context);
      for (let i = 0; i < node.arguments.length; i += 1) {
        const is_last = i === node.arguments.length - 1;
        const context2 = is_last ? final_context : child_context;
        const arg = node.arguments[i];
        if (is_last && arg.loc && comments[comment_index] && comments[comment_index].loc && comments[comment_index].loc.start.line < arg.loc.start.line) {
          child_context.multiline = true;
        }
        context2.visit(arg);
        if (!is_last) context2.write(",");
        const next2 = is_last ? node.loc?.end ?? null : node.arguments[i + 1]?.loc?.start ?? null;
        flush_trailing_comments(context2, arg.loc?.end ?? null, next2);
        if (!is_last) context2.append(join);
      }
      context.multiline ||= child_context.multiline || final_context.multiline;
      if (child_context.multiline) {
        open2.indent();
        open2.newline();
        join.newline();
        context.dedent();
        context.newline();
      } else {
        join.write(" ");
      }
      context.write(")");
    },
    /**
     * @param {TSESTree.ClassDeclaration | TSESTree.ClassExpression} node
     * @param {Context} context
     */
    "ClassDeclaration|ClassExpression": (node, context) => {
      if (node.decorators) {
        for (const decorator of node.decorators) {
          context.visit(decorator);
        }
      }
      if (node.declare) {
        context.write("declare ");
      }
      if (node.abstract) context.write("abstract ");
      context.write("class ");
      if (node.id) {
        context.visit(node.id);
        context.write(" ");
      }
      if (node.superClass) {
        context.write("extends ");
        context.visit(node.superClass);
        context.write(" ");
      }
      if (node.implements && node.implements.length > 0) {
        context.write("implements");
        sequence2(context, node.implements, node.body.loc?.start ?? null, true);
      }
      context.visit(node.body);
    },
    /**
     * @param {TSESTree.ForInStatement | TSESTree.ForOfStatement} node
     * @param {Context} context
     */
    "ForInStatement|ForOfStatement": (node, context) => {
      context.write("for ");
      if (node.type === "ForOfStatement" && node.await) context.write("await ");
      context.write("(");
      if (node.left.type === "VariableDeclaration") {
        handle_var_declaration(node.left, context);
      } else {
        context.visit(node.left);
      }
      context.write(node.type === "ForInStatement" ? " in " : " of ");
      context.visit(node.right);
      context.write(") ");
      context.visit(node.body);
    },
    /**
     * @param {TSESTree.FunctionDeclaration | TSESTree.FunctionExpression} node
     * @param {Context} context
     */
    "FunctionDeclaration|FunctionExpression": (node, context) => {
      if (node.async) context.write("async ");
      context.write(node.generator ? "function* " : "function ");
      if (node.id) context.visit(node.id);
      if (node.typeParameters) {
        context.visit(node.typeParameters);
      }
      context.write("(");
      sequence2(context, node.params, (node.returnType ?? node.body).loc?.start ?? null, false);
      context.write(")");
      if (node.returnType) context.visit(node.returnType);
      context.write(" ");
      context.visit(node.body);
    },
    /**
     * @param {TSESTree.MethodDefinition | TSESTree.TSAbstractMethodDefinition} node
     * @param {Context} context
     */
    "MethodDefinition|TSAbstractMethodDefinition": (node, context) => {
      if (node.decorators) {
        for (const decorator of node.decorators) {
          context.visit(decorator);
        }
      }
      if (node.abstract || node.type === "TSAbstractMethodDefinition") {
        context.write("abstract ");
      }
      if (node.static) {
        context.write("static ");
      }
      if (node.kind === "get" || node.kind === "set") {
        context.write(node.kind + " ");
      }
      if (node.value.async) {
        context.write("async ");
      }
      if (node.value.generator) {
        context.write("*");
      }
      if (node.computed) context.write("[");
      context.visit(node.key);
      if (node.computed) context.write("]");
      context.write("(");
      sequence2(
        context,
        node.value.params,
        (node.value.returnType ?? node.value.body)?.loc?.start ?? node.loc?.end ?? null,
        false
      );
      context.write(")");
      if (node.value.returnType) context.visit(node.value.returnType);
      context.write(" ");
      if (node.value.body) context.visit(node.value.body);
    },
    /**
     * @param {TSESTree.PropertyDefinition | TSESTree.TSAbstractPropertyDefinition | TSESTree.AccessorProperty | TSESTree.TSAbstractAccessorProperty} node
     * @param {Context} context
     */
    "PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty": (node, context) => {
      if (node.decorators) {
        for (const decorator of node.decorators) {
          context.visit(decorator);
        }
      }
      if (node.accessibility) {
        context.write(node.accessibility + " ");
      }
      if (
        // @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
        node.abstract || node.type === "TSAbstractPropertyDefinition" || node.type === "TSAbstractAccessorProperty"
      ) {
        context.write("abstract ");
      }
      if (node.static) {
        context.write("static ");
      }
      if (
        // @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
        node.accessor || node.type === "AccessorProperty" || node.type === "TSAbstractAccessorProperty"
      ) {
        context.write("accessor ");
      }
      if (node.computed) {
        context.write("[");
        context.visit(node.key);
        context.write("]");
      } else {
        context.visit(node.key);
      }
      if (node.typeAnnotation) {
        if (node.type === "AccessorProperty" || node.type === "TSAbstractAccessorProperty") {
          context.visit(node.typeAnnotation);
        } else {
          context.write(": ");
          context.visit(node.typeAnnotation.typeAnnotation);
        }
      }
      if (node.value) {
        context.write(" = ");
        context.visit(node.value);
      }
      context.write(";");
      flush_trailing_comments(
        context,
        (node.value ?? node.typeAnnotation ?? node.key).loc?.end ?? null,
        null
      );
    },
    /**
     * @param {TSESTree.RestElement | TSESTree.SpreadElement} node
     * @param {Context} context
     */
    "RestElement|SpreadElement": (node, context) => {
      context.write("...");
      context.visit(node.argument);
      if (node.typeAnnotation) context.visit(node.typeAnnotation);
    },
    /**
     * @param {TSESTree.TSConstructSignatureDeclaration | TSESTree.TSCallSignatureDeclaration} node
     * @param {Context} context
     */
    "TSConstructSignatureDeclaration|TSCallSignatureDeclaration": (node, context) => {
      if (node.type === "TSConstructSignatureDeclaration") context.write("new");
      if (node.typeParameters) {
        context.visit(node.typeParameters);
      }
      context.write("(");
      sequence2(
        context,
        // @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
        node.parameters ?? node.params,
        // @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
        (node.typeAnnotation ?? node.returnType)?.loc?.start ?? null,
        false
      );
      context.write(")");
      if (node.typeAnnotation || node.returnType) {
        context.visit(node.typeAnnotation ?? node.returnType);
      }
    },
    /**
     * @param {TSESTree.TSFunctionType | TSESTree.TSConstructorType} node
     * @param {Context} context
     */
    "TSFunctionType|TSConstructorType": (node, context) => {
      if (node.type === "TSConstructorType") context.write("new ");
      if (node.typeParameters) context.visit(node.typeParameters);
      context.write("(");
      sequence2(
        context,
        // @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
        node.parameters ?? node.params,
        // @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
        node.typeAnnotation?.typeAnnotation?.loc?.start ?? node.returnType?.typeAnnotation?.loc?.start ?? null,
        false
      );
      context.write(") => ");
      context.visit(node.typeAnnotation?.typeAnnotation ?? node.returnType?.typeAnnotation);
    }
  };
  return {
    _(node, context, visit) {
      if (node.loc) {
        flush_comments_until(context, null, node.loc.start, true);
      }
      visit(node);
    },
    AccessorProperty: shared["PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty"],
    ArrayExpression: shared["ArrayExpression|ArrayPattern"],
    ArrayPattern: shared["ArrayExpression|ArrayPattern"],
    ArrowFunctionExpression: (node, context) => {
      if (node.async) context.write("async ");
      context.write("(");
      sequence2(context, node.params, node.body.loc?.start ?? null, false);
      context.write(") => ");
      if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern" || node.body.type === "LogicalExpression" && node.body.left.type === "ObjectExpression" || node.body.type === "ConditionalExpression" && node.body.test.type === "ObjectExpression") {
        context.write("(");
        context.visit(node.body);
        context.write(")");
      } else {
        context.visit(node.body);
      }
    },
    AssignmentExpression(node, context) {
      context.visit(node.left);
      context.write(` ${node.operator} `);
      context.visit(node.right);
    },
    AssignmentPattern(node, context) {
      context.visit(node.left);
      context.write(" = ");
      context.visit(node.right);
    },
    AwaitExpression(node, context) {
      if (node.argument) {
        const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
        if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
          context.write("await (");
          context.visit(node.argument);
          context.write(")");
        } else {
          context.write("await ");
          context.visit(node.argument);
        }
      } else {
        context.write("await");
      }
    },
    BinaryExpression: shared["BinaryExpression|LogicalExpression"],
    BlockStatement: shared["BlockStatement|ClassBody"],
    BreakStatement(node, context) {
      if (node.label) {
        context.write("break ");
        context.visit(node.label);
        context.write(";");
      } else {
        context.write("break;");
      }
    },
    CallExpression: shared["CallExpression|NewExpression"],
    ChainExpression(node, context) {
      context.visit(node.expression);
    },
    ClassBody: shared["BlockStatement|ClassBody"],
    ClassDeclaration: shared["ClassDeclaration|ClassExpression"],
    ClassExpression: shared["ClassDeclaration|ClassExpression"],
    ConditionalExpression(node, context) {
      if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
        context.visit(node.test);
      } else {
        context.write("(");
        context.visit(node.test);
        context.write(")");
      }
      const consequent = context.new();
      const alternate = context.new();
      consequent.visit(node.consequent);
      alternate.visit(node.alternate);
      if (consequent.multiline || alternate.multiline || consequent.measure() + alternate.measure() > 50) {
        context.indent();
        context.newline();
        context.write("? ");
        context.append(consequent);
        context.newline();
        context.write(": ");
        context.append(alternate);
        context.dedent();
      } else {
        context.write(" ? ");
        context.append(consequent);
        context.write(" : ");
        context.append(alternate);
      }
    },
    ContinueStatement(node, context) {
      if (node.label) {
        context.write("continue ");
        context.visit(node.label);
        context.write(";");
      } else {
        context.write("continue;");
      }
    },
    DebuggerStatement(node, context) {
      context.write("debugger", node);
      context.write(";");
    },
    Decorator(node, context) {
      context.write("@");
      context.visit(node.expression);
      context.newline();
    },
    DoWhileStatement(node, context) {
      context.write("do ");
      context.visit(node.body);
      context.write(" while (");
      context.visit(node.test);
      context.write(");");
    },
    EmptyStatement(node, context) {
      context.write(";");
    },
    ExportAllDeclaration(node, context) {
      context.write(node.exportKind === "type" ? "export type * " : "export * ");
      if (node.exported) {
        context.write("as ");
        context.visit(node.exported);
      }
      context.write(" from ");
      context.visit(node.source);
      context.write(";");
    },
    ExportDefaultDeclaration(node, context) {
      context.write("export default ");
      context.visit(node.declaration);
      if (node.declaration.type !== "FunctionDeclaration") {
        context.write(";");
      }
    },
    ExportNamedDeclaration(node, context) {
      if (node.declaration) {
        const decl = (
          /** @type {any} */
          node.declaration
        );
        if (decl.decorators && decl.decorators.length > 0) {
          for (const decorator of decl.decorators) {
            context.visit(decorator);
          }
          context.write("export ");
          const savedDecorators = decl.decorators;
          decl.decorators = [];
          context.visit(node.declaration);
          decl.decorators = savedDecorators;
        } else {
          context.write("export ");
          context.visit(node.declaration);
        }
        return;
      }
      context.write("export ");
      if (node.exportKind === "type") {
        context.write("type ");
      }
      context.write("{");
      sequence2(context, node.specifiers, node.source?.loc?.start ?? node.loc?.end ?? null, true);
      context.write("}");
      if (node.source) {
        context.write(" from ");
        context.visit(node.source);
      }
      context.write(";");
    },
    ExportSpecifier(node, context) {
      if (node.exportKind === "type") {
        context.write("type ");
      }
      context.visit(node.local);
      if (node.local.type === "Identifier" && node.exported.type === "Identifier" && node.local.name !== node.exported.name) {
        context.write(" as ");
        context.visit(node.exported);
      }
    },
    ExpressionStatement(node, context) {
      if (node.expression.type === "ObjectExpression" || node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern" || node.expression.type === "FunctionExpression") {
        context.write("(");
        context.visit(node.expression);
        context.write(");");
        return;
      }
      context.visit(node.expression);
      context.write(";");
    },
    ForStatement: (node, context) => {
      context.write("for (");
      if (node.init) {
        if (node.init.type === "VariableDeclaration") {
          handle_var_declaration(node.init, context);
        } else {
          context.visit(node.init);
        }
      }
      context.write("; ");
      if (node.test) context.visit(node.test);
      context.write("; ");
      if (node.update) context.visit(node.update);
      context.write(") ");
      context.visit(node.body);
    },
    ForInStatement: shared["ForInStatement|ForOfStatement"],
    ForOfStatement: shared["ForInStatement|ForOfStatement"],
    FunctionDeclaration: shared["FunctionDeclaration|FunctionExpression"],
    FunctionExpression: shared["FunctionDeclaration|FunctionExpression"],
    Identifier(node, context) {
      let name = node.name;
      context.write(name, node);
      if (node.typeAnnotation) context.visit(node.typeAnnotation);
    },
    IfStatement(node, context) {
      context.write("if (");
      context.visit(node.test);
      context.write(") ");
      context.visit(node.consequent);
      if (node.alternate) {
        context.space();
        context.write("else ");
        context.visit(node.alternate);
      }
    },
    ImportDeclaration(node, context) {
      if (node.specifiers.length === 0) {
        context.write("import ");
        context.visit(node.source);
        context.write(";");
        return;
      }
      let namespace_specifier = null;
      let default_specifier = null;
      const named_specifiers = [];
      for (const s of node.specifiers) {
        if (s.type === "ImportNamespaceSpecifier") {
          namespace_specifier = s;
        } else if (s.type === "ImportDefaultSpecifier") {
          default_specifier = s;
        } else {
          named_specifiers.push(s);
        }
      }
      context.write("import ");
      if (node.importKind == "type") context.write("type ");
      if (default_specifier) {
        context.write(default_specifier.local.name, default_specifier);
        if (namespace_specifier || named_specifiers.length > 0) context.write(", ");
      }
      if (namespace_specifier) {
        context.write("* as " + namespace_specifier.local.name, namespace_specifier);
      }
      if (named_specifiers.length > 0) {
        context.write("{");
        sequence2(context, named_specifiers, node.source.loc?.start ?? null, true);
        context.write("}");
      }
      context.write(" from ");
      context.visit(node.source);
      if (node.attributes && node.attributes.length > 0) {
        context.write(" with { ");
        for (let index = 0; index < node.attributes.length; index++) {
          const { key: key2, value } = node.attributes[index];
          context.visit(key2);
          context.write(": ");
          context.visit(value);
          if (index + 1 !== node.attributes.length) {
            context.write(", ");
          }
        }
        context.write(" }");
      }
      context.write(";");
    },
    ImportExpression(node, context) {
      context.write("import(");
      context.visit(node.source);
      if (node.arguments) {
        for (let index = 0; index < node.arguments.length; index++) {
          context.write(", ");
          context.visit(node.arguments[index]);
        }
      }
      if (node.options) {
        context.write(", ");
        context.visit(node.options);
      }
      context.write(")");
    },
    ImportSpecifier(node, context) {
      if (node.local.type === "Identifier" && node.imported.type === "Identifier" && node.local.name !== node.imported.name) {
        context.visit(node.imported);
        context.write(" as ");
      }
      if (node.importKind == "type") context.write("type ");
      context.visit(node.local);
    },
    LabeledStatement(node, context) {
      context.visit(node.label);
      context.write(": ");
      context.visit(node.body);
    },
    Literal(node, context) {
      const value = node.raw || (typeof node.value === "string" ? quote(node.value, quote_char) : String(node.value));
      context.write(value, node);
    },
    LogicalExpression: shared["BinaryExpression|LogicalExpression"],
    MemberExpression(node, context) {
      if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
        context.write("(");
        context.visit(node.object);
        context.write(")");
      } else {
        context.visit(node.object);
      }
      if (node.computed) {
        if (node.optional) {
          context.write("?.");
        }
        context.write("[");
        context.visit(node.property);
        context.write("]");
      } else {
        context.write(node.optional ? "?." : ".");
        context.visit(node.property);
      }
    },
    MetaProperty(node, context) {
      context.visit(node.meta);
      context.write(".");
      context.visit(node.property);
    },
    MethodDefinition: shared["MethodDefinition|TSAbstractMethodDefinition"],
    NewExpression: shared["CallExpression|NewExpression"],
    ObjectExpression(node, context) {
      context.write("{");
      sequence2(context, node.properties, node.loc?.end ?? null, true);
      context.write("}");
    },
    ObjectPattern(node, context) {
      context.write("{");
      sequence2(context, node.properties, node.loc?.end ?? null, true);
      context.write("}");
      if (node.typeAnnotation) context.visit(node.typeAnnotation);
    },
    // @ts-expect-error this isn't a real node type, but Acorn produces it
    ParenthesizedExpression(node, context) {
      context.write("(");
      context.visit(node.expression);
      context.write(")");
    },
    PrivateIdentifier(node, context) {
      context.write("#");
      context.write(node.name, node);
    },
    Program(node, context) {
      body(context, node);
    },
    Property(node, context) {
      const value = node.value.type === "AssignmentPattern" ? node.value.left : node.value;
      const shorthand = !node.computed && node.kind === "init" && node.key.type === "Identifier" && value.type === "Identifier" && node.key.name === value.name;
      if (shorthand) {
        context.visit(node.value);
        return;
      }
      if (node.value.type === "FunctionExpression") {
        if (node.kind !== "init") context.write(node.kind + " ");
        if (node.value.async) context.write("async ");
        if (node.value.generator) context.write("*");
        if (node.computed) context.write("[");
        context.visit(node.key);
        if (node.computed) context.write("]");
        context.write("(");
        sequence2(
          context,
          node.value.params,
          (node.value.returnType ?? node.value.body).loc?.start ?? null,
          false
        );
        context.write(")");
        if (node.value.returnType) context.visit(node.value.returnType);
        context.write(" ");
        context.visit(node.value.body);
      } else {
        if (node.computed) context.write("[");
        if (node.kind === "get" || node.kind === "set") context.write(node.kind + " ");
        context.visit(node.key);
        context.write(node.computed ? "]: " : ": ");
        context.visit(node.value);
      }
    },
    PropertyDefinition: shared["PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty"],
    RestElement: shared["RestElement|SpreadElement"],
    ReturnStatement(node, context) {
      if (node.argument) {
        const contains_comment = comments[comment_index] && comments[comment_index].loc && node.argument.loc && before(comments[comment_index].loc.start, node.argument.loc.start);
        context.write(contains_comment ? "return (" : "return ");
        context.visit(node.argument);
        context.write(contains_comment ? ");" : ";");
      } else {
        context.write("return;");
      }
    },
    SequenceExpression(node, context) {
      context.write("(");
      sequence2(context, node.expressions, node.loc?.end ?? null, false);
      context.write(")");
    },
    SpreadElement: shared["RestElement|SpreadElement"],
    StaticBlock(node, context) {
      context.write("static {");
      context.indent();
      context.newline();
      body(context, node);
      context.dedent();
      context.newline();
      context.write("}");
    },
    Super(node, context) {
      context.write("super", node);
    },
    SwitchStatement(node, context) {
      context.write("switch (");
      context.visit(node.discriminant);
      context.write(") {");
      context.indent();
      let first = true;
      for (const block2 of node.cases) {
        if (!first) {
          context.margin();
        }
        first = false;
        if (block2.test) {
          context.newline();
          context.write("case ");
          context.visit(block2.test);
          context.write(":");
        } else {
          context.newline();
          context.write("default:");
        }
        context.indent();
        for (const statement of block2.consequent) {
          context.newline();
          context.visit(statement);
        }
        context.dedent();
      }
      context.dedent();
      context.newline();
      context.write("}");
    },
    TaggedTemplateExpression(node, context) {
      context.visit(node.tag);
      context.visit(node.quasi);
    },
    TemplateLiteral(node, context) {
      context.write("`");
      const { quasis, expressions } = node;
      for (let i = 0; i < expressions.length; i++) {
        const raw2 = quasis[i].value.raw;
        context.write(raw2 + "${");
        context.visit(expressions[i]);
        context.write("}");
        if (/\n/.test(raw2)) context.multiline = true;
      }
      const raw = quasis[quasis.length - 1].value.raw;
      context.write(raw + "`");
      if (/\n/.test(raw)) context.multiline = true;
    },
    ThisExpression(node, context) {
      context.write("this", node);
    },
    ThrowStatement(node, context) {
      context.write("throw ");
      if (node.argument) context.visit(node.argument);
      context.write(";");
    },
    TryStatement(node, context) {
      context.write("try ");
      context.visit(node.block);
      if (node.handler) {
        if (node.handler.param) {
          context.write(" catch(");
          context.visit(node.handler.param);
          context.write(") ");
        } else {
          context.write(" catch ");
        }
        context.visit(node.handler.body);
      }
      if (node.finalizer) {
        context.write(" finally ");
        context.visit(node.finalizer);
      }
    },
    UnaryExpression(node, context) {
      context.write(node.operator);
      if (node.operator.length > 1) {
        context.write(" ");
      }
      if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
        context.write("(");
        context.visit(node.argument);
        context.write(")");
      } else {
        context.visit(node.argument);
      }
    },
    UpdateExpression(node, context) {
      if (node.prefix) {
        context.write(node.operator);
        context.visit(node.argument);
      } else {
        context.visit(node.argument);
        context.write(node.operator);
      }
    },
    VariableDeclaration(node, context) {
      handle_var_declaration(node, context);
      context.write(";");
    },
    VariableDeclarator(node, context) {
      context.visit(node.id);
      if (node.init) {
        context.write(" = ");
        context.visit(node.init);
      }
    },
    WhileStatement(node, context) {
      context.write("while (");
      context.visit(node.test);
      context.write(") ");
      context.visit(node.body);
    },
    WithStatement(node, context) {
      context.write("with (");
      context.visit(node.object);
      context.write(") ");
      context.visit(node.body);
    },
    YieldExpression(node, context) {
      if (node.argument) {
        context.write(node.delegate ? `yield* ` : `yield `);
        context.visit(node.argument);
      } else {
        context.write(node.delegate ? `yield*` : `yield`);
      }
    },
    TSAbstractMethodDefinition: shared["MethodDefinition|TSAbstractMethodDefinition"],
    TSAbstractAccessorProperty: shared["PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty"],
    TSAbstractPropertyDefinition: shared["PropertyDefinition|TSAbstractPropertyDefinition|AccessorProperty|TSAbstractAccessorProperty"],
    TSDeclareFunction(node, context) {
      context.write("declare ");
      if (node.async) {
        context.write("async ");
      }
      context.write("function");
      if (node.generator) {
        context.write("*");
      }
      if (node.id) {
        context.write(" ");
        context.visit(node.id);
      }
      if (node.typeParameters) {
        context.visit(node.typeParameters);
      }
      context.write("(");
      sequence2(context, node.params, node.returnType?.loc?.start ?? node.loc?.end ?? null, false);
      context.write(")");
      if (node.returnType) {
        context.visit(node.returnType);
      }
      context.write(";");
    },
    TSNumberKeyword(node, context) {
      context.write("number", node);
    },
    TSStringKeyword(node, context) {
      context.write("string", node);
    },
    TSBooleanKeyword(node, context) {
      context.write("boolean", node);
    },
    TSAnyKeyword(node, context) {
      context.write("any", node);
    },
    TSVoidKeyword(node, context) {
      context.write("void", node);
    },
    TSUnknownKeyword(node, context) {
      context.write("unknown", node);
    },
    TSNeverKeyword(node, context) {
      context.write("never", node);
    },
    TSSymbolKeyword(node, context) {
      context.write("symbol", node);
    },
    TSNullKeyword(node, context) {
      context.write("null", node);
    },
    TSUndefinedKeyword(node, context) {
      context.write("undefined", node);
    },
    TSObjectKeyword(node, context) {
      context.write("object", node);
    },
    TSBigIntKeyword(node, context) {
      context.write("bigint", node);
    },
    TSIntrinsicKeyword(node, context) {
      context.write("intrinsic", node);
    },
    TSArrayType(node, context) {
      context.visit(node.elementType);
      context.write("[]");
    },
    TSTypeAnnotation(node, context) {
      context.write(": ");
      context.visit(node.typeAnnotation);
    },
    TSTypeLiteral(node, context) {
      context.write("{ ");
      sequence2(context, node.members, node.loc?.end ?? null, false, ";");
      context.write(" }");
    },
    TSPropertySignature(node, context) {
      context.visit(node.key);
      if (node.optional) context.write("?");
      if (node.typeAnnotation) context.visit(node.typeAnnotation);
    },
    TSTypeReference(node, context) {
      context.visit(node.typeName);
      if (node.typeArguments) {
        context.visit(node.typeArguments);
      }
    },
    TSTypeOperator(node, context) {
      context.write(node.operator + " ");
      if (node.typeAnnotation) {
        context.visit(node.typeAnnotation);
      }
    },
    TSTemplateLiteralType(node, context) {
      context.write("`");
      const { quasis, types: types2 } = node;
      for (let i = 0; i < types2.length; i++) {
        const raw = quasis[i].value.raw;
        context.write(raw + "${");
        context.visit(types2[i]);
        context.write("}");
        if (/\n/.test(raw)) context.multiline = true;
      }
      context.write("`");
    },
    TSParameterProperty(node, context) {
      if (node.accessibility) {
        context.write(node.accessibility + " ");
      }
      if (node.readonly) {
        context.write("readonly ");
      }
      context.visit(node.parameter);
    },
    TSExportAssignment(node, context) {
      context.write("export = ");
      context.visit(node.expression);
      context.write(";");
    },
    TSNamespaceExportDeclaration(node, context) {
      context.write("export as namespace ");
      context.visit(node.id);
      context.write(";");
    },
    //@ts-expect-error I don't know why, but this is relied upon in the tests, but doesn't exist in the TSESTree types
    TSExpressionWithTypeArguments(node, context) {
      context.visit(node.expression);
    },
    TSTypeAssertion(node, context) {
      context.write("<");
      context.visit(node.typeAnnotation);
      context.write(">");
      if (EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSTypeAssertion) {
        context.write("(");
        context.visit(node.expression);
        context.write(")");
      } else {
        context.visit(node.expression);
      }
    },
    TSTypeParameterInstantiation(node, context) {
      context.write("<");
      for (let i = 0; i < node.params.length; i++) {
        context.visit(node.params[i]);
        if (i != node.params.length - 1) context.write(", ");
      }
      context.write(">");
    },
    TSTypeParameterDeclaration(node, context) {
      context.write("<");
      for (let i = 0; i < node.params.length; i++) {
        context.visit(node.params[i]);
        if (i != node.params.length - 1) context.write(", ");
      }
      context.write(">");
    },
    TSTypeParameter(node, context) {
      if (node.name && node.name.type) context.visit(node.name);
      else context.write(node.name, node);
      if (node.constraint) {
        context.write(" extends ");
        context.visit(node.constraint);
      }
    },
    TSTypePredicate(node, context) {
      if (node.parameterName) {
        context.visit(node.parameterName);
      } else if (node.typeAnnotation) {
        context.visit(node.typeAnnotation);
      }
      if (node.asserts) {
        context.write(" asserts ");
      } else {
        context.write(" is ");
      }
      if (node.typeAnnotation) {
        context.visit(node.typeAnnotation.typeAnnotation);
      }
    },
    TSTypeQuery(node, context) {
      context.write("typeof ");
      context.visit(node.exprName);
    },
    TSClassImplements(node, context) {
      if (node.expression) {
        context.visit(node.expression);
      }
    },
    TSEnumMember(node, context) {
      context.visit(node.id);
      if (node.initializer) {
        context.write(" = ");
        context.visit(node.initializer);
      }
    },
    TSFunctionType: shared["TSFunctionType|TSConstructorType"],
    TSIndexSignature(node, context) {
      context.write("[");
      sequence2(context, node.parameters, node.typeAnnotation?.loc?.start ?? null, false);
      context.write("]");
      context.visit(node.typeAnnotation);
    },
    TSMappedType(node, context) {
      context.write("{[");
      if (node.typeParameter) {
        context.visit(node.typeParameter);
      } else {
        context.visit(node.key);
        context.write(" in ");
        context.visit(node.constraint);
      }
      context.write("]");
      if (node.typeAnnotation) {
        context.write(": ");
        context.visit(node.typeAnnotation);
      }
      context.write("}");
    },
    TSMethodSignature(node, context) {
      context.visit(node.key);
      context.write("(");
      sequence2(
        context,
        // @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
        node.parameters ?? node.params,
        // @ts-expect-error `acorn-typescript` and `@typescript-eslint/types` have slightly different type definitions
        (node.typeAnnotation ?? node.returnType)?.loc?.start ?? null,
        false
      );
      context.write(")");
      if (node.typeAnnotation || node.returnType) {
        context.visit(node.typeAnnotation ?? node.returnType);
      }
    },
    TSTupleType(node, context) {
      context.write("[");
      sequence2(context, node.elementTypes, node.loc?.end ?? null, false);
      context.write("]");
    },
    TSNamedTupleMember(node, context) {
      context.visit(node.label);
      context.write(": ");
      context.visit(node.elementType);
    },
    TSUnionType(node, context) {
      sequence2(context, node.types, node.loc?.end ?? null, false, " |");
    },
    TSIntersectionType(node, context) {
      sequence2(context, node.types, node.loc?.end ?? null, false, " &");
    },
    TSInferType(node, context) {
      context.write("infer ");
      context.visit(node.typeParameter);
    },
    TSLiteralType(node, context) {
      context.visit(node.literal);
    },
    TSCallSignatureDeclaration: shared["TSConstructSignatureDeclaration|TSCallSignatureDeclaration"],
    TSConditionalType(node, context) {
      context.visit(node.checkType);
      context.write(" extends ");
      context.visit(node.extendsType);
      context.write(" ? ");
      context.visit(node.trueType);
      context.write(" : ");
      context.visit(node.falseType);
    },
    TSConstructSignatureDeclaration: shared["TSConstructSignatureDeclaration|TSCallSignatureDeclaration"],
    TSConstructorType: shared["TSFunctionType|TSConstructorType"],
    TSExternalModuleReference(node, context) {
      context.write("require(");
      context.visit(node.expression);
      context.write(");");
    },
    TSIndexedAccessType(node, context) {
      context.visit(node.objectType);
      context.write("[");
      context.visit(node.indexType);
      context.write("]");
    },
    TSImportEqualsDeclaration(node, context) {
      context.write("import ");
      context.visit(node.id);
      context.write(" = ");
      context.visit(node.moduleReference);
    },
    TSImportType(node, context) {
      context.write("import(");
      context.visit(node.argument);
      context.write(")");
      if (node.qualifier) {
        context.write(".");
        context.visit(node.qualifier);
      }
    },
    TSOptionalType(node, context) {
      context.visit(node.typeAnnotation);
      context.write("?");
    },
    TSRestType(node, context) {
      context.write("...");
      context.visit(node.typeAnnotation);
    },
    TSThisType(node, context) {
      context.write("this", node);
    },
    TSAsExpression(node, context) {
      if (node.expression) {
        const needs_parens2 = EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSAsExpression;
        if (needs_parens2) {
          context.write("(");
          context.visit(node.expression);
          context.write(")");
        } else {
          context.visit(node.expression);
        }
      }
      context.write(" as ");
      context.visit(node.typeAnnotation);
    },
    TSEnumDeclaration(node, context) {
      context.write("enum ");
      context.visit(node.id);
      context.write(" {");
      context.indent();
      context.newline();
      sequence2(context, node.members ?? node.body.members, node.loc?.end ?? null, false);
      context.dedent();
      context.newline();
      context.write("}");
    },
    TSModuleBlock(node, context) {
      context.write(" {");
      context.indent();
      context.newline();
      body(context, node);
      context.dedent();
      context.newline();
      context.write("}");
    },
    TSModuleDeclaration(node, context) {
      if (node.declare) context.write("declare ");
      else context.write("namespace ");
      context.visit(node.id);
      if (!node.body) return;
      context.visit(node.body);
    },
    TSNonNullExpression(node, context) {
      context.visit(node.expression);
      context.write("!");
    },
    TSInterfaceBody(node, context) {
      sequence2(context, node.body, node.loc?.end ?? null, true, ";");
    },
    TSInterfaceDeclaration(node, context) {
      context.write("interface ");
      context.visit(node.id);
      if (node.typeParameters) context.visit(node.typeParameters);
      if (node.extends && node.extends.length > 0) {
        context.write(" extends ");
        sequence2(context, node.extends, node.body.loc?.start ?? null, false);
      }
      context.write(" {");
      context.visit(node.body);
      context.write("}");
    },
    TSInstantiationExpression(node, context) {
      context.visit(node.expression);
      context.visit(node.typeArguments);
    },
    TSInterfaceHeritage(node, context) {
      if (node.expression) {
        context.visit(node.expression);
      }
    },
    //@ts-expect-error I don't know why, but this is relied upon in the tests, but doesn't exist in the TSESTree types
    TSParenthesizedType(node, context) {
      context.write("(");
      context.visit(node.typeAnnotation);
      context.write(")");
    },
    TSSatisfiesExpression(node, context) {
      if (node.expression) {
        const needs_parens2 = EXPRESSIONS_PRECEDENCE[node.expression.type] < EXPRESSIONS_PRECEDENCE.TSSatisfiesExpression;
        if (needs_parens2) {
          context.write("(");
          context.visit(node.expression);
          context.write(")");
        } else {
          context.visit(node.expression);
        }
      }
      context.write(" satisfies ");
      context.visit(node.typeAnnotation);
    },
    TSTypeAliasDeclaration(node, context) {
      context.write("type ");
      context.visit(node.id);
      if (node.typeParameters) context.visit(node.typeParameters);
      context.write(" = ");
      context.visit(node.typeAnnotation);
      context.write(";");
    },
    TSQualifiedName(node, context) {
      context.visit(node.left);
      context.write(".");
      context.visit(node.right);
    }
  };
};
function needs_parens(node, parent, is_right) {
  if (node.type === "PrivateIdentifier") return false;
  if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) {
    return true;
  }
  const precedence = EXPRESSIONS_PRECEDENCE[node.type];
  const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
  if (precedence !== parent_precedence) {
    return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
  }
  if (precedence !== 13 && precedence !== 14) {
    return false;
  }
  if (
    /** @type {TSESTree.BinaryExpression} */
    node.operator === "**" && parent.operator === "**"
  ) {
    return !is_right;
  }
  if (is_right) {
    return OPERATOR_PRECEDENCE[
      /** @type {TSESTree.BinaryExpression} */
      node.operator
    ] <= OPERATOR_PRECEDENCE[parent.operator];
  }
  return OPERATOR_PRECEDENCE[
    /** @type {TSESTree.BinaryExpression} */
    node.operator
  ] < OPERATOR_PRECEDENCE[parent.operator];
}
function has_call_expression(node) {
  while (node) {
    if (node.type === "CallExpression") {
      return true;
    } else if (node.type === "MemberExpression") {
      node = node.object;
    } else {
      return false;
    }
  }
}
function handle_var_declaration(node, context) {
  const open2 = context.new();
  const join = context.new();
  const child_context = context.new();
  context.append(child_context);
  if (node.declare) {
    child_context.write("declare ");
  }
  child_context.write(`${node.kind} `);
  child_context.append(open2);
  let first = true;
  for (const d of node.declarations) {
    if (!first) child_context.append(join);
    first = false;
    child_context.visit(d);
  }
  const length = child_context.measure() + 2 * (node.declarations.length - 1);
  const multiline = child_context.multiline || node.declarations.length > 1 && length > 50;
  if (multiline) {
    context.multiline = true;
    if (node.declarations.length > 1) open2.indent();
    join.write(",");
    join.newline();
    if (node.declarations.length > 1) context.dedent();
  } else {
    join.write(", ");
  }
}
function quote(string2, char) {
  let out = char;
  for (const c of string2) {
    if (c === "\\") {
      out += "\\\\";
    } else if (c === char) {
      out += "\\" + c;
    } else if (c === "\n") {
      out += "\\n";
    } else if (c === "\r") {
      out += "\\r";
    } else {
      out += c;
    }
  }
  return out + char;
}
function before(a, b) {
  if (a.line < b.line) return true;
  if (a.line > b.line) return false;
  return a.column < b.column;
}

// node_modules/.deno/magic-string@0.30.21/node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = "";
    this.outro = "";
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) return true;
    }
  }
};
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str2) => globalThis.btoa(unescape(encodeURIComponent(str2)));
  } else if (typeof Buffer === "function") {
    return (str2) => Buffer.from(str2, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa3 = /* @__PURE__ */ getBtoa();
var SourceMap2 = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
    if (typeof properties.debugId !== "undefined") {
      this.debugId = properties.debugId;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa3(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--) fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString2 = Object.prototype.toString;
function isObject(thing) {
  return toString2.call(thing) === "[object Object]";
}
function getLocator2(source2) {
  const originalLines = source2.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf("\n", 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
        charInHiresBoundary = false;
      } else {
        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (this.hires === "boundary") {
            if (wordRegex.test(original[originalCharIndex])) {
              if (!charInHiresBoundary) {
                this.rawSegments.push(segment);
                charInHiresBoundary = true;
              }
            } else {
              this.rawSegments.push(segment);
              charInHiresBoundary = false;
            }
          } else {
            this.rawSegments.push(segment);
          }
        }
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str2) {
    if (!str2) return;
    const lines = str2.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string2, options = {}) {
    const chunk = new Chunk(0, string2.length, string2);
    Object.defineProperties(this, {
      original: { writable: true, value: string2 },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList },
      offset: { writable: true, value: options.offset || 0 }
    });
    this.byStart[0] = chunk;
    this.byEnd[string2.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename, offset: this.offset });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator2(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length) mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length) mappings.advance(chunk.outro);
    });
    if (this.outro) {
      mappings.advance(this.outro);
    }
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap2(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "") return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter) return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start, end, index) {
    start = start + this.offset;
    end = end + this.offset;
    index = index + this.offset;
    if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    const first = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) oldLeft.next = oldRight;
    if (oldRight) oldRight.previous = oldLeft;
    if (newLeft) newLeft.next = first;
    if (newRight) newRight.previous = last;
    if (!first.previous) this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) this.firstChunk = first;
    if (!newRight) this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options) {
    options = options || {};
    return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start, end, content, options) {
    start = start + this.offset;
    end = end + this.offset;
    if (typeof content !== "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (end > this.original.length) throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start > end) throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start, end) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start === end) return this;
    if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start > end) throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length) return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length) return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length - this.offset) {
    start = start + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start < 0) start += this.original.length;
      while (end < 0) end += this.original.length;
    }
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index]) return;
    let chunk = this.lastSearchedChunk;
    let previousChunk = chunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index)) return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
      if (chunk === previousChunk) return;
      previousChunk = chunk;
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator2(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str2 = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str2 += chunk.toString();
      chunk = chunk.next;
    }
    return str2 + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk) this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str2) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_2, i) => {
          if (i === "$") return "$";
          if (i === "&") return match[0];
          const num = +i;
          if (num < match.length) return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str2, match.groups);
      }
    }
    function matchAll(re, str2) {
      let match;
      const matches = [];
      while (match = re.exec(str2)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null) {
          const replacement2 = getReplacement(match, this.original);
          if (replacement2 !== match[0]) {
            this.overwrite(match.index, match.index + match[0].length, replacement2);
          }
        }
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null) {
        const replacement2 = getReplacement(match, this.original);
        if (replacement2 !== match[0]) {
          this.overwrite(match.index, match.index + match[0].length, replacement2);
        }
      }
    }
    return this;
  }
  _replaceString(string2, replacement) {
    const { original } = this;
    const index = original.indexOf(string2);
    if (index !== -1) {
      if (typeof replacement === "function") {
        replacement = replacement(string2, index, original);
      }
      if (string2 !== replacement) {
        this.overwrite(index, index + string2.length, replacement);
      }
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string2, replacement) {
    const { original } = this;
    const stringLength = string2.length;
    for (let index = original.indexOf(string2); index !== -1; index = original.indexOf(string2, index + stringLength)) {
      const previous = original.slice(index, index + stringLength);
      let _replacement = replacement;
      if (typeof replacement === "function") {
        _replacement = replacement(previous, index, original);
      }
      if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// node_modules/.deno/@jridgewell+trace-mapping@0.3.31/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
var import_resolve_uri = __toESM(require_resolve_uri_umd(), 1);
function stripFilename(path) {
  if (!path) return "";
  const index = path.lastIndexOf("/");
  return path.slice(0, index + 1);
}
function resolver(mapUrl, sourceRoot) {
  const from = stripFilename(mapUrl);
  const prefix = sourceRoot ? sourceRoot + "/" : "";
  return (source2) => (0, import_resolve_uri.default)(prefix + (source2 || ""), from);
}
var COLUMN = 0;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length) return mappings;
  if (!owned) mappings = mappings.slice();
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i = start; i < mappings.length; i++) {
    if (!isSorted(mappings[i])) return i;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN] < line[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned) line = line.slice();
  return line.sort(sortComparator2);
}
function sortComparator2(a, b) {
  return a[COLUMN] - b[COLUMN];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index) {
  for (let i = index + 1; i < haystack.length; index = i++) {
    if (haystack[i][COLUMN] !== needle) break;
  }
  return index;
}
function lowerBound(haystack, needle, index) {
  for (let i = index - 1; i >= 0; index = i--) {
    if (haystack[i][COLUMN] !== needle) break;
  }
  return index;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key2) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key2 === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key2;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
function parse6(map) {
  return typeof map === "string" ? JSON.parse(map) : map;
}
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
  constructor(map, mapUrl) {
    const isString = typeof map === "string";
    if (!isString && map._decodedMemo) return map;
    const parsed = parse6(map);
    const { version: version2, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version2;
    this.file = file;
    this.names = names || [];
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    const resolve = resolver(mapUrl, sourceRoot);
    this.resolvedSources = sources.map(resolve);
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else if (Array.isArray(mappings)) {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    } else if (parsed.sections) {
      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
    } else {
      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
function cast(map) {
  return map;
}
function decodedMappings(map) {
  var _a;
  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));
}
function traceSegment(map, line, column) {
  const decoded = decodedMappings(map);
  if (line >= decoded.length) return null;
  const segments = decoded[line];
  const index = traceSegmentInternal(
    segments,
    cast(map)._decodedMemo,
    line,
    column,
    GREATEST_LOWER_BOUND
  );
  return index === -1 ? null : segments[index];
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
  } else if (bias === LEAST_UPPER_BOUND) index++;
  if (index === -1 || index === segments.length) return -1;
  return index;
}

// node_modules/.deno/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var SetArray = class {
  constructor() {
    this._indexes = { __proto__: null };
    this.array = [];
  }
};
function cast2(set2) {
  return set2;
}
function get2(setarr, key2) {
  return cast2(setarr)._indexes[key2];
}
function put(setarr, key2) {
  const index = get2(setarr, key2);
  if (index !== void 0) return index;
  const { array: array2, _indexes: indexes } = cast2(setarr);
  const length = array2.push(key2);
  return indexes[key2] = length - 1;
}
function remove(setarr, key2) {
  const index = get2(setarr, key2);
  if (index === void 0) return;
  const { array: array2, _indexes: indexes } = cast2(setarr);
  for (let i = index + 1; i < array2.length; i++) {
    const k = array2[i];
    array2[i - 1] = k;
    indexes[k]--;
  }
  indexes[key2] = void 0;
  array2.pop();
}
var COLUMN2 = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
var NO_NAME = -1;
var GenMapping = class {
  constructor({ file, sourceRoot } = {}) {
    this._names = new SetArray();
    this._sources = new SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
    this._ignoreList = new SetArray();
  }
};
function cast22(map) {
  return map;
}
var maybeAddSegment = (map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content) => {
  return addSegmentInternal(
    true,
    map,
    genLine,
    genColumn,
    source2,
    sourceLine,
    sourceColumn,
    name,
    content
  );
};
function setSourceContent(map, source2, content) {
  const {
    _sources: sources,
    _sourcesContent: sourcesContent
    // _originalScopes: originalScopes,
  } = cast22(map);
  const index = put(sources, source2);
  sourcesContent[index] = content;
}
function setIgnore(map, source2, ignore = true) {
  const {
    _sources: sources,
    _sourcesContent: sourcesContent,
    _ignoreList: ignoreList
    // _originalScopes: originalScopes,
  } = cast22(map);
  const index = put(sources, source2);
  if (index === sourcesContent.length) sourcesContent[index] = null;
  if (ignore) put(ignoreList, index);
  else remove(ignoreList, index);
}
function toDecodedMap(map) {
  const {
    _mappings: mappings,
    _sources: sources,
    _sourcesContent: sourcesContent,
    _names: names,
    _ignoreList: ignoreList
    // _originalScopes: originalScopes,
    // _generatedRanges: generatedRanges,
  } = cast22(map);
  removeEmptyFinalLines(mappings);
  return {
    version: 3,
    file: map.file || void 0,
    names: names.array,
    sourceRoot: map.sourceRoot || void 0,
    sources: sources.array,
    sourcesContent,
    mappings,
    // originalScopes,
    // generatedRanges,
    ignoreList: ignoreList.array
  };
}
function toEncodedMap(map) {
  const decoded = toDecodedMap(map);
  return Object.assign({}, decoded, {
    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
    mappings: encode(decoded.mappings)
  });
}
function addSegmentInternal(skipable, map, genLine, genColumn, source2, sourceLine, sourceColumn, name, content) {
  const {
    _mappings: mappings,
    _sources: sources,
    _sourcesContent: sourcesContent,
    _names: names
    // _originalScopes: originalScopes,
  } = cast22(map);
  const line = getIndex(mappings, genLine);
  const index = getColumnIndex(line, genColumn);
  if (!source2) {
    if (skipable && skipSourceless(line, index)) return;
    return insert(line, index, [genColumn]);
  }
  assert2(sourceLine);
  assert2(sourceColumn);
  const sourcesIndex = put(sources, source2);
  const namesIndex = name ? put(names, name) : NO_NAME;
  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
    return;
  }
  return insert(
    line,
    index,
    name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]
  );
}
function assert2(_val) {
}
function getIndex(arr, index) {
  for (let i = arr.length; i <= index; i++) {
    arr[i] = [];
  }
  return arr[index];
}
function getColumnIndex(line, genColumn) {
  let index = line.length;
  for (let i = index - 1; i >= 0; index = i--) {
    const current2 = line[i];
    if (genColumn >= current2[COLUMN2]) break;
  }
  return index;
}
function insert(array2, index, value) {
  for (let i = array2.length; i > index; i--) {
    array2[i] = array2[i - 1];
  }
  array2[index] = value;
}
function removeEmptyFinalLines(mappings) {
  const { length } = mappings;
  let len = length;
  for (let i = len - 1; i >= 0; len = i, i--) {
    if (mappings[i].length > 0) break;
  }
  if (len < length) mappings.length = len;
}
function skipSourceless(line, index) {
  if (index === 0) return true;
  const prev = line[index - 1];
  return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
  if (index === 0) return false;
  const prev = line[index - 1];
  if (prev.length === 1) return false;
  return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
}

// node_modules/.deno/@jridgewell+remapping@2.3.5/node_modules/@jridgewell/remapping/dist/remapping.mjs
var SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null, false);
var EMPTY_SOURCES = [];
function SegmentObject(source2, line, column, name, content, ignore) {
  return { source: source2, line, column, name, content, ignore };
}
function Source(map, sources, source2, content, ignore) {
  return {
    map,
    sources,
    source: source2,
    content,
    ignore
  };
}
function MapSource(map, sources) {
  return Source(map, sources, "", null, false);
}
function OriginalSource(source2, content, ignore) {
  return Source(null, EMPTY_SOURCES, source2, content, ignore);
}
function traceMappings(tree) {
  const gen = new GenMapping({ file: tree.map.file });
  const { sources: rootSources, map } = tree;
  const rootNames = map.names;
  const rootMappings = decodedMappings(map);
  for (let i = 0; i < rootMappings.length; i++) {
    const segments = rootMappings[i];
    for (let j = 0; j < segments.length; j++) {
      const segment = segments[j];
      const genCol = segment[0];
      let traced = SOURCELESS_MAPPING;
      if (segment.length !== 1) {
        const source22 = rootSources[segment[1]];
        traced = originalPositionFor(
          source22,
          segment[2],
          segment[3],
          segment.length === 5 ? rootNames[segment[4]] : ""
        );
        if (traced == null) continue;
      }
      const { column, line, name, content, source: source2, ignore } = traced;
      maybeAddSegment(gen, i, genCol, source2, line, column, name);
      if (source2 && content != null) setSourceContent(gen, source2, content);
      if (ignore) setIgnore(gen, source2, true);
    }
  }
  return gen;
}
function originalPositionFor(source2, line, column, name) {
  if (!source2.map) {
    return SegmentObject(source2.source, line, column, name, source2.content, source2.ignore);
  }
  const segment = traceSegment(source2.map, line, column);
  if (segment == null) return null;
  if (segment.length === 1) return SOURCELESS_MAPPING;
  return originalPositionFor(
    source2.sources[segment[1]],
    segment[2],
    segment[3],
    segment.length === 5 ? source2.map.names[segment[4]] : name
  );
}
function asArray(value) {
  if (Array.isArray(value)) return value;
  return [value];
}
function buildSourceMapTree(input, loader) {
  const maps = asArray(input).map((m) => new TraceMap(m, ""));
  const map = maps.pop();
  for (let i = 0; i < maps.length; i++) {
    if (maps[i].sources.length > 1) {
      throw new Error(
        `Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`
      );
    }
  }
  let tree = build(map, loader, "", 0);
  for (let i = maps.length - 1; i >= 0; i--) {
    tree = MapSource(maps[i], [tree]);
  }
  return tree;
}
function build(map, loader, importer, importerDepth) {
  const { resolvedSources, sourcesContent, ignoreList } = map;
  const depth = importerDepth + 1;
  const children = resolvedSources.map((sourceFile, i) => {
    const ctx = {
      importer,
      depth,
      source: sourceFile || "",
      content: void 0,
      ignore: void 0
    };
    const sourceMap = loader(ctx.source, ctx);
    const { source: source2, content, ignore } = ctx;
    if (sourceMap) return build(new TraceMap(sourceMap, source2), loader, source2, depth);
    const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
    const ignored = ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i) : false;
    return OriginalSource(source2, sourceContent, ignored);
  });
  return MapSource(map, children);
}
var SourceMap3 = class {
  constructor(map, options) {
    const out = options.decodedMappings ? toDecodedMap(map) : toEncodedMap(map);
    this.version = out.version;
    this.file = out.file;
    this.mappings = out.mappings;
    this.names = out.names;
    this.ignoreList = out.ignoreList;
    this.sourceRoot = out.sourceRoot;
    this.sources = out.sources;
    if (!options.excludeContent) {
      this.sourcesContent = out.sourcesContent;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
};
function remapping(input, loader, options) {
  const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
  const tree = buildSourceMapTree(input, loader);
  return new SourceMap3(traceMappings(tree), opts);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/utils/mapped_code.js
var b64enc = typeof window !== "undefined" && typeof btoa === "function" ? (
  /** @param {string} str */
  (str2) => btoa(unescape(encodeURIComponent(str2)))
) : (
  /** @param {string} str */
  (str2) => Buffer.from(str2).toString("base64")
);
function combine_sourcemaps(filename2, sourcemap_list) {
  if (sourcemap_list.length == 0) return null;
  let map_idx = 1;
  const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? remapping(
    // use array interface
    // only the oldest sourcemap can have multiple sources
    sourcemap_list,
    () => null,
    true
    // skip optional field `sourcesContent`
  ) : remapping(
    // use loader interface
    sourcemap_list[0],
    // last map
    (sourcefile) => {
      if (sourcefile === filename2 && sourcemap_list[map_idx]) {
        return sourcemap_list[map_idx++];
      } else {
        return null;
      }
    },
    true
  );
  if (!map.file) delete map.file;
  if (!map.sources.length) map.sources = [filename2];
  return map;
}
function apply_preprocessor_sourcemap(filename2, svelte_map, preprocessor_map_input) {
  if (!svelte_map || !preprocessor_map_input) return svelte_map;
  const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
  const result_map = combine_sourcemaps(filename2, [svelte_map, preprocessor_map]);
  Object.defineProperties(result_map, {
    toString: {
      enumerable: false,
      value: function toString3() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + b64enc(this.toString());
      }
    }
  });
  return (
    /** @type {any} */
    result_map
  );
}
function merge_with_preprocessor_map(result, options, source_name) {
  if (options.sourcemap) {
    const file_basename = get_basename(options.filename);
    result.map.sources = [file_basename];
    Object.assign(
      result.map,
      apply_preprocessor_sourcemap(
        file_basename,
        result.map,
        /** @type {any} */
        options.sourcemap
      )
    );
    if (file_basename !== source_name) {
      result.map.sources = result.map.sources.map(
        /** @param {string} source */
        (source2) => get_relative_path(source_name, source2)
      );
    }
  }
}
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  if (from_parts.length) {
    let i = from_parts.length;
    while (i--) from_parts[i] = "..";
  }
  return from_parts.concat(to_parts).join("/");
}
function get_basename(filename2) {
  return (
    /** @type {string} */
    filename2.split(/[/\\]/).pop()
  );
}
function get_source_name(filename2, output_filename, fallback) {
  return output_filename ? get_relative_path(output_filename, filename2) : get_basename(filename2);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/css/index.js
function render_stylesheet(source2, analysis, options) {
  const code = new MagicString(source2);
  const state = {
    code,
    hash: analysis.css.hash,
    minify: analysis.inject_styles && !options.dev,
    selector: `.${analysis.css.hash}`,
    keyframes: analysis.css.keyframes,
    specificity: {
      bumped: false
    }
  };
  const ast = (
    /** @type {AST.CSS.StyleSheet} */
    analysis.css.ast
  );
  walk(
    /** @type {AST.CSS.Node} */
    ast,
    state,
    visitors4
  );
  code.remove(0, ast.content.start);
  code.remove(
    /** @type {number} */
    ast.content.end,
    source2.length
  );
  if (state.minify) {
    remove_preceding_whitespace(ast.content.end, state);
  }
  const css = {
    code: code.toString(),
    map: code.generateMap({
      // include source content; makes it easier/more robust looking up the source map code
      includeContent: true,
      // generateMap takes care of calculating source relative to file
      source: options.filename,
      file: options.cssOutputFilename || options.filename
    }),
    hasGlobal: analysis.css.has_global
  };
  merge_with_preprocessor_map(css, options, css.map.sources[0]);
  if (dev && options.css === "injected" && css.code) {
    css.code += `
/*# sourceMappingURL=${css.map.toUrl()} */`;
  }
  return css;
}
var visitors4 = {
  _: (node, context) => {
    context.state.code.addSourcemapLocation(node.start);
    context.state.code.addSourcemapLocation(node.end);
    context.next();
  },
  Atrule(node, { state, next: next2, path }) {
    if (is_keyframes_node(node)) {
      let start = node.start + node.name.length + 1;
      while (state.code.original[start] === " ") start += 1;
      let end = start;
      while (state.code.original[end] !== "{" && state.code.original[end] !== " ") end += 1;
      if (node.prelude.startsWith("-global-")) {
        state.code.remove(start, start + 8);
      } else if (!is_in_global_block2(path)) {
        state.code.prependRight(start, `${state.hash}-`);
      }
      return;
    }
    next2();
  },
  Declaration(node, { state }) {
    const property = node.property && remove_css_prefix(node.property.toLowerCase());
    if (property === "animation" || property === "animation-name") {
      let index = node.start + node.property.length + 1;
      let name = "";
      while (index < state.code.original.length) {
        const character = state.code.original[index];
        if (regex_css_name_boundary.test(character)) {
          if (state.keyframes.includes(name)) {
            state.code.prependRight(index - name.length, `${state.hash}-`);
          }
          if (character === ";" || character === "}") {
            break;
          }
          name = "";
        } else {
          name += character;
        }
        index++;
      }
    } else if (state.minify) {
      remove_preceding_whitespace(node.start, state);
      if (!node.property.startsWith("--")) {
        let start = node.start + node.property.length + 1;
        let end = start;
        while (/\s/.test(state.code.original[end])) end++;
        if (end > start) state.code.remove(start, end);
      }
    }
  },
  Rule(node, { state, next: next2, visit, path }) {
    if (state.minify) {
      remove_preceding_whitespace(node.start, state);
      remove_preceding_whitespace(node.block.end - 1, state);
    }
    if (!dev && is_empty(node, is_in_global_block2(path))) {
      if (state.minify) {
        state.code.remove(node.start, node.end);
      } else {
        state.code.prependRight(node.start, "/* (empty) ");
        state.code.appendLeft(node.end, "*/");
        escape_comment_close(node, state.code);
      }
      return;
    }
    if (!is_used(node) && !is_in_global_block2(path)) {
      if (state.minify) {
        state.code.remove(node.start, node.end);
      } else {
        state.code.prependRight(node.start, "/* (unused) ");
        state.code.appendLeft(node.end, "*/");
        escape_comment_close(node, state.code);
      }
      return;
    }
    if (node.metadata.is_global_block) {
      const selector = node.prelude.children[0];
      if (node.prelude.children.length === 1 && selector.children.length === 1 && selector.children[0].selectors.length === 1) {
        if (state.minify) {
          state.code.remove(node.start, node.block.start + 1);
          state.code.remove(node.block.end - 1, node.end);
        } else {
          state.code.prependRight(node.start, "/* ");
          state.code.appendLeft(node.block.start + 1, "*/");
          state.code.prependRight(node.block.end - 1, "/*");
          state.code.appendLeft(node.block.end, "*/");
        }
        visit(node.block);
        return;
      }
    }
    next2();
  },
  SelectorList(node, { state, next: next2, path }) {
    const parent = path.at(-1);
    if ((!is_in_global_block2(path) || node.children.length > 1 && parent?.type === "Rule" && parent.metadata.is_global_block) && !path.find((n2) => n2.type === "ComplexSelector" && !n2.metadata.used)) {
      const children = node.children;
      let pruning = false;
      let prune_start = children[0].start;
      let last = prune_start;
      let has_previous_used = false;
      for (let i = 0; i < children.length; i += 1) {
        const selector = children[i];
        if (selector.metadata.used === pruning) {
          if (pruning) {
            let i2 = selector.start;
            while (state.code.original[i2] !== ",") i2--;
            if (state.minify) {
              state.code.remove(prune_start, has_previous_used ? i2 : i2 + 1);
            } else {
              state.code.appendRight(has_previous_used ? i2 : i2 + 1, "*/");
            }
          } else {
            if (i === 0) {
              if (state.minify) {
                prune_start = selector.start;
              } else {
                state.code.prependRight(selector.start, "/* (unused) ");
              }
            } else {
              if (state.minify) {
                prune_start = last;
              } else {
                state.code.overwrite(last, selector.start, ` /* (unused) `);
              }
            }
          }
          pruning = !pruning;
        }
        if (!pruning && selector.metadata.used) {
          has_previous_used = true;
        }
        last = selector.end;
      }
      if (pruning) {
        if (state.minify) {
          state.code.remove(prune_start, last);
        } else {
          state.code.appendLeft(last, "*/");
        }
      }
    }
    let specificity = state.specificity;
    if (parent?.type === "Rule") {
      specificity = { bumped: false };
      let rule = parent.metadata.parent_rule;
      while (rule) {
        if (rule.metadata.has_local_selectors) {
          specificity = { bumped: true };
          break;
        }
        rule = rule.metadata.parent_rule;
      }
    }
    next2({ ...state, specificity });
  },
  ComplexSelector(node, context) {
    const before_bumped = context.state.specificity.bumped;
    for (const relative_selector of node.children) {
      if (relative_selector.metadata.is_global) {
        const global = (
          /** @type {AST.CSS.PseudoClassSelector} */
          relative_selector.selectors[0]
        );
        remove_global_pseudo_class(global, relative_selector.combinator, context.state);
        const parent_rule = node.metadata.rule?.metadata.parent_rule;
        if (parent_rule && global.args === null) {
          if (relative_selector.combinator === null) {
            context.state.code.prependRight(global.start, "&");
          }
          if (parent_rule.prelude.children.length > 1 && node.children.length === node.children.findIndex((s) => s === relative_selector) - 1) {
            const next_selector = parent_rule.prelude.children.find((s) => s.start > global.end);
            if (next_selector && next_selector.metadata.used) {
              context.state.code.update(global.end, next_selector.start, "");
            }
          }
        }
        continue;
      } else {
        for (const selector of relative_selector.selectors) {
          if (selector.type === "PseudoClassSelector" && selector.name === "global") {
            remove_global_pseudo_class(selector, null, context.state);
          }
        }
      }
      if (relative_selector.metadata.scoped) {
        if (relative_selector.selectors.length === 1) {
          const selector = relative_selector.selectors[0];
          if (selector.type === "PseudoClassSelector" && (selector.name === "is" || selector.name === "where")) {
            continue;
          }
        }
        if (relative_selector.selectors.some((s) => s.type === "NestingSelector")) {
          continue;
        }
        let modifier = context.state.selector;
        if (context.state.specificity.bumped) modifier = `:where(${modifier})`;
        context.state.specificity.bumped = true;
        let i = relative_selector.selectors.length;
        while (i--) {
          const selector = relative_selector.selectors[i];
          if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
            if (selector.name !== "root" && selector.name !== "host") {
              if (i === 0) context.state.code.prependRight(selector.start, modifier);
            }
            continue;
          }
          if (selector.type === "TypeSelector" && selector.name === "*") {
            context.state.code.update(selector.start, selector.end, modifier);
          } else {
            context.state.code.appendLeft(selector.end, modifier);
          }
          break;
        }
      }
    }
    context.next();
    context.state.specificity.bumped = before_bumped;
  },
  PseudoClassSelector(node, context) {
    if (node.name === "is" || node.name === "where" || node.name === "has" || node.name === "not") {
      context.next();
    }
  }
};
function is_in_global_block2(path) {
  return path.some((node) => node.type === "Rule" && node.metadata.is_global_block);
}
function remove_global_pseudo_class(selector, combinator, state) {
  if (selector.args === null) {
    let start = selector.start;
    if (combinator?.name === " ") {
      while (/\s/.test(state.code.original[start - 1])) start--;
    }
    state.code.update(start, selector.start + ":global".length, "");
  } else {
    state.code.remove(selector.start, selector.start + ":global(".length).remove(selector.end - 1, selector.end);
  }
}
function remove_preceding_whitespace(end, state) {
  let start = end;
  while (/\s/.test(state.code.original[start - 1])) start--;
  if (start < end) state.code.remove(start, end);
}
function is_empty(rule, is_in_global_block3) {
  if (rule.metadata.is_global_block) {
    return rule.block.children.length === 0;
  }
  for (const child of rule.block.children) {
    if (child.type === "Declaration") {
      return false;
    }
    if (child.type === "Rule") {
      if ((is_used(child) || is_in_global_block3) && !is_empty(child, is_in_global_block3)) {
        return false;
      }
    }
    if (child.type === "Atrule") {
      if (child.block === null || child.block.children.length > 0) return false;
    }
  }
  return true;
}
function is_used(rule) {
  return rule.prelude.children.some((selector) => selector.metadata.used);
}
function escape_comment_close(node, code) {
  let escaped = false;
  let in_comment = false;
  for (let i = node.start; i < node.end; i++) {
    if (escaped) {
      escaped = false;
    } else {
      const char = code.original[i];
      if (in_comment) {
        if (char === "*" && code.original[i + 1] === "/") {
          code.prependRight(++i, "\\");
          in_comment = false;
        }
      } else if (char === "\\") {
        escaped = true;
      } else if (char === "/" && code.original[++i] === "*") {
        in_comment = true;
      }
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/declarations.js
function get_value(node) {
  return call("$.get", node);
}
function add_state_transformers(context) {
  for (const [name, binding] of context.state.scope.declarations) {
    if (is_state_source(binding, context.state.analysis) || binding.kind === "derived" || binding.kind === "legacy_reactive") {
      context.state.transform[name] = {
        read: binding.declaration_kind === "var" ? (node) => call("$.safe_get", node) : get_value,
        assign: (node, value, proxy = false) => {
          let call2 = call("$.set", node, value, proxy && true_instance);
          if (context.state.scope.get(`$${node.name}`)?.kind === "store_sub") {
            call2 = call("$.store_unsub", call2, literal2(`$${node.name}`), id("$$stores"));
          }
          return call2;
        },
        mutate: (node, mutation) => {
          if (context.state.analysis.runes) {
            return mutation;
          }
          return call("$.mutate", node, mutation);
        },
        update: (node) => {
          return call(
            node.prefix ? "$.update_pre" : "$.update",
            node.argument,
            node.operator === "--" && literal2(-1)
          );
        }
      };
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/shared/assignments.js
function visit_assignment_expression(node, context, build_assignment3) {
  if (node.left.type === "ArrayPattern" || node.left.type === "ObjectPattern" || node.left.type === "RestElement") {
    const value = (
      /** @type {Expression} */
      context.visit(node.right)
    );
    const should_cache = value.type !== "Identifier";
    const rhs = should_cache ? id("$$value") : value;
    let changed = false;
    const { inserts, paths } = extract_paths(node.left, rhs);
    for (const { id: id2 } of inserts) {
      id2.name = context.state.scope.generate("$$array");
    }
    const assignments = paths.map((path) => {
      const value2 = path.expression;
      let assignment2 = build_assignment3("=", path.node, value2, context);
      if (assignment2 !== null) changed = true;
      return assignment2 ?? assignment(
        "=",
        /** @type {Pattern} */
        context.visit(path.node),
        /** @type {Expression} */
        context.visit(value2)
      );
    });
    if (!changed) {
      return null;
    }
    const is_standalone = (
      /** @type {Node} */
      context.path.at(-1).type.endsWith("Statement")
    );
    if (inserts.length > 0 || should_cache) {
      const statements = [
        ...inserts.map(({ id: id2, value: value2 }) => var_builder(id2, value2)),
        ...assignments.map(stmt)
      ];
      if (!is_standalone) {
        statements.push(return_builder(rhs));
      }
      const async = is_expression_async(value) || assignments.some((assignment2) => is_expression_async(assignment2));
      const iife = arrow([rhs], block(statements), async);
      const call2 = call(iife, value);
      return async ? await_builder(call2) : call2;
    }
    const sequence2 = sequence(assignments);
    if (!is_standalone) {
      sequence2.expressions.push(rhs);
    }
    return sequence2;
  }
  if (node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
    throw new Error(`Unexpected assignment type ${node.left.type}`);
  }
  return build_assignment3(node.operator, node.left, node.right, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AssignmentExpression.js
function AssignmentExpression2(node, context) {
  return visit_assignment_expression(node, context, build_assignment) ?? context.next();
}
function build_assignment(operator, left, right, context) {
  if (context.state.analysis.runes && left.type === "MemberExpression" && left.object.type === "ThisExpression" && !left.computed) {
    const name2 = get_name(left.property);
    const field = name2 && context.state.state_fields.get(name2);
    if (field && field.node.type === "AssignmentExpression" && left === field.node.left) {
      const rune = get_rune(right, context.state.scope);
      if (rune) {
        const key2 = left.property.type === "PrivateIdentifier" || rune === "$state" || rune === "$state.raw" ? left.property : field.key;
        return assignment(
          operator,
          member(this_instance, key2, key2.type === "Literal"),
          /** @type {Expression} */
          context.visit(right)
        );
      }
    } else if (field && (field.type === "$derived" || field.type === "$derived.by") && left.property.type === "PrivateIdentifier") {
      let value = (
        /** @type {Expression} */
        context.visit(build_assignment_value(operator, left, right))
      );
      return call(member(this_instance, name2), value);
    }
  }
  let object4 = left;
  while (object4.type === "MemberExpression") {
    object4 = object4.object;
  }
  if (object4.type !== "Identifier" || !is_store_name(object4.name)) {
    return null;
  }
  const name = object4.name.slice(1);
  if (!context.state.scope.get(name)) {
    return null;
  }
  if (object4 === left) {
    let value = (
      /** @type {Expression} */
      context.visit(build_assignment_value(operator, left, right))
    );
    return call("$.store_set", id(name), value);
  }
  return call(
    "$.store_mutate",
    assignment("??=", id("$$store_subs"), object([])),
    literal2(object4.name),
    id(name),
    assignment(
      operator,
      /** @type {Pattern} */
      context.visit(left),
      /** @type {Expression} */
      context.visit(right)
    )
  );
}
function is_store_name(name) {
  return name[0] === "$" && /[A-Za-z_]/.test(name[1]);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/escaping.js
var ATTR_REGEX = /[&"<]/g;
var CONTENT_REGEX = /[&<]/g;
function escape_html(value, is_attr) {
  const str2 = String(value ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped = "";
  let last = 0;
  while (pattern.test(str2)) {
    const i = pattern.lastIndex - 1;
    const ch = str2[i];
    escaped += str2.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped + str2.substring(last);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/internal/server/hydration.js
var BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
var BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
var BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
var EMPTY_COMMENT = `<!---->`;

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/utils.js
var block_open = literal2(BLOCK_OPEN);
var block_open_else = literal2(BLOCK_OPEN_ELSE);
var block_close = literal2(BLOCK_CLOSE);
var empty_comment = literal2(EMPTY_COMMENT);
function process_children(nodes, { visit, state }) {
  let sequence2 = [];
  function flush() {
    if (sequence2.length === 0) {
      return;
    }
    let quasi2 = quasi("", false);
    const quasis = [quasi2];
    const expressions = [];
    for (let i = 0; i < sequence2.length; i++) {
      const node = sequence2[i];
      if (node.type === "Text" || node.type === "Comment") {
        quasi2.value.cooked += node.type === "Comment" ? `<!--${node.data}-->` : escape_html(node.data);
      } else {
        const evaluated = state.scope.evaluate(node.expression);
        if (evaluated.is_known) {
          quasi2.value.cooked += escape_html((evaluated.value ?? "") + "");
        } else {
          expressions.push(call(
            "$.escape",
            /** @type {Expression} */
            visit(node.expression)
          ));
          quasi2 = quasi("", i + 1 === sequence2.length);
          quasis.push(quasi2);
        }
      }
    }
    for (const quasi3 of quasis) {
      quasi3.value.raw = sanitize_template_string(
        /** @type {string} */
        quasi3.value.cooked
      );
    }
    state.template.push(template(quasis, expressions));
    sequence2 = [];
  }
  for (const node of nodes) {
    if (node.type === "ExpressionTag" && node.metadata.expression.is_async()) {
      flush();
      const expression = (
        /** @type {Expression} */
        visit(node.expression)
      );
      state.template.push(create_push(call("$.escape", expression), node.metadata.expression));
    } else if (node.type === "Text" || node.type === "Comment" || node.type === "ExpressionTag") {
      sequence2.push(node);
    } else {
      flush();
      visit(node, { ...state });
    }
  }
  flush();
}
function is_statement(node) {
  return node.type.endsWith("Statement") || node.type.endsWith("Declaration");
}
function build_template(template2) {
  let strings = [];
  let expressions = [];
  const statements = [];
  const flush = () => {
    statements.push(
      stmt(
        call(
          id("$$renderer.push"),
          template(
            strings.map((cooked, i) => quasi(cooked, i === strings.length - 1)),
            expressions
          )
        )
      )
    );
    strings = [];
    expressions = [];
  };
  for (let i = 0; i < template2.length; i++) {
    const node = template2[i];
    if (is_statement(node)) {
      if (strings.length !== 0) {
        flush();
      }
      statements.push(node);
    } else {
      if (strings.length === 0) {
        strings.push("");
      }
      if (node.type === "Literal") {
        strings[strings.length - 1] += node.value;
      } else if (node.type === "TemplateLiteral") {
        strings[strings.length - 1] += node.quasis[0].value.cooked;
        strings.push(...node.quasis.slice(1).map((q) => (
          /** @type {string} */
          q.value.cooked
        )));
        expressions.push(...node.expressions);
      } else {
        expressions.push(node);
        strings.push("");
      }
    }
  }
  if (strings.length !== 0) {
    flush();
  }
  return statements;
}
function build_attribute_value(value, context, transform, trim_whitespace = false, is_component = false) {
  if (value === true) {
    return true_instance;
  }
  if (!Array.isArray(value) || value.length === 1) {
    const chunk = Array.isArray(value) ? value[0] : value;
    if (chunk.type === "Text") {
      const data2 = trim_whitespace ? chunk.data.replace(regex_whitespaces_strict, " ").trim() : chunk.data;
      return literal2(is_component ? data2 : escape_html(data2, true));
    }
    return transform(
      /** @type {Expression} */
      context.visit(chunk.expression),
      chunk.metadata.expression
    );
  }
  let quasi2 = quasi("", false);
  const quasis = [quasi2];
  const expressions = [];
  for (let i = 0; i < value.length; i++) {
    const node = value[i];
    if (node.type === "Text") {
      quasi2.value.raw += trim_whitespace ? node.data.replace(regex_whitespaces_strict, " ") : node.data;
    } else {
      expressions.push(
        call(
          "$.stringify",
          transform(
            /** @type {Expression} */
            context.visit(node.expression),
            node.metadata.expression
          )
        )
      );
      quasi2 = quasi("", i + 1 === value.length);
      quasis.push(quasi2);
    }
  }
  return template(quasis, expressions);
}
function build_getter2(node, state) {
  const binding = state.scope.get(node.name);
  if (binding === null || node === binding.node) {
    return node;
  }
  if (binding.kind === "store_sub") {
    const store_id = id(node.name.slice(1));
    return call(
      "$.store_get",
      assignment("??=", id("$$store_subs"), object([])),
      literal2(node.name),
      build_getter2(store_id, state)
    );
  }
  return node;
}
function create_child_block(body, async) {
  return stmt(call("$$renderer.child", arrow([id("$$renderer")], body, async)));
}
function create_async_block(body, blockers = array([]), has_await = true, needs_hydration_markers = true) {
  return stmt(
    call(
      needs_hydration_markers ? "$$renderer.async_block" : "$$renderer.async",
      blockers,
      arrow([id("$$renderer")], body, has_await)
    )
  );
}
function create_push(expression, metadata, needs_hydration_markers = false) {
  if (metadata.is_async()) {
    let statement = stmt(call("$$renderer.push", thunk(expression, metadata.has_await)));
    const blockers = metadata.blockers();
    if (blockers.elements.length > 0) {
      statement = create_async_block(
        block([statement]),
        blockers,
        false,
        needs_hydration_markers
      );
    }
    return statement;
  }
  return expression;
}
function call_component_renderer(body, component_fn_id) {
  return stmt(
    call("$$renderer.component", arrow([id("$$renderer")], body, false), component_fn_id)
  );
}
var PromiseOptimiser = class {
  /** @type {Expression[]} */
  expressions = [];
  has_await = false;
  /** @type {Set<Expression>} */
  #blockers = /* @__PURE__ */ new Set();
  /**
   * @param {Expression} expression
   * @param {ExpressionMetadata} metadata
   */
  transform = (expression, metadata) => {
    this.check_blockers(metadata);
    if (metadata.has_await) {
      this.has_await = true;
      const length = this.expressions.push(expression);
      return id(`$$${length - 1}`);
    }
    return expression;
  };
  /**
   * @param {ExpressionMetadata} metadata
   */
  check_blockers(metadata) {
    for (const binding of metadata.dependencies) {
      if (binding.blocker) {
        this.#blockers.add(binding.blocker);
      }
    }
  }
  apply() {
    if (this.expressions.length === 0) {
      return empty2;
    }
    if (this.expressions.length === 1) {
      return const_builder("$$0", this.expressions[0]);
    }
    const promises = array(
      this.expressions.map((expression) => {
        return expression.type === "AwaitExpression" && !has_await_expression(expression.argument) ? expression.argument : call(thunk(expression, true));
      })
    );
    return const_builder(
      array_pattern(this.expressions.map((_2, i) => id(`$$${i}`))),
      await_builder(call("Promise.all", promises))
    );
  }
  blockers() {
    return array([...this.#blockers]);
  }
  is_async() {
    return this.expressions.length > 0 || this.#blockers.size > 0;
  }
};

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AwaitBlock.js
function AwaitBlock2(node, context) {
  let statement = stmt(
    call(
      "$.await",
      id("$$renderer"),
      /** @type {Expression} */
      context.visit(node.expression),
      thunk(
        node.pending ? (
          /** @type {BlockStatement} */
          context.visit(node.pending)
        ) : block([])
      ),
      arrow(
        node.value ? [
          /** @type {Pattern} */
          context.visit(node.value)
        ] : [],
        node.then ? (
          /** @type {BlockStatement} */
          context.visit(node.then)
        ) : block([])
      )
    )
  );
  if (node.metadata.expression.is_async()) {
    statement = create_async_block(
      block([statement]),
      node.metadata.expression.blockers(),
      node.metadata.expression.has_await
    );
  }
  context.state.template.push(statement, block_close);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AwaitExpression.js
function AwaitExpression2(node, context) {
  const argument = (
    /** @type {Expression} */
    context.visit(node.argument)
  );
  if (context.state.analysis.pickled_awaits.has(node)) {
    return save(argument);
  }
  let i = context.path.length;
  while (i--) {
    const parent = context.path[i];
    if (parent.type === "ArrowFunctionExpression" || parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
      break;
    }
    if (parent.metadata) {
      if (parent.type !== "ExpressionTag" && parent.type !== "Fragment") {
        return save(argument);
      }
      break;
    }
  }
  return argument === node.argument ? node : { ...node, argument };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/utils.js
function sort_const_tags(nodes, state) {
  const other = [];
  const tags = /* @__PURE__ */ new Map();
  for (const node of nodes) {
    if (node.type === "ConstTag") {
      const declaration2 = node.declaration.declarations[0];
      const bindings = extract_identifiers(declaration2.id).map((id2) => {
        return (
          /** @type {Binding} */
          state.scope.get(id2.name)
        );
      });
      const deps = /* @__PURE__ */ new Set();
      walk(declaration2.init, state, {
        // @ts-expect-error don't know, don't care
        _: set_scope,
        Identifier(node2, context) {
          const parent = (
            /** @type {Expression} */
            context.path.at(-1)
          );
          if (is_reference(node2, parent)) {
            const binding = context.state.scope.get(node2.name);
            if (binding) deps.add(binding);
          }
        }
      });
      for (const binding of bindings) {
        tags.set(binding, { node, deps });
      }
    } else {
      other.push(node);
    }
  }
  if (tags.size === 0) {
    return nodes;
  }
  const edges = [];
  for (const [id2, tag2] of tags) {
    for (const dep of tag2.deps) {
      if (tags.has(dep)) {
        edges.push([id2, dep]);
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle?.length) {
    const tag2 = (
      /** @type {Tag} */
      tags.get(cycle[0])
    );
    const_tag_cycle(tag2.node, cycle.map((binding) => binding.node.name).join(" \u2192 "));
  }
  const sorted = [];
  function add(tag2) {
    if (sorted.includes(tag2.node)) {
      return;
    }
    for (const dep of tag2.deps) {
      const dep_tag = tags.get(dep);
      if (dep_tag) add(dep_tag);
    }
    sorted.push(tag2.node);
  }
  for (const tag2 of tags.values()) {
    add(tag2);
  }
  return [...sorted, ...other];
}
function clean_nodes(parent, nodes, path, namespace = "html", state, preserve_whitespace, preserve_comments) {
  if (!state.analysis.runes) {
    nodes = sort_const_tags(nodes, state);
  }
  const hoisted = [];
  const regular = [];
  for (const node of nodes) {
    if (node.type === "Comment" && !preserve_comments) {
      continue;
    }
    if (node.type === "ConstTag" || node.type === "DebugTag" || node.type === "SvelteBody" || node.type === "SvelteWindow" || node.type === "SvelteDocument" || node.type === "SvelteHead" || node.type === "TitleElement" || node.type === "SnippetBlock") {
      hoisted.push(node);
    } else {
      regular.push(node);
    }
  }
  let trimmed = regular;
  if (!preserve_whitespace) {
    trimmed = [];
    let first2, last;
    while ((first2 = regular[0]) && first2.type === "Text" && !regex_not_whitespace.test(first2.data)) {
      regular.shift();
    }
    if (first2?.type === "Text") {
      first2.raw = first2.raw.replace(regex_starts_with_whitespaces, "");
      first2.data = first2.data.replace(regex_starts_with_whitespaces, "");
    }
    while ((last = regular.at(-1)) && last.type === "Text" && !regex_not_whitespace.test(last.data)) {
      regular.pop();
    }
    if (last?.type === "Text") {
      last.raw = last.raw.replace(regex_ends_with_whitespaces, "");
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
    const can_remove_entirely = namespace === "svg" && (parent.type !== "RegularElement" || parent.name !== "text") && !path.some((n2) => n2.type === "RegularElement" && n2.name === "text") || parent.type === "RegularElement" && // TODO others?
    (parent.name === "select" || parent.name === "tr" || parent.name === "table" || parent.name === "tbody" || parent.name === "thead" || parent.name === "tfoot" || parent.name === "colgroup" || parent.name === "datalist");
    for (let i = 0; i < regular.length; i++) {
      const prev = regular[i - 1];
      const node = regular[i];
      const next2 = regular[i + 1];
      if (node.type === "Text") {
        if (prev?.type !== "ExpressionTag") {
          const prev_is_text_ending_with_whitespace = prev?.type === "Text" && regex_ends_with_whitespaces.test(prev.data);
          node.data = node.data.replace(
            regex_starts_with_whitespaces,
            prev_is_text_ending_with_whitespace ? "" : " "
          );
          node.raw = node.raw.replace(
            regex_starts_with_whitespaces,
            prev_is_text_ending_with_whitespace ? "" : " "
          );
        }
        if (next2?.type !== "ExpressionTag") {
          node.data = node.data.replace(regex_ends_with_whitespaces, " ");
          node.raw = node.raw.replace(regex_ends_with_whitespaces, " ");
        }
        if (node.data && (node.data !== " " || !can_remove_entirely)) {
          trimmed.push(node);
        }
      } else {
        trimmed.push(node);
      }
    }
  }
  var first = trimmed[0];
  if (parent.type === "RegularElement" && parent.name === "pre" && first?.type === "Text") {
    if (first.data === "\n" || first.data === "\r\n") {
      trimmed.shift();
      first = trimmed[0];
    }
  }
  if (trimmed.length === 1 && first.type === "RegularElement" && first.name === "script") {
    trimmed.push({
      type: "Comment",
      data: "",
      start: -1,
      end: -1
    });
  }
  return {
    hoisted,
    trimmed,
    /**
     * In a case like `{#if x}<Foo />{/if}`, we don't need to wrap the child in
     * comments  we can just use the parent block's anchor for the component.
     * TODO extend this optimisation to other cases
     */
    is_standalone: trimmed.length === 1 && (first.type === "RenderTag" && !first.metadata.dynamic || first.type === "Component" && !state.options.hmr && !first.metadata.dynamic && !first.attributes.some(
      (attribute) => attribute.type === "Attribute" && attribute.name.startsWith("--")
    )),
    /** if a component/snippet/each block starts with text, we need to add an anchor comment so that its text node doesn't get fused with its surroundings */
    is_text_first: (parent.type === "Fragment" || parent.type === "SnippetBlock" || parent.type === "EachBlock" || parent.type === "SvelteComponent" || parent.type === "SvelteBoundary" || parent.type === "Component" || parent.type === "SvelteSelf") && first && (first?.type === "Text" || first?.type === "ExpressionTag")
  };
}
function infer_namespace(namespace, parent, nodes) {
  if (parent.type === "RegularElement" && parent.name === "foreignObject") {
    return "html";
  }
  if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
    if (parent.metadata.svg) {
      return "svg";
    }
    return parent.metadata.mathml ? "mathml" : "html";
  }
  if (parent.type === "Fragment" || parent.type === "Root" || parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteFragment" || parent.type === "SnippetBlock" || parent.type === "SlotElement") {
    const new_namespace2 = check_nodes_for_namespace(nodes, "keep");
    if (new_namespace2 !== "keep" && new_namespace2 !== "maybe_html") {
      return new_namespace2;
    }
  }
  let new_namespace = null;
  for (const node of nodes) {
    if (node.type !== "RegularElement") continue;
    if (node.metadata.mathml) {
      new_namespace = new_namespace === null || new_namespace === "mathml" ? "mathml" : "html";
    } else if (node.metadata.svg) {
      new_namespace = new_namespace === null || new_namespace === "svg" ? "svg" : "html";
    } else {
      return "html";
    }
  }
  return new_namespace ?? namespace;
}
function check_nodes_for_namespace(nodes, namespace) {
  const RegularElement4 = (node, { stop }) => {
    if (!node.metadata.svg && !node.metadata.mathml) {
      namespace = "html";
      stop();
    } else if (namespace === "keep") {
      namespace = node.metadata.svg ? "svg" : "mathml";
    }
  };
  for (const node of nodes) {
    walk(
      node,
      {},
      {
        _(node2, { next: next2 }) {
          if (node2.type === "EachBlock" || node2.type === "IfBlock" || node2.type === "AwaitBlock" || node2.type === "Fragment" || node2.type === "KeyBlock" || node2.type === "RegularElement" || node2.type === "SvelteElement" || node2.type === "Text") {
            next2();
          }
        },
        SvelteElement: RegularElement4,
        RegularElement: RegularElement4,
        Text(node2) {
          if (node2.data.trim() !== "") {
            namespace = "maybe_html";
          }
        }
      }
    );
    if (namespace === "html") return namespace;
  }
  return namespace;
}
function determine_namespace_for_children(node, namespace) {
  if (node.name === "foreignObject") {
    return "html";
  }
  if (node.metadata.svg) {
    return "svg";
  }
  return node.metadata.mathml ? "mathml" : "html";
}
function get_inspect_args(rune, node, visit) {
  const call2 = rune === "$inspect" ? node : (
    /** @type {CallExpression} */
    /** @type {MemberExpression} */
    node.callee.object
  );
  return {
    args: call2.arguments.map((arg) => (
      /** @type {Expression} */
      visit(arg)
    )),
    inspector: rune === "$inspect" ? "console.log" : (
      /** @type {Expression} */
      visit(node.arguments[0])
    )
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/CallExpression.js
function CallExpression2(node, context) {
  const rune = get_rune(node, context.state.scope);
  if (rune === "$host" || rune === "$effect" || rune === "$effect.pre" || rune === "$inspect.trace") {
    return void0;
  }
  if (rune === "$effect.tracking") {
    return false_instance;
  }
  if (rune === "$effect.root") {
    return arrow([], block([]));
  }
  if (rune === "$effect.pending") {
    return literal2(0);
  }
  if (rune === "$state" || rune === "$state.raw") {
    return node.arguments[0] ? context.visit(node.arguments[0]) : void0;
  }
  if (rune === "$derived" || rune === "$derived.by") {
    const fn = (
      /** @type {Expression} */
      context.visit(node.arguments[0])
    );
    return call("$.derived", rune === "$derived" ? thunk(fn) : fn);
  }
  if (rune === "$state.eager") {
    return node.arguments[0];
  }
  if (rune === "$state.snapshot") {
    return call(
      "$.snapshot",
      /** @type {Expression} */
      context.visit(node.arguments[0]),
      is_ignored(node, "state_snapshot_uncloneable") && true_instance
    );
  }
  if (rune === "$inspect" || rune === "$inspect().with") {
    if (!dev) return empty2;
    const { args, inspector } = get_inspect_args(rune, node, context.visit);
    return rune === "$inspect" ? call(inspector, literal2("$inspect("), ...args, literal2(")")) : call(inspector, literal2("init"), ...args);
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ClassBody.js
function ClassBody2(node, context) {
  const state_fields = context.state.analysis.classes.get(node);
  if (!state_fields) {
    context.next();
    return;
  }
  const body = [];
  const child_state = { ...context.state, state_fields };
  for (const [name, field] of state_fields) {
    if (name[0] === "#") {
      continue;
    }
    if (field && field.node.type === "AssignmentExpression" && (field.type === "$derived" || field.type === "$derived.by")) {
      const member2 = member(this_instance, field.key);
      body.push(
        prop_def(field.key, null),
        method("get", key(name), [], [return_builder(call(member2))]),
        method("set", key(name), [id("$$value")], [return_builder(call(member2, id("$$value")))])
      );
    }
  }
  for (const definition of node.body) {
    if (definition.type !== "PropertyDefinition") {
      body.push(
        /** @type {MethodDefinition | StaticBlock} */
        context.visit(definition, child_state)
      );
      continue;
    }
    const name = get_name(definition.key);
    const field = name && state_fields.get(name);
    if (!field) {
      body.push(
        /** @type {PropertyDefinition} */
        context.visit(definition, child_state)
      );
      continue;
    }
    if (name[0] === "#" || field.type === "$state" || field.type === "$state.raw") {
      body.push(
        /** @type {PropertyDefinition} */
        context.visit(definition, child_state)
      );
    } else if (field.node === definition) {
      const member2 = member(this_instance, field.key);
      body.push(
        prop_def(
          field.key,
          /** @type {CallExpression} */
          context.visit(field.value, child_state)
        ),
        method("get", definition.key, [], [return_builder(call(member2))]),
        method("set", key(name), [id("$$value")], [return_builder(call(member2, id("$$value")))])
      );
    }
  }
  return { ...node, body };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/component.js
function build_inline_component(node, expression, context) {
  const props_and_spreads = [];
  const delayed_props = [];
  const custom_css_props = [];
  const lets = { default: [] };
  const child_state = {
    ...context.state,
    scope: node.metadata.scopes.default
  };
  const children = {};
  const slot_scope_applies_to_itself = node.attributes.some(
    (node2) => node2.type === "Attribute" && node2.name === "slot"
  );
  let has_children_prop = false;
  function push_prop(prop2, delay = false) {
    const do_push = () => {
      const current2 = props_and_spreads.at(-1);
      const current_is_props = Array.isArray(current2);
      const props = current_is_props ? current2 : [];
      props.push(prop2);
      if (!current_is_props) {
        props_and_spreads.push(props);
      }
    };
    if (delay) {
      delayed_props.push(do_push);
    } else {
      do_push();
    }
  }
  const optimiser = new PromiseOptimiser();
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      if (!slot_scope_applies_to_itself) {
        lets.default.push(attribute);
      }
    } else if (attribute.type === "SpreadAttribute") {
      let expression2 = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      props_and_spreads.push(optimiser.transform(expression2, attribute.metadata.expression));
    } else if (attribute.type === "Attribute") {
      const value = build_attribute_value(
        attribute.value,
        context,
        optimiser.transform,
        false,
        true
      );
      if (attribute.name.startsWith("--")) {
        custom_css_props.push(init(attribute.name, value));
        continue;
      }
      if (attribute.name === "children") {
        has_children_prop = true;
      }
      push_prop(prop("init", key(attribute.name), value));
    } else if (attribute.type === "BindDirective" && attribute.name !== "this") {
      optimiser.check_blockers(attribute.metadata.expression);
      if (attribute.expression.type === "SequenceExpression") {
        const [get3, set2] = (
          /** @type {SequenceExpression} */
          context.visit(attribute.expression).expressions
        );
        const get_id = id(context.state.scope.generate("bind_get"));
        const set_id = id(context.state.scope.generate("bind_set"));
        context.state.init.push(var_builder(get_id, get3));
        context.state.init.push(var_builder(set_id, set2));
        push_prop(get(attribute.name, [return_builder(call(get_id))]));
        push_prop(set(attribute.name, [stmt(call(set_id, id("$$value")))]));
      } else {
        push_prop(
          get(attribute.name, [
            return_builder(
              /** @type {Expression} */
              context.visit(attribute.expression)
            )
          ]),
          true
        );
        push_prop(
          set(attribute.name, [
            stmt(
              /** @type {Expression} */
              context.visit(assignment("=", attribute.expression, id("$$value")))
            ),
            stmt(assignment("=", id("$$settled"), false_instance))
          ]),
          true
        );
      }
    } else if (attribute.type === "AttachTag") {
      optimiser.check_blockers(attribute.metadata.expression);
    }
  }
  delayed_props.forEach((fn) => fn());
  const snippet_declarations = [];
  const serialized_slots = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock") {
      context.visit(child, {
        ...context.state,
        init: snippet_declarations
      });
      push_prop(prop("init", child.expression, child.expression));
      serialized_slots.push(
        init(child.expression.name === "children" ? "default" : child.expression.name, true_instance)
      );
      continue;
    }
    let slot_name = "default";
    if (is_element_node(child)) {
      const slot = (
        /** @type {AST.Attribute | undefined} */
        child.attributes.find(
          (attribute) => attribute.type === "Attribute" && attribute.name === "slot"
        )
      );
      if (slot !== void 0) {
        slot_name = /** @type {AST.Text[]} */
        slot.value[0].data;
        lets[slot_name] = child.attributes.filter((attribute) => attribute.type === "LetDirective");
      } else if (child.type === "SvelteFragment") {
        lets.default.push(
          ...child.attributes.filter((attribute) => attribute.type === "LetDirective")
        );
      }
    }
    children[slot_name] = children[slot_name] || [];
    children[slot_name].push(child);
  }
  for (const slot_name of Object.keys(children)) {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(
        {
          ...node.fragment,
          // @ts-expect-error
          nodes: children[slot_name]
        },
        slot_name === "default" ? child_state : {
          ...context.state,
          scope: node.metadata.scopes[slot_name]
        }
      )
    );
    if (block2.body.length === 0) continue;
    const params = [id("$$renderer")];
    if (lets[slot_name].length > 0) {
      const pattern = object_pattern(
        lets[slot_name].map((node2) => {
          if (node2.expression === null) {
            return init(node2.name, id(node2.name));
          }
          if (node2.expression.type === "ObjectExpression") {
            return init(node2.name, object_pattern(node2.expression.properties));
          }
          if (node2.expression.type === "ArrayExpression") {
            return init(node2.name, array_pattern(node2.expression.elements));
          }
          return init(node2.name, node2.expression);
        })
      );
      params.push(pattern);
    }
    const slot_fn = arrow(params, block(block2.body));
    if (slot_name === "default" && !has_children_prop) {
      if (lets.default.length === 0 && children.default.every(
        (node2) => node2.type !== "SvelteFragment" || !node2.attributes.some((attr) => attr.type === "LetDirective")
      )) {
        push_prop(
          prop(
            "init",
            id("children"),
            dev ? call("$.prevent_snippet_stringification", slot_fn) : slot_fn
          )
        );
        serialized_slots.push(init(slot_name, true_instance));
      } else {
        serialized_slots.push(init(slot_name, slot_fn));
        push_prop(init("children", id("$.invalid_default_snippet")));
      }
    } else {
      serialized_slots.push(init(slot_name, slot_fn));
    }
  }
  if (serialized_slots.length > 0) {
    push_prop(prop("init", id("$$slots"), object(serialized_slots)));
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    array(props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p))
  );
  let statement = stmt(
    (node.type === "SvelteComponent" ? maybe_call : call)(
      expression,
      id("$$renderer"),
      props_expression
    )
  );
  if (snippet_declarations.length > 0) {
    statement = block([...snippet_declarations, statement]);
  }
  const dynamic = node.type === "SvelteComponent" || node.type === "Component" && node.metadata.dynamic;
  if (custom_css_props.length > 0) {
    statement = stmt(
      call(
        "$.css_props",
        id("$$renderer"),
        literal2(context.state.namespace === "svg" ? false : true),
        object(custom_css_props),
        thunk(block([statement])),
        dynamic && true_instance
      )
    );
  }
  if (node.type !== "SvelteSelf") {
    optimiser.check_blockers(node.metadata.expression);
  }
  const is_async = optimiser.is_async();
  if (is_async) {
    statement = create_async_block(
      block([
        optimiser.apply(),
        dynamic && custom_css_props.length === 0 ? stmt(call("$$renderer.push", empty_comment)) : empty2,
        statement
      ]),
      optimiser.blockers(),
      optimiser.has_await
    );
  } else if (dynamic && custom_css_props.length === 0) {
    context.state.template.push(empty_comment);
  }
  context.state.template.push(statement);
  if (!is_async && !context.state.skip_hydration_boundaries && custom_css_props.length === 0 && optimiser.expressions.length === 0) {
    context.state.template.push(empty_comment);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Component.js
function Component2(node, context) {
  build_inline_component(node, id(node.name), context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ConstTag.js
function ConstTag2(node, context) {
  const declaration2 = node.declaration.declarations[0];
  const id2 = (
    /** @type {Pattern} */
    context.visit(declaration2.id)
  );
  const init3 = (
    /** @type {Expression} */
    context.visit(declaration2.init)
  );
  const has_await = node.metadata.expression.has_await;
  if (has_await || context.state.async_consts) {
    const run = context.state.async_consts ??= {
      id: id(context.state.scope.generate("promises")),
      thunks: []
    };
    const identifiers = extract_identifiers(declaration2.id);
    const bindings = context.state.scope.get_bindings(declaration2);
    for (const identifier of identifiers) {
      context.state.init.push(let_builder(identifier.name));
    }
    const assignment2 = assignment("=", id2, init3);
    run.thunks.push(thunk(block([stmt(assignment2)]), has_await));
    const blocker = member(run.id, literal2(run.thunks.length - 1), true);
    for (const binding of bindings) {
      binding.blocker = blocker;
    }
  } else {
    context.state.init.push(const_builder(id2, init3));
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/DebugTag.js
function DebugTag2(node, context) {
  context.state.template.push(
    stmt(
      call(
        "console.log",
        object(
          node.identifiers.map(
            (identifier) => prop(
              "init",
              identifier,
              /** @type {Expression} */
              context.visit(identifier)
            )
          )
        )
      )
    ),
    debugger_builder
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/EachBlock.js
function EachBlock2(node, context) {
  const state = context.state;
  const each_node_meta = node.metadata;
  const collection = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
  const array_id = state.scope.root.unique("each_array");
  let block2 = block([const_builder(array_id, call("$.ensure_array_like", collection))]);
  const each = [];
  if (node.context) {
    each.push(let_builder(node.context, member(array_id, index, true)));
  }
  if (index.name !== node.index && node.index != null) {
    each.push(let_builder(node.index, index));
  }
  const new_body = (
    /** @type {BlockStatement} */
    context.visit(node.body).body
  );
  if (node.body) each.push(...new_body);
  const for_loop = for_builder(
    declaration("let", [
      declarator(index, literal2(0)),
      declarator("$$length", member(array_id, "length"))
    ]),
    binary("<", index, id("$$length")),
    update("++", index, false),
    block(each)
  );
  if (node.fallback) {
    const open2 = stmt(call(id("$$renderer.push"), block_open));
    const fallback = (
      /** @type {BlockStatement} */
      context.visit(node.fallback)
    );
    fallback.body.unshift(stmt(call(id("$$renderer.push"), block_open_else)));
    block2.body.push(
      if_builder(
        binary("!==", member(array_id, "length"), literal2(0)),
        block([open2, for_loop]),
        fallback
      )
    );
  } else {
    state.template.push(block_open);
    block2.body.push(for_loop);
  }
  if (node.metadata.expression.is_async()) {
    state.template.push(
      create_async_block(
        block2,
        node.metadata.expression.blockers(),
        node.metadata.expression.has_await
      ),
      block_close
    );
  } else {
    state.template.push(...block2.body, block_close);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ExpressionStatement.js
function ExpressionStatement2(node, context) {
  const rune = get_rune(node.expression, context.state.scope);
  if (rune === "$effect" || rune === "$effect.pre" || rune === "$effect.root" || rune === "$inspect.trace") {
    return empty2;
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Fragment.js
function Fragment2(node, context) {
  const parent = context.path.at(-1) ?? node;
  const namespace = infer_namespace(context.state.namespace, parent, node.nodes);
  const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
    parent,
    node.nodes,
    context.path,
    namespace,
    context.state,
    context.state.preserve_whitespace,
    context.state.options.preserveComments
  );
  const state = {
    ...context.state,
    init: [],
    template: [],
    namespace,
    skip_hydration_boundaries: is_standalone,
    async_consts: void 0
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_text_first) {
    state.template.push(empty_comment);
  }
  process_children(trimmed, { ...context, state });
  if (state.async_consts && state.async_consts.thunks.length > 0) {
    state.init.push(
      var_builder(state.async_consts.id, call("$$renderer.run", array(state.async_consts.thunks)))
    );
  }
  return block([...state.init, ...build_template(state.template)]);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/HtmlTag.js
function HtmlTag2(node, context) {
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const call2 = call("$.html", expression);
  context.state.template.push(create_push(call2, node.metadata.expression, true));
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Identifier.js
function Identifier2(node, context) {
  if (is_reference(
    node,
    /** @type {Node} */
    context.path.at(-1)
  )) {
    if (node.name === "$$props") {
      return id("$$sanitized_props");
    }
    return build_getter2(node, context.state);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/IfBlock.js
function IfBlock2(node, context) {
  const test = (
    /** @type {Expression} */
    context.visit(node.test)
  );
  const consequent = (
    /** @type {BlockStatement} */
    context.visit(node.consequent)
  );
  const alternate = node.alternate ? (
    /** @type {BlockStatement} */
    context.visit(node.alternate)
  ) : block([]);
  consequent.body.unshift(stmt(call(id("$$renderer.push"), block_open)));
  alternate.body.unshift(stmt(call(id("$$renderer.push"), block_open_else)));
  let statement = if_builder(test, consequent, alternate);
  const is_async = node.metadata.expression.is_async();
  const has_await = node.metadata.expression.has_await;
  if (is_async || has_await) {
    statement = create_async_block(
      block([statement]),
      node.metadata.expression.blockers(),
      !!has_await
    );
  }
  context.state.template.push(statement, block_close);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/KeyBlock.js
function KeyBlock2(node, context) {
  const is_async = node.metadata.expression.is_async();
  if (is_async) context.state.template.push(block_open);
  context.state.template.push(
    empty_comment,
    /** @type {BlockStatement} */
    context.visit(node.fragment),
    empty_comment
  );
  if (is_async) context.state.template.push(block_close);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/LabeledStatement.js
function LabeledStatement2(node, context) {
  if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== "$") {
    return;
  }
  context.state.legacy_reactive_statements.set(
    node,
    // people could do "break $" inside, so we need to keep the label
    labeled(
      "$",
      /** @type {ExpressionStatement} */
      context.visit(node.body)
    )
  );
  return empty2;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/MemberExpression.js
function MemberExpression2(node, context) {
  if (context.state.analysis.runes && node.property.type === "PrivateIdentifier") {
    const field = context.state.state_fields?.get(`#${node.property.name}`);
    if (field?.type === "$derived" || field?.type === "$derived.by") {
      return call(node);
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/shared/transform-async.js
function transform_body(instance_body, runner, transform) {
  const statements = instance_body.sync.map(
    (node) => (
      /** @type {ESTree.Statement | ESTree.VariableDeclaration} */
      transform(node)
    )
  );
  if (instance_body.declarations.length > 0) {
    statements.push(
      declaration(
        "var",
        instance_body.declarations.map((id2) => declarator(id2))
      )
    );
  }
  if (instance_body.async.length > 0) {
    const thunks = instance_body.async.map((s) => {
      if (s.node.type === "VariableDeclarator") {
        const visited = (
          /** @type {ESTree.VariableDeclaration} */
          transform(var_builder(s.node.id, s.node.init))
        );
        if (visited.declarations.length === 1) {
          return thunk(
            assignment("=", visited.declarations[0].id, visited.declarations[0].init ?? void0),
            s.has_await
          );
        }
        return thunk(
          block([
            var_builder(visited.declarations[0].id, visited.declarations[0].init),
            ...visited.declarations.slice(1).map((d) => stmt(assignment("=", d.id, d.init ?? void0)))
          ]),
          s.has_await
        );
      }
      if (s.node.type === "ClassDeclaration") {
        return thunk(
          assignment(
            "=",
            s.node.id,
            /** @type {ESTree.ClassExpression} */
            { ...s.node, type: "ClassExpression" }
          ),
          s.has_await
        );
      }
      if (s.node.type === "ExpressionStatement") {
        const expression = (
          /** @type {ESTree.Expression} */
          transform(s.node.expression)
        );
        return expression.type === "AwaitExpression" ? thunk(expression, true) : thunk(unary("void", expression), s.has_await);
      }
      return thunk(block([
        /** @type {ESTree.Statement} */
        transform(s.node)
      ]), s.has_await);
    });
    statements.push(var_builder("$$promises", call(runner, array(thunks))));
  }
  return statements;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Program.js
function Program(node, context) {
  if (context.state.is_instance) {
    const state = (
      /** @type {ComponentServerTransformState} */
      context.state
    );
    return {
      ...node,
      body: transform_body(
        state.analysis.instance_body,
        id("$$renderer.run"),
        (node2) => (
          /** @type {Node} */
          context.visit(node2)
        )
      )
    };
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/PropertyDefinition.js
function PropertyDefinition2(node, context) {
  if (context.state.analysis.runes && node.value != null && node.value.type === "CallExpression") {
    const rune = get_rune(node.value, context.state.scope);
    if (rune === "$state" || rune === "$state.raw") {
      return {
        ...node,
        value: node.value.arguments.length === 0 ? null : (
          /** @type {Expression} */
          context.visit(node.value.arguments[0])
        )
      };
    }
    if (rune === "$derived.by" || rune === "$derived") {
      const fn = (
        /** @type {Expression} */
        context.visit(node.value.arguments[0])
      );
      return {
        ...node,
        value: node.value.arguments.length === 0 ? null : call("$.derived", rune === "$derived" ? thunk(fn) : fn)
      };
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/element.js
var WHITESPACE_INSENSITIVE_ATTRIBUTES = ["class", "style"];
function build_element_attributes(node, context, transform) {
  const attributes = [];
  const class_directives = [];
  const style_directives = [];
  let content = null;
  let has_spread = false;
  let events_to_capture = /* @__PURE__ */ new Set();
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "value") {
        if (node.name === "textarea") {
          if (attribute.value !== true && Array.isArray(attribute.value) && attribute.value[0].type === "Text" && regex_starts_with_newline.test(attribute.value[0].data)) {
            attribute.value[0].data = "\n" + attribute.value[0].data;
          }
          content = call("$.escape", build_attribute_value(attribute.value, context, transform));
        } else if (node.name !== "select") {
          attributes.push(attribute);
        }
      } else if (is_event_attribute(attribute)) {
        if ((attribute.name === "onload" || attribute.name === "onerror") && is_load_error_element(node.name)) {
          events_to_capture.add(attribute.name);
        }
      } else if (attribute.name !== "defaultValue" && attribute.name !== "defaultChecked") {
        if (attribute.name === "class") {
          if (attribute.metadata.needs_clsx) {
            attributes.push({
              ...attribute,
              value: {
                .../** @type {AST.ExpressionTag} */
                attribute.value,
                expression: call(
                  "$.clsx",
                  /** @type {AST.ExpressionTag} */
                  attribute.value.expression
                )
              }
            });
          } else {
            attributes.push(attribute);
          }
        } else {
          attributes.push(attribute);
        }
      }
    } else if (attribute.type === "BindDirective") {
      if (attribute.name === "value" && node.name === "select") continue;
      if (attribute.name === "value" && attributes.some(
        (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute(attr) && attr.value[0].data === "file"
      )) {
        continue;
      }
      if (attribute.name === "this") continue;
      const binding = binding_properties[attribute.name];
      if (binding?.omit_in_ssr) continue;
      let expression = (
        /** @type {Expression} */
        context.visit(attribute.expression)
      );
      if (expression.type === "SequenceExpression") {
        expression = call(expression.expressions[0]);
      }
      expression = transform(expression, attribute.metadata.expression);
      if (is_content_editable_binding(attribute.name)) {
        content = expression;
      } else if (attribute.name === "value" && node.name === "textarea") {
        content = call("$.escape", expression);
      } else if (attribute.name === "group" && attribute.expression.type !== "SequenceExpression") {
        const value_attribute = (
          /** @type {AST.Attribute | undefined} */
          node.attributes.find((attr) => attr.type === "Attribute" && attr.name === "value")
        );
        if (!value_attribute) continue;
        const is_checkbox = node.attributes.some(
          (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute(attr) && attr.value[0].data === "checkbox"
        );
        attributes.push(
          create_attribute("checked", -1, -1, [
            {
              type: "ExpressionTag",
              start: -1,
              end: -1,
              expression: is_checkbox ? call(
                member(attribute.expression, "includes"),
                build_attribute_value(value_attribute.value, context, transform)
              ) : binary(
                "===",
                attribute.expression,
                build_attribute_value(value_attribute.value, context, transform)
              ),
              metadata: {
                expression: new ExpressionMetadata()
              }
            }
          ])
        );
      } else {
        attributes.push(
          create_attribute(attribute.name, -1, -1, [
            {
              type: "ExpressionTag",
              start: -1,
              end: -1,
              expression,
              metadata: {
                expression: new ExpressionMetadata()
              }
            }
          ])
        );
      }
    } else if (attribute.type === "SpreadAttribute") {
      attributes.push(attribute);
      has_spread = true;
      if (is_load_error_element(node.name)) {
        events_to_capture.add("onload");
        events_to_capture.add("onerror");
      }
    } else if (attribute.type === "UseDirective") {
      if (is_load_error_element(node.name)) {
        events_to_capture.add("onload");
        events_to_capture.add("onerror");
      }
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
    } else {
      context.visit(attribute);
    }
  }
  if (has_spread) {
    build_element_spread_attributes(
      node,
      attributes,
      style_directives,
      class_directives,
      context,
      transform
    );
  } else {
    const css_hash = node.metadata.scoped ? context.state.analysis.css.hash : null;
    for (
      const attribute of
      /** @type {AST.Attribute[]} */
      attributes
    ) {
      const name = get_attribute_name(node, attribute);
      const can_use_literal = (name !== "class" || class_directives.length === 0) && (name !== "style" || style_directives.length === 0);
      if (can_use_literal && (attribute.value === true || is_text_attribute(attribute))) {
        let literal_value = (
          /** @type {Literal} */
          build_attribute_value(
            attribute.value,
            context,
            transform,
            WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
          ).value
        );
        if (name === "class" && css_hash) {
          literal_value = (String(literal_value) + " " + css_hash).trim();
        }
        if (name !== "class" || literal_value) {
          context.state.template.push(
            literal2(
              ` ${attribute.name}${is_boolean_attribute(name) && literal_value === true ? "" : `="${literal_value === true ? "" : String(literal_value)}"`}`
            )
          );
        }
        continue;
      }
      const value = build_attribute_value(
        attribute.value,
        context,
        transform,
        WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
      );
      if (can_use_literal && value.type === "Literal" && typeof value.value === "string") {
        if (name === "class" && css_hash) {
          value.value = (value.value + " " + css_hash).trim();
        }
        context.state.template.push(literal2(` ${name}="${escape_html(value.value, true)}"`));
      } else if (name === "class") {
        context.state.template.push(
          build_attr_class(class_directives, value, context, css_hash, transform)
        );
      } else if (name === "style") {
        context.state.template.push(build_attr_style(style_directives, value, context, transform));
      } else {
        context.state.template.push(
          call("$.attr", literal2(name), value, is_boolean_attribute(name) && true_instance)
        );
      }
    }
  }
  if (events_to_capture.size !== 0) {
    for (const event of events_to_capture) {
      context.state.template.push(literal2(` ${event}="this.__e=event"`));
    }
  }
  return content;
}
function get_attribute_name(element2, attribute) {
  let name = attribute.name;
  if (!element2.metadata.svg && !element2.metadata.mathml) {
    name = name.toLowerCase();
  }
  return name;
}
function build_spread_object(element2, attributes, context, transform) {
  const object4 = object(
    attributes.map((attribute) => {
      if (attribute.type === "Attribute") {
        const name = get_attribute_name(element2, attribute);
        const value = build_attribute_value(
          attribute.value,
          context,
          transform,
          WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
        );
        return prop("init", key(name), value);
      } else if (attribute.type === "BindDirective") {
        const name = get_attribute_name(element2, attribute);
        const value = attribute.expression.type === "SequenceExpression" ? call(attribute.expression.expressions[0]) : (
          /** @type {Expression} */
          context.visit(attribute.expression)
        );
        return prop("init", key(name), value);
      }
      return spread(
        transform(
          /** @type {Expression} */
          context.visit(attribute),
          attribute.metadata.expression
        )
      );
    })
  );
  return object4;
}
function build_element_spread_attributes(element2, attributes, style_directives, class_directives, context, transform) {
  const args = prepare_element_spread(
    element2,
    /** @type {Array<AST.Attribute | AST.SpreadAttribute | AST.BindDirective>} */
    attributes,
    style_directives,
    class_directives,
    context,
    transform
  );
  let call2 = call("$.attributes", ...args);
  context.state.template.push(call2);
}
function prepare_element_spread_object(element2, context, transform) {
  const select_attributes = [];
  const class_directives = [];
  const style_directives = [];
  for (const attribute of element2.attributes) {
    if (attribute.type === "Attribute" || attribute.type === "BindDirective" || attribute.type === "SpreadAttribute") {
      select_attributes.push(attribute);
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    }
  }
  return prepare_element_spread(
    element2,
    select_attributes,
    style_directives,
    class_directives,
    context,
    transform
  );
}
function prepare_element_spread(element2, attributes, style_directives, class_directives, context, transform) {
  let classes;
  let styles;
  let flags = 0;
  if (class_directives.length) {
    const properties = class_directives.map(
      (directive) => init(
        directive.name,
        directive.expression.type === "Identifier" && directive.expression.name === directive.name ? id(directive.name) : transform(
          /** @type {Expression} */
          context.visit(directive.expression),
          directive.metadata.expression
        )
      )
    );
    classes = object(properties);
  }
  if (style_directives.length > 0) {
    const properties = style_directives.map(
      (directive) => init(
        directive.name,
        directive.value === true ? id(directive.name) : build_attribute_value(directive.value, context, transform, true)
      )
    );
    styles = object(properties);
  }
  if (element2.metadata.svg || element2.metadata.mathml) {
    flags |= ELEMENT_IS_NAMESPACED | ELEMENT_PRESERVE_ATTRIBUTE_CASE;
  } else if (is_custom_element_node(element2)) {
    flags |= ELEMENT_PRESERVE_ATTRIBUTE_CASE;
  } else if (element2.type === "RegularElement" && element2.name === "input") {
    flags |= ELEMENT_IS_INPUT;
  }
  const object4 = build_spread_object(element2, attributes, context, transform);
  const css_hash = element2.metadata.scoped && context.state.analysis.css.hash ? literal2(context.state.analysis.css.hash) : void 0;
  return [object4, css_hash, classes, styles, flags ? literal2(flags) : void 0];
}
function build_attr_class(class_directives, expression, context, hash2, transform) {
  let directives;
  if (class_directives.length) {
    directives = object(
      class_directives.map(
        (directive) => prop(
          "init",
          literal2(directive.name),
          transform(
            /** @type {Expression} */
            context.visit(directive.expression, context.state),
            directive.metadata.expression
          )
        )
      )
    );
  }
  let css_hash;
  if (hash2) {
    if (expression.type === "Literal" && typeof expression.value === "string") {
      expression.value = (expression.value + " " + hash2).trim();
    } else {
      css_hash = literal2(hash2);
    }
  }
  return call("$.attr_class", expression, css_hash, directives);
}
function build_attr_style(style_directives, expression, context, transform) {
  let directives;
  if (style_directives.length) {
    let normal_properties = [];
    let important_properties = [];
    for (const directive of style_directives) {
      const expression2 = directive.value === true ? id(directive.name) : build_attribute_value(directive.value, context, transform, true);
      let name = directive.name;
      if (name[0] !== "-" || name[1] !== "-") {
        name = name.toLowerCase();
      }
      const property = init(directive.name, expression2);
      if (directive.modifiers.includes("important")) {
        important_properties.push(property);
      } else {
        normal_properties.push(property);
      }
    }
    if (important_properties.length) {
      directives = array([object(normal_properties), object(important_properties)]);
    } else {
      directives = object(normal_properties);
    }
  }
  return call("$.attr_style", expression, directives);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/RegularElement.js
function RegularElement2(node, context) {
  const namespace = determine_namespace_for_children(node, context.state.namespace);
  const state = {
    ...context.state,
    namespace,
    preserve_whitespace: context.state.preserve_whitespace || node.name === "pre" || node.name === "textarea",
    init: [],
    template: []
  };
  const node_is_void = is_void(node.name);
  const optimiser = new PromiseOptimiser();
  const is_select_special = node.name === "select" && node.attributes.some(
    (attribute) => (attribute.type === "Attribute" || attribute.type === "BindDirective") && attribute.name === "value" || attribute.type === "SpreadAttribute"
  );
  const is_option_special = node.name === "option";
  const is_special = is_select_special || is_option_special;
  let body = (
    /** @type {Expression | null} */
    null
  );
  if (!is_special) {
    state.template.push(literal2(`<${node.name}`));
    body = build_element_attributes(node, { ...context, state }, optimiser.transform);
    state.template.push(literal2(node_is_void ? "/>" : ">"));
  }
  if ((node.name === "script" || node.name === "style") && node.fragment.nodes.length === 1) {
    state.template.push(
      literal2(
        /** @type {AST.Text} */
        node.fragment.nodes[0].data
      ),
      literal2(`</${node.name}>`)
    );
    if (optimiser.expressions.length > 0) {
      context.state.template.push(
        create_child_block(
          block([optimiser.apply(), ...state.init, ...build_template(state.template)]),
          true
        )
      );
    } else {
      context.state.init.push(...state.init);
      context.state.template.push(...state.template);
    }
    return;
  }
  const { hoisted, trimmed } = clean_nodes(
    node,
    node.fragment.nodes,
    context.path,
    namespace,
    {
      ...state,
      scope: (
        /** @type {Scope} */
        state.scopes.get(node.fragment)
      )
    },
    state.preserve_whitespace,
    state.options.preserveComments
  );
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (dev) {
    const location2 = (
      /** @type {Location} */
      locator(node.start)
    );
    state.template.push(
      stmt(
        call(
          "$.push_element",
          id("$$renderer"),
          literal2(node.name),
          literal2(location2.line),
          literal2(location2.column)
        )
      )
    );
  }
  if (is_select_special) {
    const inner_state = { ...state, template: [], init: [] };
    process_children(trimmed, { ...context, state: inner_state });
    const fn = arrow(
      [id("$$renderer")],
      block([...state.init, ...build_template(inner_state.template)])
    );
    const [attributes, ...rest2] = prepare_element_spread_object(node, context, optimiser.transform);
    const statement = stmt(call("$$renderer.select", attributes, fn, ...rest2));
    if (optimiser.expressions.length > 0) {
      context.state.template.push(
        create_child_block(block([optimiser.apply(), ...state.init, statement]), true)
      );
    } else {
      context.state.template.push(...state.init, statement);
    }
    return;
  }
  if (is_option_special) {
    let body2;
    if (node.metadata.synthetic_value_node) {
      body2 = optimiser.transform(
        node.metadata.synthetic_value_node.expression,
        node.metadata.synthetic_value_node.metadata.expression
      );
    } else {
      const inner_state = { ...state, template: [], init: [] };
      process_children(trimmed, { ...context, state: inner_state });
      body2 = arrow(
        [id("$$renderer")],
        block([...state.init, ...build_template(inner_state.template)])
      );
    }
    const [attributes, ...rest2] = prepare_element_spread_object(node, context, optimiser.transform);
    const statement = stmt(call("$$renderer.option", attributes, body2, ...rest2));
    if (optimiser.expressions.length > 0) {
      context.state.template.push(
        create_child_block(block([optimiser.apply(), ...state.init, statement]), true)
      );
    } else {
      context.state.template.push(...state.init, statement);
    }
    return;
  }
  if (body !== null) {
    const inner_state = { ...state, template: [], init: [] };
    process_children(trimmed, { ...context, state: inner_state });
    let id2 = (
      /** @type {Expression} */
      body
    );
    if (body.type !== "Identifier") {
      id2 = id(state.scope.generate("$$body"));
      state.template.push(const_builder(id2, body));
    }
    state.template.push(
      if_builder(
        id2,
        block(build_template([id2])),
        block([...inner_state.init, ...build_template(inner_state.template)])
      )
    );
  } else {
    process_children(trimmed, { ...context, state });
  }
  if (!node_is_void) {
    state.template.push(literal2(`</${node.name}>`));
  }
  if (dev) {
    state.template.push(stmt(call("$.pop_element")));
  }
  if (optimiser.is_async()) {
    let statement = create_child_block(
      block([optimiser.apply(), ...state.init, ...build_template(state.template)]),
      true
    );
    const blockers = optimiser.blockers();
    if (blockers.elements.length > 0) {
      statement = create_async_block(block([statement]), blockers, false, false);
    }
    context.state.template.push(statement);
  } else {
    context.state.init.push(...state.init);
    context.state.template.push(...state.template);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/RenderTag.js
function RenderTag2(node, context) {
  const optimiser = new PromiseOptimiser();
  const callee = unwrap_optional(node.expression).callee;
  const raw_args = unwrap_optional(node.expression).arguments;
  const snippet_function = optimiser.transform(
    /** @type {Expression} */
    context.visit(callee),
    node.metadata.expression
  );
  const snippet_args = raw_args.map((arg, i) => {
    return optimiser.transform(
      /** @type {Expression} */
      context.visit(arg),
      node.metadata.arguments[i]
    );
  });
  let statement = stmt(
    (node.expression.type === "CallExpression" ? call : maybe_call)(
      snippet_function,
      id("$$renderer"),
      ...snippet_args
    )
  );
  if (optimiser.is_async()) {
    statement = create_async_block(
      block([optimiser.apply(), statement]),
      optimiser.blockers(),
      optimiser.has_await
    );
  }
  context.state.template.push(statement);
  if (!context.state.skip_hydration_boundaries) {
    context.state.template.push(empty_comment);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SlotElement.js
function SlotElement2(node, context) {
  const props = [];
  const spreads = [];
  const optimiser = new PromiseOptimiser();
  let name = literal2("default");
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      let expression = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      spreads.push(optimiser.transform(expression, attribute.metadata.expression));
    } else if (attribute.type === "Attribute") {
      const value = build_attribute_value(
        attribute.value,
        context,
        optimiser.transform,
        false,
        true
      );
      if (attribute.name === "name") {
        name = /** @type {Literal} */
        value;
      } else if (attribute.name !== "slot") {
        props.push(init(attribute.name, value));
      }
    }
  }
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", array([object(props), ...spreads]));
  const fallback = node.fragment.nodes.length === 0 ? null_instance : thunk(
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  const slot = call(
    "$.slot",
    id("$$renderer"),
    id("$$props"),
    name,
    props_expression,
    fallback
  );
  const statement = optimiser.is_async() ? create_async_block(
    block([optimiser.apply(), stmt(slot)]),
    optimiser.blockers(),
    optimiser.has_await
  ) : stmt(slot);
  context.state.template.push(block_open, statement, block_close);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SnippetBlock.js
function SnippetBlock2(node, context) {
  let fn = function_declaration(
    node.expression,
    [id("$$renderer"), ...node.parameters],
    /** @type {BlockStatement} */
    context.visit(node.body)
  );
  fn.___snippet = true;
  const statements = node.metadata.can_hoist ? context.state.hoisted : context.state.init;
  if (dev) {
    fn.body.body.unshift(stmt(call("$.validate_snippet_args", id("$$renderer"))));
    statements.push(stmt(call("$.prevent_snippet_stringification", fn.id)));
  }
  statements.push(fn);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SpreadAttribute.js
function SpreadAttribute2(node, context) {
  return context.visit(node.expression);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteComponent.js
function SvelteComponent2(node, context) {
  build_inline_component(
    node,
    /** @type {Expression} */
    context.visit(node.expression),
    context
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteElement.js
function SvelteElement2(node, context) {
  let tag2 = (
    /** @type {Expression} */
    context.visit(node.tag)
  );
  if (dev) {
    if (tag2.type !== "Identifier") {
      const tag_id = context.state.scope.generate("$$tag");
      context.state.init.push(const_builder(tag_id, tag2));
      tag2 = id(tag_id);
    }
    if (node.fragment.nodes.length > 0) {
      context.state.init.push(stmt(call("$.validate_void_dynamic_element", thunk(tag2))));
    }
    context.state.init.push(stmt(call("$.validate_dynamic_element_tag", thunk(tag2))));
  }
  const state = {
    ...context.state,
    namespace: determine_namespace_for_children(node, context.state.namespace),
    template: [],
    init: []
  };
  const optimiser = new PromiseOptimiser();
  let statements = [];
  build_element_attributes(node, { ...context, state }, optimiser.transform);
  if (dev) {
    const location2 = (
      /** @type {Location} */
      locator(node.start)
    );
    statements.push(
      stmt(
        call(
          "$.push_element",
          id("$$renderer"),
          tag2,
          literal2(location2.line),
          literal2(location2.column)
        )
      )
    );
  }
  const attributes = block([...state.init, ...build_template(state.template)]);
  const children = (
    /** @type {BlockStatement} */
    context.visit(node.fragment, state)
  );
  let statement = stmt(
    call(
      "$.element",
      id("$$renderer"),
      tag2,
      attributes.body.length > 0 && thunk(attributes),
      children.body.length > 0 && thunk(children)
    )
  );
  if (optimiser.expressions.length > 0) {
    statement = create_child_block(block([optimiser.apply(), statement]), true);
  }
  statements.push(statement);
  if (dev) {
    statements.push(stmt(call("$.pop_element")));
  }
  if (node.metadata.expression.is_async()) {
    statements = [
      create_async_block(
        block(statements),
        node.metadata.expression.blockers(),
        node.metadata.expression.has_await
      )
    ];
  }
  context.state.template.push(...statements);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteFragment.js
function SvelteFragment2(node, context) {
  context.state.template.push(
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteHead.js
function SvelteHead2(node, context) {
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  context.state.template.push(
    stmt(
      call(
        "$.head",
        literal2(hash(filename)),
        id("$$renderer"),
        arrow([id("$$renderer")], block2)
      )
    )
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteSelf.js
function SvelteSelf2(node, context) {
  build_inline_component(node, id(context.state.analysis.name), context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/TitleElement.js
function TitleElement2(node, context) {
  const template2 = [literal2("<title>")];
  process_children(node.fragment.nodes, { ...context, state: { ...context.state, template: template2 } });
  template2.push(literal2("</title>"));
  context.state.init.push(
    stmt(
      call("$$renderer.title", arrow([id("$$renderer")], block(build_template(template2))))
    )
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/UpdateExpression.js
function UpdateExpression2(node, context) {
  const argument = node.argument;
  if (argument.type === "Identifier" && context.state.scope.get(argument.name)?.kind === "store_sub") {
    return call(
      node.prefix ? "$.update_store_pre" : "$.update_store",
      assignment("??=", id("$$store_subs"), object([])),
      literal2(argument.name),
      id(argument.name.slice(1)),
      node.operator === "--" && literal2(-1)
    );
  }
  return context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/VariableDeclaration.js
function VariableDeclaration(node, context) {
  const declarations = [];
  if (context.state.analysis.runes) {
    for (const declarator2 of node.declarations) {
      const init3 = declarator2.init;
      const rune = get_rune(init3, context.state.scope);
      if (!rune || rune === "$effect.tracking" || rune === "$inspect" || rune === "$effect.root") {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (rune === "$props.id") {
        continue;
      }
      if (rune === "$props") {
        let has_rest = false;
        let id2 = walk(declarator2.id, null, {
          RestElement(node2, context2) {
            if (context2.path.at(-1) === declarator2.id) {
              has_rest = true;
            }
          },
          AssignmentPattern(node2) {
            if (node2.right.type === "CallExpression" && get_rune(node2.right, context.state.scope) === "$bindable") {
              const right = node2.right.arguments.length ? (
                /** @type {Expression} */
                context.visit(node2.right.arguments[0])
              ) : void0;
              return assignment_pattern(node2.left, right);
            }
          }
        });
        const slots_name = (
          /** @type {ComponentAnalysis} */
          context.state.analysis.uses_slots ? id("$$slots_") : id("$$slots")
        );
        if (id2.type === "ObjectPattern" && has_rest) {
          id2.properties.splice(
            id2.properties.length - 1,
            0,
            // @ts-ignore
            prop("init", id("$$slots"), slots_name),
            prop("init", id("$$events"), id("$$events"))
          );
        } else if (id2.type === "Identifier") {
          id2 = object_pattern([
            prop("init", id("$$slots"), slots_name),
            prop("init", id("$$events"), id("$$events")),
            rest(id(id2.name))
          ]);
        }
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(id2),
            id("$$props")
          )
        );
        continue;
      }
      const args = (
        /** @type {CallExpression} */
        init3.arguments
      );
      const value = args.length > 0 ? (
        /** @type {Expression} */
        context.visit(args[0])
      ) : void0;
      if (rune === "$derived.by") {
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(declarator2.id),
            call(value)
          )
        );
        continue;
      }
      if (declarator2.id.type === "Identifier") {
        declarations.push(declarator(declarator2.id, value));
        continue;
      }
      if (rune === "$derived") {
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(declarator2.id),
            value
          )
        );
        continue;
      }
      declarations.push(...create_state_declarators(declarator2, context.state.scope, value));
    }
  } else {
    for (const declarator2 of node.declarations) {
      const bindings = (
        /** @type {Binding[]} */
        context.state.scope.get_bindings(declarator2)
      );
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = id(context.state.scope.generate("tmp"));
          const { inserts, paths } = extract_paths(declarator2.id, tmp);
          declarations.push(
            declarator(
              tmp,
              /** @type {Expression} */
              context.visit(
                /** @type {Expression} */
                declarator2.init
              )
            )
          );
          for (const { id: id2, value } of inserts) {
            id2.name = context.state.scope.generate("$$array");
            declarations.push(declarator(id2, value));
          }
          for (const path of paths) {
            const value = path.expression;
            const name = (
              /** @type {Identifier} */
              path.node.name
            );
            const binding2 = (
              /** @type {Binding} */
              context.state.scope.get(name)
            );
            const prop3 = member(id("$$props"), literal2(binding2.prop_alias ?? name), true);
            declarations.push(declarator(path.node, build_fallback(prop3, value)));
          }
          continue;
        }
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(declarator2.id.name)
        );
        const prop2 = member(
          id("$$props"),
          literal2(binding.prop_alias ?? declarator2.id.name),
          true
        );
        let init3 = prop2;
        if (declarator2.init) {
          const default_value = (
            /** @type {Expression} */
            context.visit(declarator2.init)
          );
          init3 = build_fallback(prop2, default_value);
        }
        declarations.push(declarator(declarator2.id, init3));
        continue;
      }
      declarations.push(
        ...create_state_declarators(
          declarator2,
          context.state.scope,
          /** @type {Expression} */
          declarator2.init && context.visit(declarator2.init)
        )
      );
    }
  }
  if (declarations.length === 0) {
    return empty2;
  }
  return {
    ...node,
    declarations
  };
}
function create_state_declarators(declarator2, scope, value) {
  if (declarator2.id.type === "Identifier") {
    return [declarator(declarator2.id, value)];
  }
  const tmp = id(scope.generate("tmp"));
  const { paths, inserts } = extract_paths(declarator2.id, tmp);
  return [
    declarator(tmp, value),
    // TODO inject declarator for opts, so we can use it below
    ...inserts.map(({ id: id2, value: value2 }) => {
      id2.name = scope.generate("$$array");
      return declarator(id2, value2);
    }),
    ...paths.map((path) => {
      const value2 = path.expression;
      return declarator(path.node, value2);
    })
  ];
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteBoundary.js
function SvelteBoundary2(node, context) {
  const pending_attribute = (
    /** @type {AST.Attribute} */
    node.attributes.find((node2) => node2.type === "Attribute" && node2.name === "pending")
  );
  const is_pending_attr_nullish = pending_attribute && typeof pending_attribute.value === "object" && !Array.isArray(pending_attribute.value) && !context.state.scope.evaluate(pending_attribute.value.expression).is_defined;
  const pending_snippet = (
    /** @type {AST.SnippetBlock} */
    node.fragment.nodes.find(
      (node2) => node2.type === "SnippetBlock" && node2.expression.name === "pending"
    )
  );
  if (pending_attribute || pending_snippet) {
    if (pending_attribute && is_pending_attr_nullish && !pending_snippet) {
      const callee = build_attribute_value(
        pending_attribute.value,
        context,
        (expression) => expression,
        false,
        true
      );
      const pending = call(callee, id("$$renderer"));
      const block2 = (
        /** @type {BlockStatement} */
        context.visit(node.fragment)
      );
      context.state.template.push(
        if_builder(
          callee,
          block(build_template([block_open_else, stmt(pending), block_close])),
          block(build_template([block_open, block2, block_close]))
        )
      );
    } else {
      const pending = pending_attribute ? call(
        build_attribute_value(
          pending_attribute.value,
          context,
          (expression) => expression,
          false,
          true
        ),
        id("$$renderer")
      ) : (
        /** @type {BlockStatement} */
        context.visit(pending_snippet.body)
      );
      context.state.template.push(block_open_else, pending, block_close);
    }
  } else {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(node.fragment)
    );
    context.state.template.push(block_open, block2, block_close);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/server/transform-server.js
var global_visitors = {
  _: set_scope,
  AssignmentExpression: AssignmentExpression2,
  AwaitExpression: AwaitExpression2,
  CallExpression: CallExpression2,
  ClassBody: ClassBody2,
  ExpressionStatement: ExpressionStatement2,
  Identifier: Identifier2,
  LabeledStatement: LabeledStatement2,
  MemberExpression: MemberExpression2,
  Program,
  PropertyDefinition: PropertyDefinition2,
  UpdateExpression: UpdateExpression2,
  VariableDeclaration
};
var template_visitors = {
  AwaitBlock: AwaitBlock2,
  Component: Component2,
  ConstTag: ConstTag2,
  DebugTag: DebugTag2,
  EachBlock: EachBlock2,
  Fragment: Fragment2,
  HtmlTag: HtmlTag2,
  IfBlock: IfBlock2,
  KeyBlock: KeyBlock2,
  RegularElement: RegularElement2,
  RenderTag: RenderTag2,
  SlotElement: SlotElement2,
  SnippetBlock: SnippetBlock2,
  SpreadAttribute: SpreadAttribute2,
  SvelteComponent: SvelteComponent2,
  SvelteElement: SvelteElement2,
  SvelteFragment: SvelteFragment2,
  SvelteHead: SvelteHead2,
  SvelteSelf: SvelteSelf2,
  TitleElement: TitleElement2,
  SvelteBoundary: SvelteBoundary2
};
function server_component(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    hoisted: [import_all("$", "svelte/internal/server"), ...analysis.instance_body.hoisted],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    // these are set inside the `Fragment` visitor, and cannot be used until then
    init: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    ),
    namespace: options.namespace,
    preserve_whitespace: options.preserveWhitespace,
    state_fields: /* @__PURE__ */ new Map(),
    skip_hydration_boundaries: false,
    is_instance: false
  };
  const module = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      global_visitors
    )
  );
  const instance = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.instance.ast,
      { ...state, scopes: analysis.instance.scopes, is_instance: true },
      {
        ...global_visitors,
        ImportDeclaration(node) {
          state.hoisted.push(node);
          return empty2;
        },
        ExportNamedDeclaration(node, context) {
          if (node.declaration) {
            return context.visit(node.declaration);
          }
          return empty2;
        }
      }
    )
  );
  const template2 = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.template.ast,
      { ...state, scopes: analysis.template.scopes },
      // @ts-expect-error don't know, don't care
      { ...global_visitors, ...template_visitors }
    )
  );
  const legacy_reactive_declarations = [];
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n2]) => n2 === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
      for (const id2 of extract_identifiers(node.body.expression.left)) {
        const binding = analysis.instance.scope.get(id2.name);
        if (binding?.kind === "legacy_reactive") {
          legacy_reactive_declarations.push(declarator(id2));
        }
      }
    }
    instance.body.push(statement[1]);
  }
  if (legacy_reactive_declarations.length > 0) {
    instance.body.unshift({
      type: "VariableDeclaration",
      kind: "let",
      declarations: legacy_reactive_declarations
    });
  }
  if (analysis.uses_component_bindings) {
    const snippets = template2.body.filter(
      // @ts-expect-error
      (node) => node.type === "FunctionDeclaration" && node.___snippet
    );
    const rest2 = template2.body.filter(
      // @ts-expect-error
      (node) => node.type !== "FunctionDeclaration" || !node.___snippet
    );
    template2.body = [
      ...snippets,
      let_builder("$$settled", true_instance),
      let_builder("$$inner_renderer"),
      function_declaration(
        id("$$render_inner"),
        [id("$$renderer")],
        block(
          /** @type {ESTree.Statement[]} */
          rest2
        )
      ),
      do_while(
        unary("!", id("$$settled")),
        block([
          stmt(assignment("=", id("$$settled"), true_instance)),
          stmt(assignment("=", id("$$inner_renderer"), call("$$renderer.copy"))),
          stmt(call("$$render_inner", id("$$inner_renderer")))
        ])
      ),
      stmt(call("$$renderer.subsume", id("$$inner_renderer")))
    ];
  }
  if ([...analysis.instance.scope.declarations.values()].some(
    (binding) => binding.kind === "store_sub"
  )) {
    instance.body.unshift(var_builder("$$store_subs"));
    template2.body.push(
      if_builder(id("$$store_subs"), stmt(call("$.unsubscribe_stores", id("$$store_subs"))))
    );
  }
  const props = [];
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "bindable_prop" && !name.startsWith("$$")) {
      props.push(init(binding.prop_alias ?? name, id(name)));
    }
  }
  for (const { name, alias } of analysis.exports) {
    props.push(init(alias ?? name, id(name)));
  }
  if (props.length > 0) {
    template2.body.push(stmt(call("$.bind_props", id("$$props"), object(props))));
  }
  let component_block = block([
    .../** @type {ESTree.Statement[]} */
    instance.body,
    .../** @type {ESTree.Statement[]} */
    template2.body
  ]);
  component_block.loc = instance.loc;
  if (analysis.props_id) {
    component_block.body.unshift(
      const_builder(analysis.props_id, call("$.props_id", id("$$renderer")))
    );
  }
  let should_inject_context = dev || analysis.needs_context;
  if (should_inject_context) {
    component_block = block([
      call_component_renderer(component_block, dev && id(component_name))
    ]);
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.rest_props",
          id("$$sanitized_props"),
          array(named_props.map((name) => literal2(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    component_block.body.unshift(
      const_builder("$$sanitized_props", call("$.sanitize_props", id("$$props")))
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id("$$props"))));
  }
  const body = [...state.hoisted, ...module.body];
  if (analysis.css.ast !== null && options.css === "injected" && !options.customElement) {
    const hash2 = literal2(analysis.css.hash);
    const code = literal2(render_stylesheet(analysis.source, analysis, options).code);
    body.push(const_builder("$$css", object([init("hash", hash2), init("code", code)])));
    component_block.body.unshift(stmt(call("$$renderer.global.css.add", id("$$css"))));
  }
  let should_inject_props = should_inject_context || props.length > 0 || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  const component_function = function_declaration(
    id(analysis.name),
    should_inject_props ? [id("$$renderer"), id("$$props")] : [id("$$renderer")],
    component_block
  );
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports2([["render", "$$_render"]], "svelte/server"));
    body.push(
      component_function,
      stmt(
        assignment(
          "=",
          member_id(`${analysis.name}.render`),
          function_builder(
            null,
            [id("$$props"), id("$$opts")],
            block([
              return_builder(
                call(
                  "$$_render",
                  id(analysis.name),
                  object([
                    init("props", id("$$props")),
                    init("context", member(id("$$opts"), "context", false, true))
                  ])
                )
              )
            ])
          )
        )
      ),
      export_default(id(analysis.name))
    );
  } else if (dev) {
    body.push(
      component_function,
      stmt(
        assignment(
          "=",
          member_id(`${analysis.name}.render`),
          function_builder(
            null,
            [],
            block([
              throw_error(
                `Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information`
              )
            ])
          )
        )
      ),
      export_default(id(analysis.name))
    );
  } else {
    body.push(export_default(component_function));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id(analysis.name), "$.FILENAME", true), literal2(filename))
      )
    );
  }
  if (options.experimental.async) {
    body.unshift(imports2([], "svelte/internal/flags/async"));
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/utils.js
var Memoizer = class {
  /** @type {Array<{ id: Identifier, expression: Expression }>} */
  #sync = [];
  /** @type {Array<{ id: Identifier, expression: Expression }>} */
  #async = [];
  /** @type {Set<Expression>} */
  #blockers = /* @__PURE__ */ new Set();
  /**
   * @param {Expression} expression
   * @param {ExpressionMetadata} metadata
   * @param {boolean} memoize_if_state
   */
  add(expression, metadata, memoize_if_state = false) {
    this.check_blockers(metadata);
    const should_memoize = metadata.has_call || metadata.has_await || memoize_if_state && metadata.has_state;
    if (!should_memoize) {
      return expression;
    }
    const id2 = id("#");
    (metadata.has_await ? this.#async : this.#sync).push({ id: id2, expression });
    return id2;
  }
  /**
   * @param {ExpressionMetadata} metadata
   */
  check_blockers(metadata) {
    for (const binding of metadata.dependencies) {
      if (binding.blocker) {
        this.#blockers.add(binding.blocker);
      }
    }
  }
  apply() {
    return [...this.#sync, ...this.#async].map((memo, i) => {
      memo.id.name = `$${i}`;
      return memo.id;
    });
  }
  blockers() {
    return this.#blockers.size > 0 ? array([...this.#blockers]) : void 0;
  }
  deriveds(runes2 = true) {
    return this.#sync.map(
      (memo) => let_builder(memo.id, call(runes2 ? "$.derived" : "$.derived_safe_equal", thunk(memo.expression)))
    );
  }
  async_ids() {
    return this.#async.map((memo) => memo.id);
  }
  async_values() {
    if (this.#async.length === 0) return;
    return array(this.#async.map((memo) => thunk(memo.expression, true)));
  }
  sync_values() {
    if (this.#sync.length === 0) return;
    return array(this.#sync.map((memo) => thunk(memo.expression)));
  }
};
function build_template_chunk(values, context, state = context.state, memoize = (value, metadata) => state.memoizer.add(value, metadata)) {
  const expressions = [];
  let quasi2 = quasi("");
  const quasis = [quasi2];
  let has_state = false;
  let has_await = false;
  for (let i = 0; i < values.length; i++) {
    const node = values[i];
    if (node.type === "Text") {
      quasi2.value.cooked += node.data;
    } else if (node.expression.type === "Literal") {
      if (node.expression.value != null) {
        quasi2.value.cooked += node.expression.value + "";
      }
    } else if (node.expression.type !== "Identifier" || node.expression.name !== "undefined" || state.scope.get("undefined")) {
      let value2 = memoize(
        build_expression(context, node.expression, node.metadata.expression, state),
        node.metadata.expression
      );
      const evaluated = state.scope.evaluate(value2);
      has_await ||= node.metadata.expression.has_await;
      has_state ||= has_await || node.metadata.expression.has_state && !evaluated.is_known;
      if (values.length === 1) {
        if (evaluated.is_known) {
          value2 = literal2((evaluated.value ?? "") + "");
        }
        return { value: value2, has_state };
      }
      if (value2.type === "LogicalExpression" && value2.right.type === "Literal" && (value2.operator === "??" || value2.operator === "||")) {
        if (value2.right.value === null) {
          value2 = { ...value2, right: literal2("") };
        }
      }
      if (evaluated.is_known) {
        quasi2.value.cooked += (evaluated.value ?? "") + "";
      } else {
        if (!evaluated.is_defined) {
          value2 = logical("??", value2, literal2(""));
        }
        expressions.push(value2);
        quasi2 = quasi("", i + 1 === values.length);
        quasis.push(quasi2);
      }
    }
  }
  for (const quasi3 of quasis) {
    quasi3.value.raw = sanitize_template_string(
      /** @type {string} */
      quasi3.value.cooked
    );
  }
  const value = expressions.length > 0 ? template(quasis, expressions) : literal2(
    /** @type {string} */
    quasi2.value.cooked
  );
  return { value, has_state };
}
function build_render_statement(state) {
  const { memoizer } = state;
  const ids = memoizer.apply();
  return stmt(
    call(
      "$.template_effect",
      arrow(
        ids,
        state.update.length === 1 && state.update[0].type === "ExpressionStatement" ? state.update[0].expression : block(state.update)
      ),
      memoizer.sync_values(),
      memoizer.async_values(),
      memoizer.blockers()
    )
  );
}
function parse_directive_name(name) {
  const parts = name.split(".");
  let part = (
    /** @type {string} */
    parts.shift()
  );
  let expression = id(part);
  while (part = /** @type {string} */
  parts.shift()) {
    const computed = !regex_is_valid_identifier.test(part);
    expression = member(expression, computed ? literal2(part) : id(part), computed);
  }
  return expression;
}
function build_bind_this(expression, value, { state, visit }) {
  const [getter, setter] = expression.type === "SequenceExpression" ? expression.expressions : [null, null];
  const ids = [];
  const values = [];
  const seen2 = [];
  const transform = { ...state.transform };
  walk(getter ?? expression, null, {
    Identifier(node2, { path }) {
      if (seen2.includes(node2.name)) return;
      seen2.push(node2.name);
      const parent = (
        /** @type {Expression} */
        path.at(-1)
      );
      if (!is_reference(node2, parent)) return;
      const binding = state.scope.get(node2.name);
      if (!binding) return;
      for (const [owner, scope] of state.scopes) {
        if (owner.type === "EachBlock" && scope === binding.scope) {
          ids.push(node2);
          values.push(
            /** @type {Expression} */
            visit(node2)
          );
          if (transform[node2.name]) {
            transform[node2.name] = {
              ...transform[node2.name],
              read: (node3) => node3
            };
          }
          break;
        }
      }
    }
  });
  const child_state = { ...state, transform };
  let get3 = (
    /** @type {Expression} */
    visit(getter ?? expression, child_state)
  );
  let set2 = (
    /** @type {Expression} */
    visit(
      setter ?? assignment(
        "=",
        /** @type {Identifier | MemberExpression} */
        expression,
        id("$$value")
      ),
      child_state
    )
  );
  let node = get3;
  while (node.type === "MemberExpression") {
    node.optional = true;
    node = node.object;
  }
  get3 = get3.type === "ArrowFunctionExpression" ? arrow([...ids], get3.body) : get3.type === "FunctionExpression" ? function_builder(null, [...ids], get3.body) : getter ? get3 : arrow([...ids], get3);
  set2 = set2.type === "ArrowFunctionExpression" ? arrow([set2.params[0] ?? id("_"), ...ids], set2.body) : set2.type === "FunctionExpression" ? function_builder(null, [set2.params[0] ?? id("_"), ...ids], set2.body) : setter ? set2 : arrow([id("$$value"), ...ids], set2);
  return call("$.bind_this", value, set2, get3, values.length > 0 && thunk(array(values)));
}
function validate_binding(state, binding, expression) {
  if (binding.expression.type === "SequenceExpression") {
    return;
  }
  const left = object2(binding.expression);
  const left_binding = left && state.scope.get(left.name);
  if (left_binding?.kind === "store_sub") return;
  const loc = locator(binding.start);
  const obj = (
    /** @type {Expression} */
    expression.object
  );
  state.init.push(
    stmt(
      call(
        "$.validate_binding",
        literal2(state.analysis.source.slice(binding.start, binding.end)),
        binding.metadata.expression.blockers(),
        thunk(
          state.store_to_invalidate ? sequence([call("$.mark_store_binding"), obj]) : obj
        ),
        thunk(
          /** @type {Expression} */
          expression.computed ? expression.property : literal2(
            /** @type {Identifier} */
            expression.property.name
          )
        ),
        loc && literal2(loc.line),
        loc && literal2(loc.column)
      )
    )
  );
}
function validate_mutation(node, context, expression) {
  let left = (
    /** @type {Expression | Super} */
    node.type === "AssignmentExpression" ? node.left : node.argument
  );
  if (!dev || left.type !== "MemberExpression" || is_ignored(node, "ownership_invalid_mutation")) {
    return expression;
  }
  const name = object2(left);
  if (!name) return expression;
  const binding = context.state.scope.get(name.name);
  if (binding?.kind !== "prop" && binding?.kind !== "bindable_prop") return expression;
  const state = (
    /** @type {ComponentClientTransformState} */
    context.state
  );
  state.analysis.needs_mutation_validation = true;
  const path = [];
  while (left.type === "MemberExpression") {
    if (left.property.type === "Literal") {
      path.unshift(left.property);
    } else if (left.property.type === "Identifier") {
      const transform = Object.hasOwn(context.state.transform, left.property.name) ? context.state.transform[left.property.name] : null;
      if (left.computed) {
        path.unshift(transform?.read ? transform.read(left.property) : left.property);
      } else {
        path.unshift(literal2(left.property.name));
      }
    } else {
      return expression;
    }
    left = left.object;
  }
  path.unshift(literal2(name.name));
  const loc = locator(
    /** @type {number} */
    left.start
  );
  return call(
    "$$ownership_validator.mutation",
    literal2(binding.prop_alias),
    array(path),
    expression,
    loc && literal2(loc.line),
    loc && literal2(loc.column)
  );
}
function build_expression(context, expression, metadata, state = context.state) {
  const value = (
    /** @type {Expression} */
    context.visit(expression, state)
  );
  if (context.state.analysis.runes || context.state.analysis.maybe_runes) {
    return value;
  }
  if (!metadata.has_call && !metadata.has_member_expression && !metadata.has_assignment) {
    return value;
  }
  const sequence2 = sequence([]);
  for (const binding of metadata.references) {
    if (binding.kind === "normal" && binding.declaration_kind !== "import") {
      continue;
    }
    var getter = build_getter({ ...binding.node }, state);
    if (binding.kind === "bindable_prop" || binding.kind === "template" || binding.declaration_kind === "import" || binding.node.name === "$$props" || binding.node.name === "$$restProps") {
      getter = call("$.deep_read_state", getter);
    }
    sequence2.expressions.push(getter);
  }
  sequence2.expressions.push(call("$.untrack", thunk(value)));
  return sequence2;
}
function add_svelte_meta(expression, node, type, additional) {
  if (!dev) {
    return stmt(expression);
  }
  const location2 = node.start !== void 0 && locator(node.start);
  if (!location2) {
    return stmt(expression);
  }
  return stmt(
    call(
      "$.add_svelte_meta",
      arrow([], expression),
      literal2(type),
      id(component_name),
      literal2(location2.line),
      literal2(location2.column),
      additional && object(Object.entries(additional).map(([k, v]) => init(k, literal2(v))))
    )
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AnimateDirective.js
function AnimateDirective2(node, context) {
  const expression = node.expression === null ? null_instance : thunk(
    /** @type {Expression} */
    context.visit(node.expression)
  );
  let statement = stmt(
    call(
      "$.animation",
      context.state.node,
      thunk(
        /** @type {Expression} */
        context.visit(parse_directive_name(node.name))
      ),
      expression
    )
  );
  if (node.metadata.expression.is_async()) {
    statement = stmt(
      call(
        "$.run_after_blockers",
        node.metadata.expression.blockers(),
        thunk(block([statement]))
      )
    );
  }
  context.state.after_update.push(statement);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/function.js
var visit_function2 = (node, context) => {
  let state = { ...context.state, in_constructor: false, in_derived: false };
  if (node.type === "FunctionExpression") {
    const parent = (
      /** @type {Node} */
      context.path.at(-1)
    );
    state.in_constructor = parent.type === "MethodDefinition" && parent.kind === "constructor";
  }
  context.next(state);
};

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ArrowFunctionExpression.js
function ArrowFunctionExpression2(node, context) {
  return visit_function2(node, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AssignmentExpression.js
function AssignmentExpression3(node, context) {
  const expression = (
    /** @type {Expression} */
    visit_assignment_expression(node, context, build_assignment2) ?? context.next()
  );
  return validate_mutation(node, context, expression);
}
function is_non_coercive_operator(operator) {
  return ["=", "||=", "&&=", "??="].includes(operator);
}
var callees = {
  "=": "$.assign",
  "&&=": "$.assign_and",
  "||=": "$.assign_or",
  "??=": "$.assign_nullish"
};
function build_assignment2(operator, left, right, context) {
  if (context.state.analysis.runes && left.type === "MemberExpression") {
    const name = get_name(left.property);
    const field = name && context.state.state_fields.get(name);
    if (field) {
      if (field.node.type === "AssignmentExpression" && left === field.node.left) {
        const rune = get_rune(right, context.state.scope);
        if (rune) {
          const child_state = {
            ...context.state,
            in_constructor: rune !== "$derived" && rune !== "$derived.by"
          };
          let value = (
            /** @type {Expression} */
            context.visit(right, child_state)
          );
          if (dev) {
            const declaration2 = context.path.findLast(
              (parent) => parent.type === "ClassDeclaration" || parent.type === "ClassExpression"
            );
            value = call(
              "$.tag",
              value,
              literal2(`${declaration2?.id?.name ?? "[class]"}.${name}`)
            );
          }
          return assignment(operator, member(this_instance, field.key), value);
        }
      }
      if (left.property.type === "PrivateIdentifier") {
        let value = (
          /** @type {Expression} */
          context.visit(build_assignment_value(operator, left, right))
        );
        const needs_proxy = field.type === "$state" && is_non_coercive_operator(operator) && should_proxy(value, context.state.scope);
        return call("$.set", left, value, needs_proxy && true_instance);
      }
    }
  }
  let object4 = left;
  while (object4.type === "MemberExpression") {
    object4 = object4.object;
  }
  if (object4.type !== "Identifier") {
    return null;
  }
  const binding = context.state.scope.get(object4.name);
  if (!binding) return null;
  const transform = Object.hasOwn(context.state.transform, object4.name) ? context.state.transform[object4.name] : null;
  const path = context.path.map((node) => node.type);
  if (object4 === left && transform?.assign) {
    const is_primitive = path.at(-1) === "BindDirective" && path.at(-2) === "RegularElement";
    let value = (
      /** @type {Expression} */
      context.visit(build_assignment_value(operator, left, right))
    );
    return transform.assign(
      object4,
      value,
      !is_primitive && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "raw_state" && binding.kind !== "derived" && binding.kind !== "store_sub" && context.state.analysis.runes && should_proxy(right, context.state.scope) && is_non_coercive_operator(operator)
    );
  }
  if (transform?.mutate) {
    return transform.mutate(
      object4,
      assignment(
        operator,
        /** @type {Pattern} */
        context.visit(left),
        /** @type {Expression} */
        context.visit(right)
      )
    );
  }
  let should_transform = dev && path.at(-1) !== "ExpressionStatement" && is_non_coercive_operator(operator);
  if (path.at(-1) === "ArrowFunctionExpression" && (path.at(-2) === "RegularElement" || path.at(-2) === "SvelteElement")) {
    const element2 = (
      /** @type {AST.RegularElement} */
      context.path.at(-2)
    );
    const attribute = element2.attributes.find((attribute2) => {
      if (attribute2.type !== "Attribute" || !is_event_attribute(attribute2)) {
        return false;
      }
      const expression = get_attribute_expression(attribute2);
      return expression === context.path.at(-1);
    });
    if (attribute) {
      should_transform = false;
    }
  }
  if (path.at(-1) === "BindDirective" || path.at(-1) === "Component" || path.at(-1) === "SvelteComponent" || path.at(-1) === "ArrowFunctionExpression" && (path.at(-2) === "BindDirective" || path.at(-2) === "Component" && path.at(-3) === "Fragment" || path.at(-2) === "SequenceExpression" && (path.at(-3) === "Component" || path.at(-3) === "SvelteComponent" || path.at(-3) === "BindDirective"))) {
    should_transform = false;
  }
  if (left.type === "MemberExpression" && should_transform) {
    const callee = callees[operator];
    return (
      /** @type {Expression} */
      context.visit(
        call(
          callee,
          /** @type {Expression} */
          left.object,
          /** @type {Expression} */
          left.computed ? left.property : literal2(
            /** @type {Identifier} */
            left.property.name
          ),
          right,
          literal2(locate_node(left))
        )
      )
    );
  }
  return null;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/events.js
function visit_event_attribute(node, context) {
  let capture = false;
  let event_name = node.name.slice(2);
  if (is_capture_event(event_name)) {
    event_name = event_name.slice(0, -7);
    capture = true;
  }
  const tag2 = Array.isArray(node.value) ? (
    /** @type {AST.ExpressionTag} */
    node.value[0]
  ) : (
    /** @type {AST.ExpressionTag} */
    node.value
  );
  let handler = build_event_handler(tag2.expression, tag2.metadata.expression, context);
  if (node.metadata.delegated) {
    if (!context.state.events.has(event_name)) {
      context.state.events.add(event_name);
    }
    context.state.init.push(
      stmt(assignment("=", member(context.state.node, "__" + event_name), handler))
    );
  } else {
    const statement = stmt(
      build_event(
        event_name,
        context.state.node,
        handler,
        capture,
        is_passive_event(event_name) ? true : void 0
      )
    );
    const type = (
      /** @type {AST.SvelteNode} */
      context.path.at(-1).type
    );
    if (type === "SvelteDocument" || type === "SvelteWindow" || type === "SvelteBody") {
      context.state.init.push(statement);
    } else {
      context.state.after_update.push(statement);
    }
  }
}
function build_event(event_name, node, handler, capture, passive) {
  return call(
    "$.event",
    literal2(event_name),
    node,
    handler,
    capture && true_instance,
    passive === void 0 ? void 0 : literal2(passive)
  );
}
function build_event_handler(node, metadata, context) {
  if (node === null) {
    return function_builder(
      null,
      [id("$$arg")],
      block([stmt(call("$.bubble_event.call", this_instance, id("$$props"), id("$$arg")))])
    );
  }
  let handler = (
    /** @type {Expression} */
    context.visit(node)
  );
  if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
    return handler;
  }
  if (handler.type === "Identifier") {
    const binding = context.state.scope.get(handler.name);
    if (binding?.is_function()) {
      return handler;
    }
    if (!dev && binding?.declaration_kind !== "import") {
      return handler;
    }
  }
  if (metadata.has_call) {
    const id2 = id(context.state.scope.generate("event_handler"));
    context.state.init.push(var_builder(id2, call("$.derived", thunk(handler))));
    handler = call("$.get", id2);
  }
  let call2 = call(member(handler, "apply", false, true), this_instance, id("$$args"));
  if (dev) {
    const loc = locator(
      /** @type {number} */
      node.start
    );
    const remove_parens = node.type === "CallExpression" && node.arguments.length === 0 && node.callee.type === "Identifier";
    call2 = call(
      "$.apply",
      thunk(handler),
      this_instance,
      id("$$args"),
      id(context.state.analysis.name),
      loc && array([literal2(loc.line), literal2(loc.column)]),
      has_side_effects(node) && true_instance,
      remove_parens && true_instance
    );
  }
  return function_builder(null, [rest(id("$$args"))], block([stmt(call2)]));
}
function has_side_effects(node) {
  if (node.type === "CallExpression" || node.type === "NewExpression" || node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
    return true;
  }
  if (node.type === "SequenceExpression") {
    return node.expressions.some(has_side_effects);
  }
  return false;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Attribute.js
function Attribute2(node, context) {
  if (is_event_attribute(node)) {
    visit_event_attribute(node, context);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AwaitBlock.js
function AwaitBlock3(node, context) {
  context.state.template.push_comment();
  const expression = thunk(
    build_expression(context, node.expression, node.metadata.expression),
    node.metadata.expression.has_await
  );
  let then_block;
  let catch_block;
  if (node.then) {
    const then_context = {
      ...context,
      state: { ...context.state, transform: { ...context.state.transform } }
    };
    const argument = node.value && create_derived_block_argument(node.value, then_context);
    const args = [id("$$anchor")];
    if (argument) args.push(argument.id);
    const declarations = argument?.declarations ?? [];
    const block2 = (
      /** @type {BlockStatement} */
      then_context.visit(node.then, then_context.state)
    );
    then_block = arrow(args, block([...declarations, ...block2.body]));
  }
  if (node.catch) {
    const catch_context = { ...context, state: { ...context.state } };
    const argument = node.error && create_derived_block_argument(node.error, catch_context);
    const args = [id("$$anchor")];
    if (argument) args.push(argument.id);
    const declarations = argument?.declarations ?? [];
    const block2 = (
      /** @type {BlockStatement} */
      catch_context.visit(node.catch, catch_context.state)
    );
    catch_block = arrow(args, block([...declarations, ...block2.body]));
  }
  const stmt2 = add_svelte_meta(
    call(
      "$.await",
      context.state.node,
      expression,
      node.pending ? arrow(
        [id("$$anchor")],
        /** @type {BlockStatement} */
        context.visit(node.pending)
      ) : null_instance,
      then_block,
      catch_block
    ),
    node,
    "await"
  );
  if (node.metadata.expression.has_blockers()) {
    context.state.init.push(
      stmt(
        call(
          "$.async",
          context.state.node,
          node.metadata.expression.blockers(),
          array([]),
          arrow([context.state.node], block([stmt2]))
        )
      )
    );
  } else {
    context.state.init.push(stmt2);
  }
}
function create_derived_block_argument(node, context) {
  if (node.type === "Identifier") {
    context.state.transform[node.name] = { read: get_value };
    return { id: node, declarations: null };
  }
  const pattern = (
    /** @type {Pattern} */
    context.visit(node)
  );
  const identifiers = extract_identifiers(node);
  const id2 = id("$$source");
  const value = id("$$value");
  const block2 = block([
    var_builder(pattern, call("$.get", id2)),
    return_builder(object(identifiers.map((identifier) => prop("init", identifier, identifier))))
  ]);
  const declarations = [var_builder(value, create_derived(context.state, block2))];
  for (const id3 of identifiers) {
    context.state.transform[id3.name] = { read: get_value };
    declarations.push(
      var_builder(id3, create_derived(context.state, member(call("$.get", value), id3)))
    );
  }
  return { id: id2, declarations };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AwaitExpression.js
function AwaitExpression3(node, context) {
  const argument = (
    /** @type {Expression} */
    context.visit(node.argument)
  );
  if (context.state.analysis.pickled_awaits.has(node)) {
    return save(argument);
  } else if (dev && !is_ignored(node, "await_reactivity_loss")) {
    return call(await_builder(call("$.track_reactivity_loss", argument)));
  }
  return argument === node.argument ? node : { ...node, argument };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BinaryExpression.js
function BinaryExpression(node, context) {
  if (dev) {
    const operator = node.operator;
    if (operator === "===" || operator === "!==") {
      return call(
        "$.strict_equals",
        /** @type {Expression} */
        context.visit(node.left),
        /** @type {Expression} */
        context.visit(node.right),
        operator === "!==" && false_instance
      );
    }
    if (operator === "==" || operator === "!=") {
      return call(
        "$.equals",
        /** @type {Expression} */
        context.visit(node.left),
        /** @type {Expression} */
        context.visit(node.right),
        operator === "!=" && false_instance
      );
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/fragment.js
function process_children2(nodes, initial, is_element, context) {
  const within_bound_contenteditable = context.state.metadata.bound_contenteditable;
  let prev = initial;
  let skipped = 0;
  let sequence2 = [];
  function get_node(is_text) {
    if (skipped === 0) {
      return prev(is_text);
    }
    return call(
      "$.sibling",
      prev(false),
      (is_text || skipped !== 1) && literal2(skipped),
      is_text && true_instance
    );
  }
  function flush_node(is_text, name) {
    const expression = get_node(is_text);
    let id2 = expression;
    if (id2.type !== "Identifier") {
      id2 = id(context.state.scope.generate(name));
      context.state.init.push(var_builder(id2, expression));
    }
    prev = () => id2;
    skipped = 1;
    return id2;
  }
  function flush_sequence(sequence3) {
    if (sequence3.every((node) => node.type === "Text")) {
      skipped += 1;
      context.state.template.push_text(sequence3);
      return;
    }
    context.state.template.push_text([{ type: "Text", data: " ", raw: " ", start: -1, end: -1 }]);
    const { has_state, value } = build_template_chunk(sequence3, context);
    const is_text = sequence3.length === 1;
    const id2 = flush_node(is_text, "text");
    const update2 = stmt(call("$.set_text", id2, value));
    if (has_state && !within_bound_contenteditable) {
      context.state.update.push(update2);
    } else {
      context.state.init.push(stmt(assignment("=", member(id2, "nodeValue"), value)));
    }
  }
  for (const node of nodes) {
    if (node.type === "Text" || node.type === "ExpressionTag") {
      sequence2.push(node);
    } else {
      if (sequence2.length > 0) {
        flush_sequence(sequence2);
        sequence2 = [];
      }
      let child_state = context.state;
      if (is_static_element2(node, context.state)) {
        skipped += 1;
      } else if (node.type === "EachBlock" && nodes.length === 1 && is_element && // In case it's wrapped in async the async logic will want to skip sibling nodes up until the end, hence we cannot make this controlled
      // TODO switch this around and instead optimize for elements with a single block child and not require extra comments (neither for async nor normally)
      !node.metadata.expression.is_async()) {
        node.metadata.is_controlled = true;
      } else {
        const id2 = flush_node(false, node.type === "RegularElement" ? node.name : "node");
        child_state = { ...context.state, node: id2 };
      }
      context.visit(node, child_state);
    }
  }
  if (sequence2.length > 0) {
    flush_sequence(sequence2);
  }
  if (skipped > 1) {
    skipped -= 1;
    context.state.init.push(stmt(call("$.next", skipped !== 1 && literal2(skipped))));
  }
}
function is_static_element2(node, state) {
  if (node.type !== "RegularElement") return false;
  if (node.fragment.metadata.dynamic) return false;
  if (is_custom_element_node(node)) return false;
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      return false;
    }
    if (is_event_attribute(attribute)) {
      return false;
    }
    if (cannot_be_set_statically(attribute.name)) {
      return false;
    }
    if (attribute.name === "dir") {
      return false;
    }
    if (["input", "textarea"].includes(node.name) && ["value", "checked"].includes(attribute.name)) {
      return false;
    }
    if (node.name === "option" && attribute.name === "value") {
      return false;
    }
    if (node.name === "img" && attribute.name === "loading") {
      return false;
    }
    if (attribute.value !== true && !is_text_attribute(attribute)) {
      return false;
    }
  }
  return true;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/RegularElement.js
function RegularElement3(node, context) {
  context.state.template.push_element(node.name, node.start);
  if (node.name === "noscript") {
    context.state.template.pop_element();
    return;
  }
  const is_custom_element = is_custom_element_node(node);
  context.state.template.needs_import_node ||= node.name === "video" || is_custom_element;
  context.state.template.contains_script_tag ||= node.name === "script";
  const attributes = [];
  const class_directives = [];
  const style_directives = [];
  const other_directives = [];
  const lets = [];
  const lookup = /* @__PURE__ */ new Map();
  const bindings = /* @__PURE__ */ new Map();
  let has_spread = node.metadata.has_spread;
  let has_use = false;
  let should_remove_defaults = false;
  for (const attribute of node.attributes) {
    switch (attribute.type) {
      case "AnimateDirective":
        other_directives.push(attribute);
        break;
      case "Attribute":
        if (attribute.name === "is" && context.state.metadata.namespace === "html") {
          const { value } = build_attribute_value2(attribute.value, context);
          if (value.type === "Literal" && typeof value.value === "string") {
            context.state.template.set_prop("is", value.value);
            continue;
          }
        }
        attributes.push(attribute);
        lookup.set(attribute.name, attribute);
        break;
      case "BindDirective":
        bindings.set(attribute.name, attribute);
        other_directives.push(attribute);
        break;
      case "ClassDirective":
        class_directives.push(attribute);
        break;
      case "LetDirective":
        context.visit(attribute, { ...context.state, let_directives: lets });
        break;
      case "OnDirective":
        other_directives.push(attribute);
        break;
      case "SpreadAttribute":
        attributes.push(attribute);
        break;
      case "StyleDirective":
        style_directives.push(attribute);
        break;
      case "TransitionDirective":
        other_directives.push(attribute);
        break;
      case "UseDirective":
        has_use = true;
        other_directives.push(attribute);
        break;
      case "AttachTag":
        other_directives.push(attribute);
        break;
    }
  }
  const element_state = { ...context.state, init: [], after_update: [] };
  for (const attribute of other_directives) {
    if (attribute.type === "OnDirective") {
      const handler = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (has_use) {
        element_state.init.push(stmt(call("$.effect", thunk(handler))));
      } else {
        element_state.after_update.push(stmt(handler));
      }
    } else {
      context.visit(attribute, element_state);
    }
  }
  if (node.name === "input") {
    const has_value_attribute = attributes.some(
      (attribute) => attribute.type === "Attribute" && (attribute.name === "value" || attribute.name === "checked") && !is_text_attribute(attribute)
    );
    const has_default_value_attribute = attributes.some(
      (attribute) => attribute.type === "Attribute" && (attribute.name === "defaultValue" || attribute.name === "defaultChecked")
    );
    if (!has_default_value_attribute && (has_spread || bindings.has("value") || bindings.has("checked") || bindings.has("group") || !bindings.has("group") && has_value_attribute)) {
      if (has_spread) {
        should_remove_defaults = true;
      } else {
        context.state.init.push(stmt(call("$.remove_input_defaults", context.state.node)));
      }
    }
  }
  if (node.name === "textarea") {
    const attribute = lookup.get("value") ?? lookup.get("checked");
    const needs_content_reset = attribute && !is_text_attribute(attribute);
    if (has_spread || bindings.has("value") || needs_content_reset) {
      context.state.init.push(stmt(call("$.remove_textarea_child", context.state.node)));
    }
  }
  if (node.name === "select" && bindings.has("value")) {
    setup_select_synchronization(
      /** @type {AST.BindDirective} */
      bindings.get("value"),
      context
    );
  }
  context.state.init.push(...lets);
  const node_id = context.state.node;
  const needs_special_value_handling = node.name === "option" || node.name === "select" || bindings.has("group") || bindings.has("checked");
  if (has_spread) {
    build_attribute_effect(
      attributes,
      class_directives,
      style_directives,
      context,
      node,
      node_id,
      should_remove_defaults
    );
  } else {
    for (
      const attribute of
      /** @type {AST.Attribute[]} */
      attributes
    ) {
      if (is_event_attribute(attribute)) {
        visit_event_attribute(attribute, context);
        continue;
      }
      if (needs_special_value_handling && attribute.name === "value") {
        continue;
      }
      const name = get_attribute_name2(node, attribute);
      if (!is_custom_element && !cannot_be_set_statically(attribute.name) && (attribute.value === true || is_text_attribute(attribute)) && (name !== "class" || class_directives.length === 0) && (name !== "style" || style_directives.length === 0)) {
        let value = is_text_attribute(attribute) ? attribute.value[0].data : true;
        if (name === "class" && node.metadata.scoped && context.state.analysis.css.hash) {
          if (value === true || value === "") {
            value = context.state.analysis.css.hash;
          } else {
            value += " " + context.state.analysis.css.hash;
          }
        }
        if (name !== "class" || value) {
          context.state.template.set_prop(
            attribute.name,
            is_boolean_attribute(name) && value === true ? void 0 : value === true ? "" : value
          );
        }
      } else if (name === "autofocus") {
        let { value } = build_attribute_value2(attribute.value, context);
        context.state.init.push(stmt(call("$.autofocus", node_id, value)));
      } else if (name === "class") {
        const is_html = context.state.metadata.namespace === "html" && node.name !== "svg";
        build_set_class(node, node_id, attribute, class_directives, context, is_html);
      } else if (name === "style") {
        build_set_style(node_id, attribute, style_directives, context);
      } else if (is_custom_element) {
        build_custom_element_attribute_update_assignment(node_id, attribute, context);
      } else {
        const { value, has_state } = build_attribute_value2(
          attribute.value,
          context,
          (value2, metadata2) => context.state.memoizer.add(value2, metadata2)
        );
        const update2 = build_element_attribute_update(node, node_id, name, value, attributes);
        (has_state ? context.state.update : context.state.init).push(stmt(update2));
      }
    }
  }
  if (is_load_error_element(node.name) && (has_spread || has_use || lookup.has("onload") || lookup.has("onerror"))) {
    context.state.after_update.push(stmt(call("$.replay_events", node_id)));
  }
  const metadata = {
    ...context.state.metadata,
    namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
  };
  if (bindings.has("innerHTML") || bindings.has("innerText") || bindings.has("textContent")) {
    const contenteditable = lookup.get("contenteditable");
    if (contenteditable && (contenteditable.value === true || is_text_attribute(contenteditable) && contenteditable.value[0].data === "true")) {
      metadata.bound_contenteditable = true;
    }
  }
  const state = {
    ...context.state,
    metadata,
    scope: (
      /** @type {Scope} */
      context.state.scopes.get(node.fragment)
    ),
    preserve_whitespace: context.state.preserve_whitespace || node.name === "pre" || node.name === "textarea"
  };
  const { hoisted, trimmed } = clean_nodes(
    node,
    node.fragment.nodes,
    context.path,
    state.metadata.namespace,
    state,
    node.name === "script" || state.preserve_whitespace,
    state.options.preserveComments
  );
  const child_state = { ...state, init: [], update: [], after_update: [] };
  for (const node2 of hoisted) {
    context.visit(node2, child_state);
  }
  const use_text_content = trimmed.every((node2) => node2.type === "Text" || node2.type === "ExpressionTag") && trimmed.every(
    (node2) => node2.type === "Text" || !node2.metadata.expression.has_state && !node2.metadata.expression.has_await
  ) && trimmed.some((node2) => node2.type === "ExpressionTag");
  if (use_text_content) {
    const { value } = build_template_chunk(trimmed, context, child_state);
    const empty_string = value.type === "Literal" && value.value === "";
    if (!empty_string) {
      child_state.init.push(
        stmt(assignment("=", member(context.state.node, "textContent"), value))
      );
    }
  } else {
    let arg = context.state.node;
    let needs_reset = trimmed.some((node2) => node2.type !== "Text");
    if (node.name === "template") {
      needs_reset = true;
      child_state.init.push(stmt(call("$.hydrate_template", arg)));
      arg = member(arg, "content");
    }
    process_children2(trimmed, (is_text) => call("$.child", arg, is_text && true_instance), true, {
      ...context,
      state: child_state
    });
    if (needs_reset) {
      child_state.init.push(stmt(call("$.reset", context.state.node)));
    }
  }
  if (node.fragment.nodes.some((node2) => node2.type === "SnippetBlock")) {
    context.state.init.push(
      block([
        ...child_state.init,
        ...element_state.init,
        child_state.update.length > 0 ? build_render_statement(child_state) : empty2,
        ...child_state.after_update,
        ...element_state.after_update
      ])
    );
  } else if (node.fragment.metadata.dynamic) {
    context.state.init.push(...child_state.init, ...element_state.init);
    context.state.update.push(...child_state.update);
    context.state.after_update.push(...child_state.after_update, ...element_state.after_update);
  } else {
    context.state.init.push(...element_state.init);
    context.state.after_update.push(...element_state.after_update);
  }
  if (lookup.has("dir")) {
    const dir = member(node_id, "dir");
    context.state.update.push(stmt(assignment("=", dir, dir)));
  }
  if (!has_spread && needs_special_value_handling) {
    if (node.metadata.synthetic_value_node) {
      const synthetic_node = node.metadata.synthetic_value_node;
      const synthetic_attribute = create_attribute(
        "value",
        synthetic_node.start,
        synthetic_node.end,
        [synthetic_node]
      );
      build_element_special_value_attribute(node.name, node_id, synthetic_attribute, context, true);
    } else {
      for (
        const attribute of
        /** @type {AST.Attribute[]} */
        attributes
      ) {
        if (attribute.name === "value") {
          build_element_special_value_attribute(node.name, node_id, attribute, context);
          break;
        }
      }
    }
  }
  context.state.template.pop_element();
}
function setup_select_synchronization(value_binding, context) {
  if (context.state.analysis.runes) return;
  let bound = value_binding.expression;
  if (bound.type === "SequenceExpression") {
    return;
  }
  while (bound.type === "MemberExpression") {
    bound = /** @type {Identifier | MemberExpression} */
    bound.object;
  }
  const names = [];
  for (const [name, refs] of context.state.scope.references) {
    if (refs.length > 0 && // prevent infinite loop
    name !== bound.name) {
      names.push(name);
    }
  }
  const invalidator = call(
    "$.invalidate_inner_signals",
    thunk(
      block(
        names.map((name) => {
          const serialized = build_getter(id(name), context.state);
          return stmt(serialized);
        })
      )
    )
  );
  context.state.init.push(
    stmt(
      call(
        "$.template_effect",
        thunk(
          block([stmt(
            /** @type {Expression} */
            context.visit(bound)
          ), stmt(invalidator)])
        )
      )
    )
  );
}
function build_class_directives_object(class_directives, context, memoizer = context.state.memoizer) {
  let properties = [];
  const metadata = new ExpressionMetadata();
  for (const d of class_directives) {
    metadata.merge(d.metadata.expression);
    const expression = (
      /** @type Expression */
      context.visit(d.expression)
    );
    properties.push(init(d.name, expression));
  }
  const directives = object(properties);
  return memoizer.add(directives, metadata);
}
function build_style_directives_object(style_directives, context, memoizer = context.state.memoizer) {
  const normal = object([]);
  const important = object([]);
  const metadata = new ExpressionMetadata();
  for (const d of style_directives) {
    metadata.merge(d.metadata.expression);
    const expression = d.value === true ? build_getter(id(d.name), context.state) : build_attribute_value2(d.value, context).value;
    const object4 = d.modifiers.includes("important") ? important : normal;
    object4.properties.push(init(d.name, expression));
  }
  const directives = important.properties.length ? array([normal, important]) : normal;
  return memoizer.add(directives, metadata);
}
function build_element_attribute_update(element2, node_id, name, value, attributes) {
  if (name === "muted") {
    return assignment("=", member(node_id, id("muted")), value);
  }
  if (name === "value") {
    return call("$.set_value", node_id, value);
  }
  if (name === "checked") {
    return call("$.set_checked", node_id, value);
  }
  if (name === "selected") {
    return call("$.set_selected", node_id, value);
  }
  if (
    // If we would just set the defaultValue property, it would override the value property,
    // because it is set in the template which implicitly means it's also setting the default value,
    // and if one updates the default value while the input is pristine it will also update the
    // current value, which is not what we want, which is why we need to do some extra work.
    name === "defaultValue" && (attributes.some(
      (attr) => attr.type === "Attribute" && attr.name === "value" && is_text_attribute(attr)
    ) || element2.name === "textarea" && element2.fragment.nodes.length > 0)
  ) {
    return call("$.set_default_value", node_id, value);
  }
  if (
    // See defaultValue comment
    name === "defaultChecked" && attributes.some(
      (attr) => attr.type === "Attribute" && attr.name === "checked" && attr.value === true
    )
  ) {
    return call("$.set_default_checked", node_id, value);
  }
  if (is_dom_property(name)) {
    return assignment("=", member(node_id, name), value);
  }
  return call(
    name.startsWith("xlink") ? "$.set_xlink_attribute" : "$.set_attribute",
    node_id,
    literal2(name),
    value,
    is_ignored(element2, "hydration_attribute_changed") && true_instance
  );
}
function build_custom_element_attribute_update_assignment(node_id, attribute, context) {
  const { value, has_state } = build_attribute_value2(attribute.value, context);
  const call2 = call("$.set_custom_element_data", node_id, literal2(attribute.name), value);
  const update2 = has_state ? call("$.template_effect", thunk(call2)) : call2;
  context.state.init.push(stmt(update2));
}
function build_element_special_value_attribute(element2, node_id, attribute, context, synthetic = false) {
  const state = context.state;
  const is_select_with_value = (
    // attribute.metadata.dynamic would give false negatives because even if the value does not change,
    // the inner options could still change, so we need to always treat it as reactive
    element2 === "select" && attribute.value !== true && !is_text_attribute(attribute)
  );
  const { value, has_state } = build_attribute_value2(
    attribute.value,
    context,
    (value2, metadata) => state.memoizer.add(value2, metadata)
  );
  const evaluated = context.state.scope.evaluate(value);
  const assignment2 = assignment("=", member(node_id, "__value"), value);
  const set_value_assignment = assignment(
    "=",
    member(node_id, "value"),
    evaluated.is_defined ? assignment2 : logical("??", assignment2, literal2(""))
  );
  const update2 = stmt(
    is_select_with_value ? sequence([
      set_value_assignment,
      // This ensures a one-way street to the DOM in case it's <select {value}>
      // and not <select bind:value>. We need it in addition to $.init_select
      // because the select value is not reflected as an attribute, so the
      // mutation observer wouldn't notice.
      call("$.select_option", node_id, value)
    ]) : synthetic ? assignment2 : set_value_assignment
  );
  if (has_state) {
    const id2 = id(state.scope.generate(`${node_id.name}_value`));
    const init3 = element2 === "option" ? object([]) : void 0;
    state.init.push(var_builder(id2, init3));
    state.update.push(if_builder(binary("!==", id2, assignment("=", id2, value)), block([update2])));
  } else {
    state.init.push(update2);
  }
  if (is_select_with_value) {
    state.init.push(stmt(call("$.init_select", node_id)));
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/element.js
function build_attribute_effect(attributes, class_directives, style_directives, context, element2, element_id, should_remove_defaults = false) {
  const values = [];
  const memoizer = new Memoizer();
  for (const attribute of attributes) {
    if (attribute.type === "Attribute") {
      const { value } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => memoizer.add(value2, metadata)
      );
      if (is_event_attribute(attribute) && (value.type === "ArrowFunctionExpression" || value.type === "FunctionExpression")) {
        const id2 = context.state.scope.generate("event_handler");
        context.state.init.push(var_builder(id2, value));
        values.push(init(attribute.name, id(id2)));
      } else {
        values.push(init(attribute.name, value));
      }
    } else {
      let value = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      value = memoizer.add(value, attribute.metadata.expression);
      values.push(spread(value));
    }
  }
  if (class_directives.length) {
    values.push(
      prop(
        "init",
        array([id("$.CLASS")]),
        build_class_directives_object(class_directives, context, memoizer)
      )
    );
  }
  if (style_directives.length) {
    values.push(
      prop(
        "init",
        array([id("$.STYLE")]),
        build_style_directives_object(style_directives, context, memoizer)
      )
    );
  }
  const ids = memoizer.apply();
  context.state.init.push(
    stmt(
      call(
        "$.attribute_effect",
        element_id,
        arrow(ids, object(values)),
        memoizer.sync_values(),
        memoizer.async_values(),
        memoizer.blockers(),
        element2.metadata.scoped && context.state.analysis.css.hash !== "" && literal2(context.state.analysis.css.hash),
        should_remove_defaults && true_instance,
        is_ignored(element2, "hydration_attribute_changed") && true_instance
      )
    )
  );
}
function build_attribute_value2(value, context, memoize = (value2) => value2) {
  if (value === true) {
    return { value: true_instance, has_state: false };
  }
  if (!Array.isArray(value) || value.length === 1) {
    const chunk = Array.isArray(value) ? value[0] : value;
    if (chunk.type === "Text") {
      return { value: literal2(chunk.data), has_state: false };
    }
    let expression = build_expression(context, chunk.expression, chunk.metadata.expression);
    return {
      value: memoize(expression, chunk.metadata.expression),
      has_state: chunk.metadata.expression.has_state || chunk.metadata.expression.is_async()
    };
  }
  return build_template_chunk(value, context, context.state, memoize);
}
function get_attribute_name2(element2, attribute) {
  if (!element2.metadata.svg && !element2.metadata.mathml) {
    return normalize_attribute(attribute.name);
  }
  return attribute.name;
}
function build_set_class(element2, node_id, attribute, class_directives, context, is_html) {
  let { value, has_state } = build_attribute_value2(attribute.value, context, (value2, metadata) => {
    if (attribute.metadata.needs_clsx) {
      value2 = call("$.clsx", value2);
    }
    return context.state.memoizer.add(value2, metadata);
  });
  let previous_id;
  let prev;
  let next2;
  if (class_directives.length) {
    next2 = build_class_directives_object(class_directives, context);
    has_state ||= class_directives.some(
      (d) => d.metadata.expression.has_state || d.metadata.expression.is_async()
    );
    if (has_state) {
      previous_id = id(context.state.scope.generate("classes"));
      context.state.init.push(declaration("let", [declarator(previous_id)]));
      prev = previous_id;
    } else {
      prev = object([]);
    }
  }
  let css_hash;
  if (element2.metadata.scoped && context.state.analysis.css.hash) {
    if (value.type === "Literal" && (value.value === "" || value.value === null)) {
      value = literal2(context.state.analysis.css.hash);
    } else if (value.type === "Literal" && typeof value.value === "string") {
      value = literal2(escape_html(value.value, true) + " " + context.state.analysis.css.hash);
    } else {
      css_hash = literal2(context.state.analysis.css.hash);
    }
  }
  if (!css_hash && next2) {
    css_hash = null_instance;
  }
  let set_class = call(
    "$.set_class",
    node_id,
    is_html ? literal2(1) : literal2(0),
    value,
    css_hash,
    prev,
    next2
  );
  if (previous_id) {
    set_class = assignment("=", previous_id, set_class);
  }
  (has_state ? context.state.update : context.state.init).push(stmt(set_class));
}
function build_set_style(node_id, attribute, style_directives, context) {
  let { value, has_state } = build_attribute_value2(
    attribute.value,
    context,
    (value2, metadata) => context.state.memoizer.add(value2, metadata)
  );
  let previous_id;
  let prev;
  let next2;
  if (style_directives.length) {
    next2 = build_style_directives_object(style_directives, context);
    has_state ||= style_directives.some(
      (d) => d.metadata.expression.has_state || d.metadata.expression.is_async()
    );
    if (has_state) {
      previous_id = id(context.state.scope.generate("styles"));
      context.state.init.push(declaration("let", [declarator(previous_id)]));
      prev = previous_id;
    } else {
      prev = object([]);
    }
  }
  let set_style = call("$.set_style", node_id, value, prev, next2);
  if (previous_id) {
    set_style = assignment("=", previous_id, set_style);
  }
  (has_state ? context.state.update : context.state.init).push(stmt(set_style));
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BindDirective.js
function BindDirective2(node, context) {
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const property = binding_properties[node.name];
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  let get3, set2;
  if (expression.type === "SequenceExpression") {
    [get3, set2] = expression.expressions;
  } else {
    if (dev && context.state.analysis.runes && expression.type === "MemberExpression" && (node.name !== "this" || context.path.some(
      ({ type }) => type === "IfBlock" || type === "EachBlock" || type === "AwaitBlock" || type === "KeyBlock"
    )) && !is_ignored(node, "binding_property_non_reactive")) {
      validate_binding(context.state, node, expression);
    }
    get3 = thunk(expression);
    set2 = unthunk(
      arrow(
        [id("$$value")],
        /** @type {Expression} */
        context.visit(
          assignment(
            "=",
            /** @type {Pattern} */
            node.expression,
            id("$$value")
          )
        )
      )
    );
    if (get3 === set2) {
      set2 = void 0;
    }
  }
  let call2;
  if (property?.event) {
    call2 = call(
      "$.bind_property",
      literal2(node.name),
      literal2(property.event),
      context.state.node,
      set2 ?? get3,
      property.bidirectional && get3
    );
  } else {
    switch (node.name) {
      // window
      case "online":
        call2 = call(`$.bind_online`, set2 ?? get3);
        break;
      case "scrollX":
      case "scrollY":
        call2 = call(
          "$.bind_window_scroll",
          literal2(node.name === "scrollX" ? "x" : "y"),
          get3,
          set2
        );
        break;
      case "innerWidth":
      case "innerHeight":
      case "outerWidth":
      case "outerHeight":
        call2 = call("$.bind_window_size", literal2(node.name), set2 ?? get3);
        break;
      // document
      case "activeElement":
        call2 = call("$.bind_active_element", set2 ?? get3);
        break;
      // media
      case "muted":
        call2 = call(`$.bind_muted`, context.state.node, get3, set2);
        break;
      case "paused":
        call2 = call(`$.bind_paused`, context.state.node, get3, set2);
        break;
      case "volume":
        call2 = call(`$.bind_volume`, context.state.node, get3, set2);
        break;
      case "playbackRate":
        call2 = call(`$.bind_playback_rate`, context.state.node, get3, set2);
        break;
      case "currentTime":
        call2 = call(`$.bind_current_time`, context.state.node, get3, set2);
        break;
      case "buffered":
        call2 = call(`$.bind_buffered`, context.state.node, set2 ?? get3);
        break;
      case "played":
        call2 = call(`$.bind_played`, context.state.node, set2 ?? get3);
        break;
      case "seekable":
        call2 = call(`$.bind_seekable`, context.state.node, set2 ?? get3);
        break;
      case "seeking":
        call2 = call(`$.bind_seeking`, context.state.node, set2 ?? get3);
        break;
      case "ended":
        call2 = call(`$.bind_ended`, context.state.node, set2 ?? get3);
        break;
      case "readyState":
        call2 = call(`$.bind_ready_state`, context.state.node, set2 ?? get3);
        break;
      // dimensions
      case "contentRect":
      case "contentBoxSize":
      case "borderBoxSize":
      case "devicePixelContentBoxSize":
        call2 = call(
          "$.bind_resize_observer",
          context.state.node,
          literal2(node.name),
          set2 ?? get3
        );
        break;
      case "clientWidth":
      case "clientHeight":
      case "offsetWidth":
      case "offsetHeight":
        call2 = call("$.bind_element_size", context.state.node, literal2(node.name), set2 ?? get3);
        break;
      // various
      case "value": {
        if (parent?.type === "RegularElement" && parent.name === "select") {
          call2 = call(`$.bind_select_value`, context.state.node, get3, set2);
        } else {
          call2 = call(`$.bind_value`, context.state.node, get3, set2);
        }
        break;
      }
      case "files":
        call2 = call(`$.bind_files`, context.state.node, get3, set2);
        break;
      case "this":
        call2 = build_bind_this(node.expression, context.state.node, context);
        break;
      case "textContent":
      case "innerHTML":
      case "innerText":
        call2 = call(
          "$.bind_content_editable",
          literal2(node.name),
          context.state.node,
          get3,
          set2
        );
        break;
      // checkbox/radio
      case "checked":
        call2 = call(`$.bind_checked`, context.state.node, get3, set2);
        break;
      case "focused":
        call2 = call(`$.bind_focused`, context.state.node, set2 ?? get3);
        break;
      case "group": {
        const indexes = node.metadata.parent_each_blocks.map((each) => {
          return each.metadata.keyed && each.index ? call("$.get", each.metadata.index) : each.metadata.index;
        });
        let group_getter = get3;
        if (parent?.type === "RegularElement") {
          const value = (
            /** @type {any[]} */
            /** @type {AST.Attribute} */
            parent.attributes.find(
              (a) => a.type === "Attribute" && a.name === "value" && !is_text_attribute(a) && a.value !== true
            )?.value
          );
          if (value !== void 0) {
            group_getter = thunk(
              block([stmt(build_attribute_value2(value, context).value), return_builder(expression)])
            );
          }
        }
        call2 = call(
          "$.bind_group",
          node.metadata.binding_group_name,
          array(indexes),
          context.state.node,
          group_getter,
          set2 ?? get3
        );
        break;
      }
      default:
        throw new Error("unknown binding " + node.name);
    }
  }
  const defer = node.name !== "this" && parent.type === "RegularElement" && parent.attributes.find((a) => a.type === "UseDirective");
  let statement = defer ? stmt(call("$.effect", thunk(call2))) : stmt(call2);
  if (node.metadata.expression.is_async()) {
    statement = stmt(
      call(
        "$.run_after_blockers",
        node.metadata.expression.blockers(),
        thunk(block([statement]))
      )
    );
  }
  if (node.name === "this") {
    context.state.init.push(statement);
  } else {
    if (defer) {
      context.state.init.push(statement);
    } else {
      context.state.after_update.push(statement);
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BlockStatement.js
function BlockStatement(node, context) {
  add_state_transformers(context);
  const tracing = context.state.scope.tracing;
  if (tracing !== null) {
    const parent = (
      /** @type {ArrowFunctionExpression | FunctionDeclaration | FunctionExpression} */
      context.path.at(-1)
    );
    const is_async = parent.async;
    const call2 = call(
      "$.trace",
      /** @type {Expression} */
      tracing,
      thunk(block(node.body.map((n2) => (
        /** @type {Statement} */
        context.visit(n2)
      ))), is_async)
    );
    return block([return_builder(is_async ? await_builder(call2) : call2)]);
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BreakStatement.js
function BreakStatement(node, context) {
  if (context.state.analysis.runes || !node.label || node.label.name !== "$") {
    return;
  }
  const in_reactive_statement = context.path[1].type === "LabeledStatement" && context.path[1].label.name === "$";
  if (in_reactive_statement) {
    return return_builder();
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/CallExpression.js
function CallExpression3(node, context) {
  const rune = get_rune(node, context.state.scope);
  switch (rune) {
    case "$host":
      return id("$$props.$$host");
    case "$effect.tracking":
      return call("$.effect_tracking");
    // transform state field assignments in constructors
    case "$state":
    case "$state.raw": {
      let arg = node.arguments[0];
      let value = void 0;
      if (arg) {
        value = /** @type {Expression} */
        context.visit(node.arguments[0]);
        if (rune === "$state" && should_proxy(
          /** @type {Expression} */
          arg,
          context.state.scope
        )) {
          value = call("$.proxy", value);
        }
      }
      return call("$.state", value);
    }
    case "$derived":
    case "$derived.by": {
      let fn = (
        /** @type {Expression} */
        context.visit(node.arguments[0])
      );
      return call("$.derived", rune === "$derived" ? thunk(fn) : fn);
    }
    case "$state.eager":
      return call(
        "$.eager",
        thunk(
          /** @type {Expression} */
          context.visit(node.arguments[0])
        )
      );
    case "$state.snapshot":
      return call(
        "$.snapshot",
        /** @type {Expression} */
        context.visit(node.arguments[0]),
        is_ignored(node, "state_snapshot_uncloneable") && true_instance
      );
    case "$effect":
    case "$effect.pre": {
      const callee = rune === "$effect" ? "$.user_effect" : "$.user_pre_effect";
      const func = (
        /** @type {Expression} */
        context.visit(node.arguments[0])
      );
      const expr = call(
        callee,
        /** @type {Expression} */
        func
      );
      expr.callee.loc = node.callee.loc;
      return expr;
    }
    case "$effect.root":
      return call(
        "$.effect_root",
        .../** @type {Expression[]} */
        node.arguments.map((arg) => context.visit(arg))
      );
    case "$effect.pending":
      return call("$.eager", thunk(call("$.pending")));
    case "$inspect":
    case "$inspect().with":
      return transform_inspect_rune(rune, node, context);
  }
  if (dev && node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "console" && context.state.scope.get("console") === null && node.callee.property.type === "Identifier" && ["debug", "dir", "error", "group", "groupCollapsed", "info", "log", "trace", "warn"].includes(
    node.callee.property.name
  ) && node.arguments.some(
    (arg) => arg.type === "SpreadElement" || context.state.scope.evaluate(arg).has_unknown
  )) {
    return call(
      node.callee,
      spread(
        call(
          "$.log_if_contains_state",
          literal2(node.callee.property.name),
          .../** @type {Expression[]} */
          node.arguments.map((arg) => context.visit(arg))
        )
      )
    );
  }
  context.next();
}
function transform_inspect_rune(rune, node, context) {
  if (!dev) return empty2;
  const { args, inspector } = get_inspect_args(rune, node, context.visit);
  const id2 = id("$$args");
  const fn = arrow([rest(id2)], call(inspector, spread(id2)));
  return call("$.inspect", thunk(array(args)), fn, rune === "$inspect" && true_instance);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ClassBody.js
function ClassBody3(node, context) {
  const state_fields = context.state.analysis.classes.get(node);
  if (!state_fields) {
    context.next();
    return;
  }
  const body = [];
  const child_state = { ...context.state, state_fields };
  for (const [name, field] of state_fields) {
    if (name[0] === "#") {
      continue;
    }
    if (field.node.type === "AssignmentExpression") {
      const member2 = member(this_instance, field.key);
      const should_proxy2 = field.type === "$state" && true;
      const key2 = key(name);
      body.push(
        prop_def(field.key, null),
        method("get", key2, [], [return_builder(call("$.get", member2))]),
        method(
          "set",
          key2,
          [id("value")],
          [stmt(call("$.set", member2, id("value"), should_proxy2 && true_instance))]
        )
      );
    }
  }
  const declaration2 = (
    /** @type {ClassDeclaration | ClassExpression} */
    get_parent(context.path, -1)
  );
  for (const definition of node.body) {
    if (definition.type !== "PropertyDefinition") {
      body.push(
        /** @type {MethodDefinition | StaticBlock} */
        context.visit(definition, child_state)
      );
      continue;
    }
    const name = get_name(definition.key);
    const field = name && /** @type {StateField} */
    state_fields.get(name);
    if (!field) {
      body.push(
        /** @type {PropertyDefinition} */
        context.visit(definition, child_state)
      );
      continue;
    }
    if (name[0] === "#") {
      let value = definition.value ? (
        /** @type {CallExpression} */
        context.visit(definition.value, child_state)
      ) : void 0;
      if (dev && field.node === definition) {
        value = call("$.tag", value, literal2(`${declaration2.id?.name ?? "[class]"}.${name}`));
      }
      body.push(prop_def(definition.key, value));
    } else if (field.node === definition) {
      let call2 = (
        /** @type {CallExpression} */
        context.visit(field.value, child_state)
      );
      if (dev) {
        call2 = call("$.tag", call2, literal2(`${declaration2.id?.name ?? "[class]"}.${name}`));
      }
      const member2 = member(this_instance, field.key);
      const should_proxy2 = field.type === "$state" && true;
      body.push(
        prop_def(field.key, call2),
        method("get", definition.key, [], [return_builder(call("$.get", member2))]),
        method(
          "set",
          definition.key,
          [id("value")],
          [stmt(call("$.set", member2, id("value"), should_proxy2 && true_instance))]
        )
      );
    }
  }
  return { ...node, body };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Comment.js
function Comment(node, context) {
  context.state.template.push_comment(node.data);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/component.js
function build_component(node, component_name2, context) {
  const anchor = context.state.node;
  const props_and_spreads = [];
  const delayed_props = [];
  const lets = [];
  const states = {
    default: {
      ...context.state,
      scope: node.metadata.scopes.default,
      transform: { ...context.state.transform }
    }
  };
  const children = {};
  const events = {};
  const memoizer = new Memoizer();
  const custom_css_props = [];
  let bind_this = null;
  const binding_initializers = [];
  const is_component_dynamic = node.type === "SvelteComponent" || node.type === "Component" && node.metadata.dynamic;
  const intermediate_name = node.type === "Component" && node.metadata.dynamic ? context.state.scope.generate(node.name) : "$$component";
  let slot_scope_applies_to_itself = !!determine_slot(node);
  let has_children_prop = false;
  function push_prop(prop2, delay = false) {
    const do_push = () => {
      const current2 = props_and_spreads.at(-1);
      const current_is_props = Array.isArray(current2);
      const props = current_is_props ? current2 : [];
      props.push(prop2);
      if (!current_is_props) {
        props_and_spreads.push(props);
      }
    };
    if (delay) {
      delayed_props.push(do_push);
    } else {
      do_push();
    }
  }
  if (slot_scope_applies_to_itself) {
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        context.visit(attribute, { ...context.state, let_directives: lets });
      }
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      if (!slot_scope_applies_to_itself) {
        context.visit(attribute, { ...states.default, let_directives: lets });
      }
    } else if (attribute.type === "OnDirective") {
      if (!attribute.expression) {
        context.state.analysis.needs_props = true;
      }
      let handler = build_event_handler(
        attribute.expression,
        attribute.metadata.expression,
        context
      );
      if (attribute.modifiers.includes("once")) {
        handler = call("$.once", handler);
      }
      (events[attribute.name] ||= []).push(handler);
    } else if (attribute.type === "SpreadAttribute") {
      const expression = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      const memoized_expression = memoizer.add(expression, attribute.metadata.expression);
      const is_memoized = expression !== memoized_expression;
      if (is_memoized || attribute.metadata.expression.has_state || attribute.metadata.expression.has_await) {
        props_and_spreads.push(
          thunk(is_memoized ? call("$.get", memoized_expression) : expression)
        );
      } else {
        props_and_spreads.push(expression);
      }
    } else if (attribute.type === "Attribute") {
      if (attribute.name.startsWith("--")) {
        custom_css_props.push(
          init(
            attribute.name,
            build_attribute_value2(attribute.value, context, (value2, metadata) => {
              const memoized = memoizer.add(value2, metadata);
              return value2 !== memoized ? call("$.get", memoized) : value2;
            }).value
          )
        );
        continue;
      }
      if (attribute.name === "slot") {
        slot_scope_applies_to_itself = true;
      }
      if (attribute.name === "children") {
        has_children_prop = true;
      }
      const { value, has_state } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => {
          const should_wrap_in_derived = metadata.has_await || get_attribute_chunks(attribute.value).some((n2) => {
            return n2.type === "ExpressionTag" && n2.expression.type !== "Identifier" && n2.expression.type !== "MemberExpression";
          });
          const memoized = memoizer.add(value2, metadata, should_wrap_in_derived);
          return value2 !== memoized ? call("$.get", memoized) : value2;
        }
      );
      if (has_state) {
        push_prop(get(attribute.name, [return_builder(value)]));
      } else {
        push_prop(init(attribute.name, value));
      }
    } else if (attribute.type === "BindDirective") {
      const expression = (
        /** @type {Expression} */
        context.visit(attribute.expression, { ...context.state, memoizer })
      );
      memoizer.check_blockers(attribute.metadata.expression);
      if (dev && attribute.name !== "this" && !is_ignored(node, "ownership_invalid_binding") && // bind:x={() => x.y, y => x.y = y} will be handled by the assignment expression binding validation
      attribute.expression.type !== "SequenceExpression") {
        const left = object2(attribute.expression);
        const binding = left && context.state.scope.get(left.name);
        if (binding?.kind === "bindable_prop" || binding?.kind === "prop") {
          context.state.analysis.needs_mutation_validation = true;
          binding_initializers.push(
            stmt(
              call(
                "$$ownership_validator.binding",
                literal2(binding.node.name),
                id(is_component_dynamic ? intermediate_name : component_name2),
                thunk(expression)
              )
            )
          );
        }
      }
      if (expression.type === "SequenceExpression") {
        if (attribute.name === "this") {
          bind_this = attribute.expression;
        } else {
          const [get3, set2] = expression.expressions;
          const get_id = id(context.state.scope.generate("bind_get"));
          const set_id = id(context.state.scope.generate("bind_set"));
          context.state.init.push(var_builder(get_id, get3));
          context.state.init.push(var_builder(set_id, set2));
          push_prop(get(attribute.name, [return_builder(call(get_id))]));
          push_prop(set(attribute.name, [stmt(call(set_id, id("$$value")))]));
        }
      } else {
        if (dev && expression.type === "MemberExpression" && context.state.analysis.runes && !is_ignored(node, "binding_property_non_reactive")) {
          validate_binding(context.state, attribute, expression);
        }
        if (attribute.name === "this") {
          bind_this = attribute.expression;
        } else {
          const is_store_sub = attribute.expression.type === "Identifier" && context.state.scope.get(attribute.expression.name)?.kind === "store_sub";
          if (is_store_sub) {
            push_prop(
              get(attribute.name, [stmt(call("$.mark_store_binding")), return_builder(expression)]),
              true
            );
          } else {
            push_prop(get(attribute.name, [return_builder(expression)]), true);
          }
          const assignment2 = assignment(
            "=",
            /** @type {Pattern} */
            attribute.expression,
            id("$$value")
          );
          push_prop(
            set(attribute.name, [stmt(
              /** @type {Expression} */
              context.visit(assignment2)
            )]),
            true
          );
        }
      }
    } else if (attribute.type === "AttachTag") {
      const evaluated = context.state.scope.evaluate(attribute.expression);
      let expression = (
        /** @type {Expression} */
        context.visit(attribute.expression)
      );
      if (attribute.metadata.expression.has_state) {
        expression = arrow(
          [id("$$node")],
          call(
            evaluated.is_function ? expression : logical("||", expression, id("$.noop")),
            id("$$node")
          )
        );
      }
      memoizer.check_blockers(attribute.metadata.expression);
      push_prop(prop("init", call("$.attachment"), expression, true));
    }
  }
  delayed_props.forEach((fn2) => fn2());
  if (slot_scope_applies_to_itself) {
    context.state.init.push(...lets);
  }
  if (Object.keys(events).length > 0) {
    const events_expression = object(
      Object.keys(events).map(
        (name) => init(name, events[name].length > 1 ? array(events[name]) : events[name][0])
      )
    );
    push_prop(init("$$events", events_expression));
  }
  const snippet_declarations = [];
  const serialized_slots = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock") {
      context.visit(child, {
        ...context.state,
        init: snippet_declarations
      });
      push_prop(prop("init", child.expression, child.expression));
      serialized_slots.push(
        init(child.expression.name === "children" ? "default" : child.expression.name, true_instance)
      );
      continue;
    }
    let slot_name = determine_slot(child) ?? "default";
    (children[slot_name] ||= []).push(child);
  }
  for (const slot_name of Object.keys(children)) {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(
        {
          ...node.fragment,
          // @ts-expect-error
          nodes: children[slot_name]
        },
        slot_name === "default" ? slot_scope_applies_to_itself ? context.state : states.default : {
          ...context.state,
          scope: node.metadata.scopes[slot_name],
          transform: { ...context.state.transform }
        }
      )
    );
    if (block2.body.length === 0) continue;
    const slot_fn = arrow(
      [id("$$anchor"), id("$$slotProps")],
      block([
        ...slot_name === "default" && !slot_scope_applies_to_itself ? lets : [],
        ...block2.body
      ])
    );
    if (slot_name === "default" && !has_children_prop) {
      if (lets.length === 0 && children.default.every(
        (node2) => node2.type !== "SvelteFragment" || !node2.attributes.some((attr) => attr.type === "LetDirective")
      )) {
        push_prop(
          init(
            "children",
            dev ? call("$.wrap_snippet", id(context.state.analysis.name), slot_fn) : slot_fn
          )
        );
        serialized_slots.push(init(slot_name, true_instance));
      } else {
        serialized_slots.push(init(slot_name, slot_fn));
        push_prop(init("children", id("$.invalid_default_snippet")));
      }
    } else {
      serialized_slots.push(init(slot_name, slot_fn));
    }
  }
  if (serialized_slots.length > 0) {
    push_prop(init("$$slots", object(serialized_slots)));
  }
  if (!context.state.analysis.runes && node.attributes.some((attribute) => attribute.type === "BindDirective")) {
    push_prop(init("$$legacy", true_instance));
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    ...props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p)
  );
  let fn = (node_id) => {
    return call(
      // TODO We can remove this ternary once we remove legacy mode, since in runes mode dynamic components
      // will be handled separately through the `$.component` function, and then the component name will
      // always be referenced through just the identifier here.
      is_component_dynamic ? intermediate_name : (
        /** @type {Expression} */
        context.visit(member_id(component_name2))
      ),
      node_id,
      props_expression
    );
  };
  if (bind_this !== null) {
    const prev = fn;
    fn = (node_id) => {
      return build_bind_this(bind_this, prev(node_id), context);
    };
  }
  if (node.type !== "SvelteSelf") {
    memoizer.check_blockers(node.metadata.expression);
  }
  const statements = [...snippet_declarations, ...memoizer.deriveds(context.state.analysis.runes)];
  if (is_component_dynamic) {
    const prev = fn;
    fn = (node_id) => {
      return call(
        "$.component",
        node_id,
        thunk(
          /** @type {Expression} */
          context.visit(node.type === "Component" ? member_id(component_name2) : node.expression)
        ),
        arrow(
          [id("$$anchor"), id(intermediate_name)],
          block([...binding_initializers, stmt(prev(id("$$anchor")))])
        )
      );
    };
  } else {
    statements.push(...binding_initializers);
  }
  if (Object.keys(custom_css_props).length > 0) {
    if (context.state.metadata.namespace === "svg") {
      context.state.template.push_element("g", node.start);
    } else {
      context.state.template.push_element("svelte-css-wrapper", node.start);
      context.state.template.set_prop("style", "display: contents");
    }
    context.state.template.push_comment();
    context.state.template.pop_element();
    statements.push(
      stmt(call("$.css_props", anchor, thunk(object(custom_css_props)))),
      stmt(fn(member(anchor, "lastChild"))),
      stmt(call("$.reset", anchor))
    );
  } else {
    context.state.template.push_comment();
    statements.push(add_svelte_meta(fn(anchor), node, "component", { componentTag: node.name }));
  }
  memoizer.apply();
  const async_values = memoizer.async_values();
  const blockers = memoizer.blockers();
  if (async_values || blockers) {
    return stmt(
      call(
        "$.async",
        anchor,
        blockers,
        async_values,
        arrow([id("$$anchor"), ...memoizer.async_ids()], block(statements))
      )
    );
  }
  return statements.length > 1 ? block(statements) : statements[0];
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Component.js
function Component3(node, context) {
  const component = build_component(node, node.name, context);
  context.state.init.push(component);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ConstTag.js
function ConstTag3(node, context) {
  const declaration2 = node.declaration.declarations[0];
  if (declaration2.id.type === "Identifier") {
    const init3 = build_expression(context, declaration2.init, node.metadata.expression);
    let expression = create_derived(context.state, init3, node.metadata.expression.has_await);
    if (dev) {
      expression = call("$.tag", expression, literal2(declaration2.id.name));
    }
    context.state.transform[declaration2.id.name] = { read: get_value };
    add_const_declaration(
      context.state,
      declaration2.id,
      expression,
      node.metadata.expression.has_await,
      context.state.scope.get_bindings(declaration2)
    );
  } else {
    const identifiers = extract_identifiers(declaration2.id);
    const tmp = id(context.state.scope.generate("computed_const"));
    const transform = { ...context.state.transform };
    for (const node2 of identifiers) {
      delete transform[node2.name];
    }
    const child_state = (
      /** @type {ComponentContext['state']} */
      {
        ...context.state,
        transform
      }
    );
    const init3 = build_expression(
      { ...context, state: child_state },
      declaration2.init,
      node.metadata.expression
    );
    const block2 = block([
      const_builder(
        /** @type {Pattern} */
        context.visit(declaration2.id, child_state),
        init3
      ),
      return_builder(object(identifiers.map((node2) => prop("init", node2, node2))))
    ]);
    let expression = create_derived(context.state, block2, node.metadata.expression.has_await);
    if (dev) {
      expression = call("$.tag", expression, literal2("[@const]"));
    }
    add_const_declaration(
      context.state,
      tmp,
      expression,
      node.metadata.expression.has_await,
      context.state.scope.get_bindings(declaration2)
    );
    for (const node2 of identifiers) {
      context.state.transform[node2.name] = {
        read: (node3) => member(call("$.get", tmp), node3)
      };
    }
  }
}
function add_const_declaration(state, id2, expression, has_await, bindings) {
  const after = dev ? [stmt(call("$.get", id2))] : [];
  if (has_await || state.async_consts) {
    const run = state.async_consts ??= {
      id: id(state.scope.generate("promises")),
      thunks: []
    };
    state.consts.push(let_builder(id2));
    const assignment2 = assignment("=", id2, expression);
    const body = after.length === 0 ? assignment2 : block([stmt(assignment2), ...after]);
    run.thunks.push(thunk(body, has_await));
    const blocker = member(run.id, literal2(run.thunks.length - 1), true);
    for (const binding of bindings) {
      binding.blocker = blocker;
    }
  } else {
    state.consts.push(const_builder(id2, expression));
    state.consts.push(...after);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/DebugTag.js
function DebugTag3(node, context) {
  const object4 = object(
    node.identifiers.map((identifier) => {
      const visited = call(
        "$.snapshot",
        /** @type {Expression} */
        context.visit(identifier)
      );
      return prop(
        "init",
        identifier,
        context.state.analysis.runes ? visited : call("$.untrack", thunk(visited))
      );
    })
  );
  const call2 = call("console.log", object4);
  context.state.init.push(
    stmt(call("$.template_effect", thunk(block([stmt(call2), debugger_builder]))))
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/EachBlock.js
function EachBlock3(node, context) {
  const each_node_meta = node.metadata;
  const parent_scope_state = {
    ...context.state,
    scope: (
      /** @type {Scope} */
      context.state.scope.parent
    )
  };
  const collection = build_expression(
    {
      ...context,
      state: parent_scope_state
    },
    node.expression,
    node.metadata.expression
  );
  if (!each_node_meta.is_controlled) {
    context.state.template.push_comment();
  }
  let flags = 0;
  if (node.metadata.keyed && node.index) {
    flags |= EACH_INDEX_REACTIVE;
  }
  const key_is_item = node.key?.type === "Identifier" && node.context?.type === "Identifier" && node.context?.name === node.key.name;
  let uses_store;
  for (const binding of node.metadata.expression.dependencies) {
    if (binding.kind === "store_sub") {
      uses_store = true;
      break;
    }
  }
  for (const binding of node.metadata.expression.dependencies) {
    if (binding.scope.function_depth >= context.state.scope.function_depth) {
      continue;
    }
    if (!context.state.analysis.runes || !key_is_item || uses_store) {
      flags |= EACH_ITEM_REACTIVE;
      break;
    }
  }
  if (context.state.analysis.runes && !uses_store) {
    flags |= EACH_ITEM_IMMUTABLE;
  }
  if (node.key && node.body.nodes.some((child) => {
    if (child.type !== "RegularElement" && child.type !== "SvelteElement") return false;
    return child.attributes.some((attr) => attr.type === "AnimateDirective");
  })) {
    flags |= EACH_IS_ANIMATED;
  }
  if (each_node_meta.is_controlled) {
    flags |= EACH_IS_CONTROLLED;
  }
  let store_to_invalidate = "";
  if (node.expression.type === "Identifier" || node.expression.type === "MemberExpression") {
    const id2 = object2(node.expression);
    if (id2) {
      const binding = context.state.scope.get(id2.name);
      if (binding?.kind === "store_sub") {
        store_to_invalidate = id2.name;
      }
    }
  }
  let collection_id = null;
  for (const [name] of context.state.scope.declarations) {
    if (context.state.scope.parent?.get(name) != null) {
      collection_id = context.state.scope.root.unique("$$array");
      break;
    }
  }
  const child_state = {
    ...context.state,
    transform: { ...context.state.transform },
    store_to_invalidate
  };
  const key_state = {
    ...context.state,
    transform: { ...context.state.transform }
  };
  const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
  const item = node.context?.type === "Identifier" ? node.context : id("$$item");
  let uses_index = each_node_meta.contains_group_binding;
  let key_uses_index = false;
  if (node.index) {
    child_state.transform[node.index] = {
      read: (node2) => {
        uses_index = true;
        return (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(node2) : node2;
      }
    };
    key_state.transform[node.index] = {
      read: (node2) => {
        key_uses_index = true;
        return node2;
      }
    };
  }
  const declarations = [];
  const invalidate_store = store_to_invalidate ? call("$.invalidate_store", id("$$stores"), literal2(store_to_invalidate)) : void 0;
  const sequence2 = [];
  if (!context.state.analysis.runes) {
    const transitive_deps = /* @__PURE__ */ new Set();
    if (collection_id) {
      transitive_deps.add(collection_id);
      child_state.transform[collection_id.name] = { read: call };
    } else {
      for (const binding of each_node_meta.transitive_deps) {
        transitive_deps.add(binding.node);
      }
    }
    for (const block3 of collect_parent_each_blocks(context)) {
      for (const binding of block3.metadata.transitive_deps) {
        transitive_deps.add(binding.node);
      }
    }
    if (transitive_deps.size > 0) {
      const invalidate = call(
        "$.invalidate_inner_signals",
        thunk(
          sequence(
            [...transitive_deps].map(
              (node2) => (
                /** @type {Expression} */
                context.visit({ ...node2 }, child_state)
              )
            )
          )
        )
      );
      sequence2.push(invalidate);
    }
  }
  if (invalidate_store) {
    sequence2.push(invalidate_store);
  }
  if (node.context?.type === "Identifier") {
    const binding = (
      /** @type {Binding} */
      context.state.scope.get(node.context.name)
    );
    child_state.transform[node.context.name] = {
      read: (node2) => {
        if (binding.reassigned) {
          return member(
            collection_id ? call(collection_id) : collection,
            (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index,
            true
          );
        }
        return (flags & EACH_ITEM_REACTIVE) !== 0 ? get_value(node2) : node2;
      },
      assign: (_2, value) => {
        uses_index = true;
        const left = member(
          collection_id ? call(collection_id) : collection,
          (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index,
          true
        );
        return sequence([assignment("=", left, value), ...sequence2]);
      },
      mutate: (_2, mutation) => {
        uses_index = true;
        return sequence([mutation, ...sequence2]);
      }
    };
    delete key_state.transform[node.context.name];
  } else if (node.context) {
    const unwrapped = (flags & EACH_ITEM_REACTIVE) !== 0 ? call("$.get", item) : item;
    const { inserts, paths } = extract_paths(node.context, unwrapped);
    for (const { id: id2, value } of inserts) {
      id2.name = context.state.scope.generate("$$array");
      child_state.transform[id2.name] = { read: get_value };
      const expression = (
        /** @type {Expression} */
        context.visit(thunk(value), child_state)
      );
      declarations.push(var_builder(id2, call("$.derived", expression)));
    }
    for (const path of paths) {
      const name = (
        /** @type {Identifier} */
        path.node.name
      );
      const needs_derived = path.has_default_value;
      const fn = thunk(
        /** @type {Expression} */
        context.visit(path.expression, child_state)
      );
      declarations.push(let_builder(path.node, needs_derived ? call("$.derived_safe_equal", fn) : fn));
      const read = needs_derived ? get_value : call;
      child_state.transform[name] = {
        read,
        assign: (_2, value) => {
          const left = (
            /** @type {Pattern} */
            path.update_expression
          );
          return sequence([assignment("=", left, value), ...sequence2]);
        },
        mutate: (_2, mutation) => {
          return sequence([mutation, ...sequence2]);
        }
      };
      if (dev) {
        declarations.push(stmt(read(id(name))));
      }
      delete key_state.transform[name];
    }
  }
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.body, child_state)
  );
  let key_function = id("$.index");
  if (node.metadata.keyed) {
    const pattern = (
      /** @type {Pattern} */
      node.context
    );
    const expression = (
      /** @type {Expression} */
      context.visit(
        /** @type {Expression} */
        node.key,
        key_state
      )
    );
    key_function = arrow(key_uses_index ? [pattern, index] : [pattern], expression);
  }
  if (node.index && each_node_meta.contains_group_binding) {
    declarations.push(let_builder(node.index, index));
  }
  const is_async = node.metadata.expression.is_async();
  const get_collection = thunk(collection, node.metadata.expression.has_await);
  const thunk2 = is_async ? thunk(call("$.get", id("$$collection"))) : get_collection;
  const render_args = [id("$$anchor"), item];
  if (uses_index || collection_id) render_args.push(index);
  if (collection_id) render_args.push(collection_id);
  const args = [
    context.state.node,
    literal2(flags),
    thunk2,
    key_function,
    arrow(render_args, block(declarations.concat(block2.body)))
  ];
  if (node.fallback) {
    args.push(
      arrow(
        [id("$$anchor")],
        /** @type {BlockStatement} */
        context.visit(node.fallback)
      )
    );
  }
  const statements = [add_svelte_meta(call("$.each", ...args), node, "each")];
  if (dev && node.metadata.keyed) {
    statements.unshift(stmt(call("$.validate_each_keys", thunk2, key_function)));
  }
  if (is_async) {
    context.state.init.push(
      stmt(
        call(
          "$.async",
          context.state.node,
          node.metadata.expression.blockers(),
          array([get_collection]),
          arrow([context.state.node, id("$$collection")], block(statements))
        )
      )
    );
  } else {
    context.state.init.push(...statements);
  }
}
function collect_parent_each_blocks(context) {
  return (
    /** @type {AST.EachBlock[]} */
    context.path.filter((node) => node.type === "EachBlock")
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ExportNamedDeclaration.js
function ExportNamedDeclaration2(node, context) {
  if (context.state.is_instance) {
    if (node.declaration) {
      return context.visit(node.declaration);
    }
    return empty2;
  }
  return context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ExpressionStatement.js
function ExpressionStatement3(node, context) {
  if (node.expression.type === "CallExpression") {
    const rune = get_rune(node.expression, context.state.scope);
    if (rune === "$inspect.trace") {
      return empty2;
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ForOfStatement.js
function ForOfStatement(node, context) {
  if (node.await && dev && !is_ignored(node, "await_reactivity_loss") && context.state.options.experimental.async) {
    const left = (
      /** @type {VariableDeclaration | Pattern} */
      context.visit(node.left)
    );
    const argument = (
      /** @type {Expression} */
      context.visit(node.right)
    );
    const body = (
      /** @type {Statement} */
      context.visit(node.body)
    );
    const right = call("$.for_await_track_reactivity_loss", argument);
    return for_of(left, right, body, true);
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/transform-template/index.js
function build_locations(nodes) {
  const array2 = array([]);
  for (const node of nodes) {
    if (node.type !== "element") continue;
    const { line, column } = (
      /** @type {Location} */
      locator(node.start)
    );
    const expression = array([literal2(line), literal2(column)]);
    const children = build_locations(node.children);
    if (children.elements.length > 0) {
      expression.elements.push(children);
    }
    array2.elements.push(expression);
  }
  return array2;
}
function transform_template(state, namespace, flags = 0) {
  const tree = state.options.fragments === "tree";
  const expression = tree ? state.template.as_tree() : state.template.as_html();
  if (tree) {
    if (namespace === "svg") flags |= TEMPLATE_USE_SVG;
    if (namespace === "mathml") flags |= TEMPLATE_USE_MATHML;
  }
  let call2 = call(
    tree ? `$.from_tree` : `$.from_${namespace}`,
    expression,
    flags ? literal2(flags) : void 0
  );
  if (state.template.contains_script_tag) {
    call2 = call(`$.with_script`, call2);
  }
  if (dev) {
    call2 = call(
      "$.add_locations",
      call2,
      member(id(state.analysis.name), "$.FILENAME", true),
      build_locations(state.template.nodes)
    );
  }
  return call2;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/transform-template/fix-attribute-casing.js
var svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(
  " "
);
var svg_attribute_lookup = /* @__PURE__ */ new Map();
svg_attributes.forEach((name) => {
  svg_attribute_lookup.set(name.toLowerCase(), name);
});
function fix_attribute_casing(name) {
  name = name.toLowerCase();
  return svg_attribute_lookup.get(name) || name;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/transform-template/template.js
var Template = class {
  /**
   * `true` if HTML template contains a `<script>` tag. In this case we need to invoke a special
   * template instantiation function (see `create_fragment_with_script_from_html` for more info)
   */
  contains_script_tag = false;
  /** `true` if the HTML template needs to be instantiated with `importNode` */
  needs_import_node = false;
  /** @type {Node[]} */
  nodes = [];
  /** @type {Node[][]} */
  #stack = [this.nodes];
  /** @type {Element | undefined} */
  #element;
  #fragment = this.nodes;
  /**
   * @param {string} name
   * @param {number} start
   */
  push_element(name, start) {
    this.#element = {
      type: "element",
      name,
      attributes: {},
      children: [],
      start
    };
    this.#fragment.push(this.#element);
    this.#fragment = /** @type {Element} */
    this.#element.children;
    this.#stack.push(this.#fragment);
  }
  /** @param {string} [data] */
  push_comment(data2) {
    this.#fragment.push({ type: "comment", data: data2 });
  }
  /** @param {AST.Text[]} nodes */
  push_text(nodes) {
    this.#fragment.push({ type: "text", nodes });
  }
  pop_element() {
    this.#stack.pop();
    this.#fragment = /** @type {Node[]} */
    this.#stack.at(-1);
  }
  /**
   * @param {string} key
   * @param {string | undefined} value
   */
  set_prop(key2, value) {
    this.#element.attributes[key2] = value;
  }
  as_html() {
    return template([quasi(this.nodes.map(stringify).join(""), true)], []);
  }
  as_tree() {
    if (this.nodes[0].type === "comment") {
      this.nodes.unshift({ type: "comment", data: void 0 });
    }
    return array(this.nodes.map(objectify));
  }
};
function stringify(item) {
  if (item.type === "text") {
    return item.nodes.map((node) => node.raw).join("");
  }
  if (item.type === "comment") {
    return item.data ? `<!--${item.data}-->` : "<!>";
  }
  let str2 = `<${item.name}`;
  for (const key2 in item.attributes) {
    const value = item.attributes[key2];
    str2 += ` ${key2}`;
    if (value !== void 0) str2 += `="${escape_html(value, true)}"`;
  }
  if (is_void(item.name)) {
    str2 += "/>";
  } else {
    str2 += `>`;
    str2 += item.children.map(stringify).join("");
    str2 += `</${item.name}>`;
  }
  return str2;
}
function objectify(item) {
  if (item.type === "text") {
    return literal2(item.nodes.map((node) => node.data).join(""));
  }
  if (item.type === "comment") {
    return item.data ? array([literal2(`// ${item.data}`)]) : null;
  }
  const element2 = array([literal2(item.name)]);
  const attributes = object([]);
  for (const key2 in item.attributes) {
    const value = item.attributes[key2];
    attributes.properties.push(
      prop(
        "init",
        key(fix_attribute_casing(key2)),
        value === void 0 ? void0 : literal2(value)
      )
    );
  }
  if (attributes.properties.length > 0 || item.children.length > 0) {
    element2.elements.push(attributes.properties.length > 0 ? attributes : null_instance);
  }
  if (item.children.length > 0) {
    const children = item.children.map(objectify);
    element2.elements.push(...children);
    if (item.name === "pre" || item.name === "textarea") {
      const first = children[0];
      if (first?.type === "Literal") {
        first.value = /** @type {string} */
        first.value.replace(regex_starts_with_newline, "");
      }
    }
  }
  return element2;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Fragment.js
function Fragment3(node, context) {
  const parent = context.path.at(-1) ?? node;
  const namespace = infer_namespace(context.state.metadata.namespace, parent, node.nodes);
  const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
    parent,
    node.nodes,
    context.path,
    namespace,
    context.state,
    context.state.preserve_whitespace,
    context.state.options.preserveComments
  );
  if (hoisted.length === 0 && trimmed.length === 0) {
    return block([]);
  }
  const is_single_element = trimmed.length === 1 && trimmed[0].type === "RegularElement";
  const is_single_child_not_needing_template = trimmed.length === 1 && (trimmed[0].type === "SvelteFragment" || trimmed[0].type === "TitleElement");
  const template_name = context.state.scope.root.unique("root");
  const body = [];
  let close2 = void 0;
  const state = {
    ...context.state,
    init: [],
    consts: [],
    let_directives: [],
    update: [],
    after_update: [],
    memoizer: new Memoizer(),
    template: new Template(),
    transform: { ...context.state.transform },
    metadata: {
      namespace,
      bound_contenteditable: context.state.metadata.bound_contenteditable
    },
    async_consts: void 0
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_single_element) {
    const element2 = (
      /** @type {AST.RegularElement} */
      trimmed[0]
    );
    const id2 = id(context.state.scope.generate(element2.name));
    context.visit(element2, {
      ...state,
      node: id2
    });
    let flags = state.template.needs_import_node ? TEMPLATE_USE_IMPORT_NODE : void 0;
    const template2 = transform_template(state, namespace, flags);
    state.hoisted.push(var_builder(template_name, template2));
    state.init.unshift(var_builder(id2, call(template_name)));
    close2 = stmt(call("$.append", id("$$anchor"), id2));
  } else if (is_single_child_not_needing_template) {
    context.visit(trimmed[0], state);
  } else if (trimmed.length === 1 && trimmed[0].type === "Text") {
    const id2 = id(context.state.scope.generate("text"));
    state.init.unshift(var_builder(id2, call("$.text", literal2(trimmed[0].data))));
    close2 = stmt(call("$.append", id("$$anchor"), id2));
  } else if (trimmed.length > 0) {
    const id2 = id(context.state.scope.generate("fragment"));
    const use_space_template = trimmed.some((node2) => node2.type === "ExpressionTag") && trimmed.every((node2) => node2.type === "Text" || node2.type === "ExpressionTag");
    if (use_space_template) {
      const id3 = id(context.state.scope.generate("text"));
      process_children2(trimmed, () => id3, false, {
        ...context,
        state
      });
      state.init.unshift(var_builder(id3, call("$.text")));
      close2 = stmt(call("$.append", id("$$anchor"), id3));
    } else {
      if (is_standalone) {
        process_children2(trimmed, () => id("$$anchor"), false, { ...context, state });
      } else {
        const expression = (is_text) => call("$.first_child", id2, is_text && true_instance);
        process_children2(trimmed, expression, false, { ...context, state });
        let flags = TEMPLATE_FRAGMENT;
        if (state.template.needs_import_node) {
          flags |= TEMPLATE_USE_IMPORT_NODE;
        }
        if (state.template.nodes.length === 1 && state.template.nodes[0].type === "comment") {
          state.init.unshift(var_builder(id2, call("$.comment")));
        } else {
          const template2 = transform_template(state, namespace, flags);
          state.hoisted.push(var_builder(template_name, template2));
          state.init.unshift(var_builder(id2, call(template_name)));
        }
        close2 = stmt(call("$.append", id("$$anchor"), id2));
      }
    }
  }
  body.push(...state.let_directives, ...state.consts);
  if (state.async_consts && state.async_consts.thunks.length > 0) {
    body.push(var_builder(state.async_consts.id, call("$.run", array(state.async_consts.thunks))));
  }
  if (is_text_first) {
    body.push(stmt(call("$.next")));
  }
  body.push(...state.init);
  if (state.update.length > 0) {
    body.push(build_render_statement(state));
  }
  body.push(...state.after_update);
  if (close2 !== void 0) {
    body.push(close2);
  }
  return block(body);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/FunctionDeclaration.js
function FunctionDeclaration2(node, context) {
  const state = { ...context.state, in_constructor: false, in_derived: false };
  context.next(state);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/FunctionExpression.js
function FunctionExpression2(node, context) {
  return visit_function2(node, context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/HtmlTag.js
function HtmlTag3(node, context) {
  context.state.template.push_comment();
  const is_async = node.metadata.expression.is_async();
  const expression = build_expression(context, node.expression, node.metadata.expression);
  const html = is_async ? call("$.get", id("$$html")) : expression;
  const is_svg2 = context.state.metadata.namespace === "svg";
  const is_mathml2 = context.state.metadata.namespace === "mathml";
  const statement = stmt(
    call(
      "$.html",
      context.state.node,
      thunk(html),
      is_svg2 && true_instance,
      is_mathml2 && true_instance,
      is_ignored(node, "hydration_html_changed") && true_instance
    )
  );
  if (is_async) {
    context.state.init.push(
      stmt(
        call(
          "$.async",
          context.state.node,
          node.metadata.expression.blockers(),
          array([thunk(expression, node.metadata.expression.has_await)]),
          arrow([context.state.node, id("$$html")], block([statement]))
        )
      )
    );
  } else {
    context.state.init.push(statement);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Identifier.js
function Identifier3(node, context) {
  const parent = (
    /** @type {Node} */
    context.path.at(-1)
  );
  if (is_reference(node, parent)) {
    if (node.name === "$$props") {
      return id("$$sanitized_props");
    }
    const binding = context.state.scope.get(node.name);
    if (context.state.analysis.runes && // can't do this in legacy mode because the proxy does more than just read/write
    binding !== null && node !== binding.node && binding.kind === "rest_prop") {
      const grand_parent = context.path.at(-2);
      if (parent?.type === "MemberExpression" && !parent.computed && grand_parent?.type !== "AssignmentExpression" && grand_parent?.type !== "UpdateExpression") {
        const key2 = (
          /** @type {Identifier} */
          parent.property
        );
        if (!binding.metadata?.exclude_props?.includes(key2.name)) {
          return id("$$props");
        }
      }
    }
    return build_getter(node, context.state);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/IfBlock.js
function IfBlock3(node, context) {
  context.state.template.push_comment();
  const statements = [];
  const consequent = (
    /** @type {BlockStatement} */
    context.visit(node.consequent)
  );
  const consequent_id = id(context.state.scope.generate("consequent"));
  statements.push(var_builder(consequent_id, arrow([id("$$anchor")], consequent)));
  let alternate_id;
  if (node.alternate) {
    const alternate = (
      /** @type {BlockStatement} */
      context.visit(node.alternate)
    );
    alternate_id = id(context.state.scope.generate("alternate"));
    statements.push(var_builder(alternate_id, arrow([id("$$anchor")], alternate)));
  }
  const is_async = node.metadata.expression.is_async();
  const expression = build_expression(context, node.test, node.metadata.expression);
  const test = is_async ? call("$.get", id("$$condition")) : expression;
  const args = [
    context.state.node,
    arrow(
      [id("$$render")],
      block([
        if_builder(
          test,
          stmt(call("$$render", consequent_id)),
          alternate_id && stmt(call("$$render", alternate_id, literal2(false)))
        )
      ])
    )
  ];
  if (node.elseif) {
    args.push(true_instance);
  }
  statements.push(add_svelte_meta(call("$.if", ...args), node, "if"));
  if (is_async) {
    context.state.init.push(
      stmt(
        call(
          "$.async",
          context.state.node,
          node.metadata.expression.blockers(),
          array([thunk(expression, node.metadata.expression.has_await)]),
          arrow([context.state.node, id("$$condition")], block(statements))
        )
      )
    );
  } else {
    context.state.init.push(block(statements));
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/KeyBlock.js
function KeyBlock3(node, context) {
  context.state.template.push_comment();
  const is_async = node.metadata.expression.is_async();
  const expression = build_expression(context, node.expression, node.metadata.expression);
  const key2 = thunk(is_async ? call("$.get", id("$$key")) : expression);
  const body = (
    /** @type {Expression} */
    context.visit(node.fragment)
  );
  let statement = add_svelte_meta(
    call("$.key", context.state.node, key2, arrow([id("$$anchor")], body)),
    node,
    "key"
  );
  if (is_async) {
    statement = stmt(
      call(
        "$.async",
        context.state.node,
        node.metadata.expression.blockers(),
        array([thunk(expression, node.metadata.expression.has_await)]),
        arrow([context.state.node, id("$$key")], block([statement]))
      )
    );
  }
  context.state.init.push(statement);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/LabeledStatement.js
function LabeledStatement3(node, context) {
  if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== "$") {
    context.next();
    return;
  }
  const reactive_statement = (
    /** @type {ReactiveStatement} */
    context.state.analysis.reactive_statements.get(node)
  );
  if (!reactive_statement) return;
  let serialized_body = (
    /** @type {Statement} */
    context.visit(node.body)
  );
  if (serialized_body.type !== "BlockStatement") {
    serialized_body = block([serialized_body]);
  }
  const body = serialized_body.body;
  const sequence2 = [];
  for (const binding of reactive_statement.dependencies) {
    if (binding.kind === "normal" && binding.declaration_kind !== "import") continue;
    const name = binding.node.name;
    let serialized = build_getter(id(name), context.state);
    if (name === "$$props" || name === "$$restProps" || binding.kind === "bindable_prop") {
      serialized = call("$.deep_read_state", serialized);
    }
    sequence2.push(serialized);
  }
  context.state.legacy_reactive_statements.set(
    node,
    stmt(
      call(
        "$.legacy_pre_effect",
        sequence2.length > 0 ? thunk(sequence(sequence2)) : thunk(block([])),
        thunk(block(body))
      )
    )
  );
  return empty2;
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/LetDirective.js
function LetDirective2(node, context) {
  if (node.expression && node.expression.type !== "Identifier") {
    const name = context.state.scope.generate(node.name);
    const bindings = context.state.scope.get_bindings(node);
    for (const binding of bindings) {
      context.state.transform[binding.node.name] = {
        read: (node2) => member(call("$.get", id(name)), node2)
      };
    }
    context.state.let_directives.push(
      const_builder(
        name,
        call(
          "$.derived",
          thunk(
            block([
              let_builder(
                /** @type {Expression} */
                node.expression.type === "ObjectExpression" ? (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  object_pattern(node.expression.properties)
                ) : (
                  // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                  array_pattern(node.expression.elements)
                ),
                member(id("$$slotProps"), node.name)
              ),
              return_builder(object(bindings.map((binding) => init(binding.node.name, binding.node))))
            ])
          )
        )
      )
    );
  } else {
    const name = node.expression === null ? node.name : node.expression.name;
    context.state.transform[name] = {
      read: (node2) => call("$.get", node2)
    };
    context.state.let_directives.push(
      const_builder(name, create_derived(context.state, member(id("$$slotProps"), node.name)))
    );
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/MemberExpression.js
function MemberExpression3(node, context) {
  if (node.property.type === "PrivateIdentifier") {
    const field = context.state.state_fields.get("#" + node.property.name);
    if (field) {
      return context.state.in_constructor && (field.type === "$state.raw" || field.type === "$state") ? member(node, "v") : call("$.get", node);
    }
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/OnDirective.js
var modifiers = (
  /** @type {const} */
  [
    "stopPropagation",
    "stopImmediatePropagation",
    "preventDefault",
    "self",
    "trusted",
    "once"
  ]
);
function OnDirective2(node, context) {
  if (!node.expression) {
    context.state.analysis.needs_props = true;
  }
  let handler = build_event_handler(node.expression, node.metadata.expression, context);
  for (const modifier of modifiers) {
    if (node.modifiers.includes(modifier)) {
      handler = call("$." + modifier, handler);
    }
  }
  const capture = node.modifiers.includes("capture");
  const passive = node.modifiers.includes("passive") || (node.modifiers.includes("nonpassive") ? false : void 0);
  return build_event(node.name, context.state.node, handler, capture, passive);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Program.js
function Program2(node, context) {
  if (!context.state.analysis.runes) {
    context.state.transform["$$props"] = {
      read: (node2) => ({ ...node2, name: "$$sanitized_props" })
    };
    for (const [name, binding] of context.state.scope.declarations) {
      if (binding.declaration_kind === "import" && binding.mutated) {
        const { start, end } = context.state.analysis.instance.ast;
        const node2 = (
          /** @type {ImportDeclaration} */
          binding.initial
        );
        const is_instance_import = (
          /** @type {number} */
          node2.start > /** @type {number} */
          start && /** @type {number} */
          node2.end < /** @type {number} */
          end
        );
        if (is_instance_import) {
          const id2 = id("$$_import_" + name);
          context.state.transform[name] = {
            read: (_2) => call(id2),
            mutate: (_2, mutation) => call(id2, mutation)
          };
          context.state.legacy_reactive_imports.push(
            var_builder(id2, call("$.reactive_import", thunk(id(name))))
          );
        }
      }
    }
  }
  for (const [name, binding] of context.state.scope.declarations) {
    if (binding.kind === "store_sub") {
      let cached;
      const get_store = () => {
        return cached ??= /** @type {Expression} */
        context.visit(id(name.slice(1)));
      };
      context.state.transform[name] = {
        read: call,
        assign: (_2, value) => call("$.store_set", get_store(), value),
        mutate: (node2, mutation) => {
          const untracked = call("$.untrack", node2);
          function replace(n2) {
            if (n2.type === "MemberExpression") {
              return {
                ...n2,
                object: replace(
                  /** @type {Expression} */
                  n2.object
                ),
                property: n2.property
              };
            }
            return untracked;
          }
          return call(
            "$.store_mutate",
            get_store(),
            mutation.type === "AssignmentExpression" ? assignment(
              mutation.operator,
              /** @type {MemberExpression} */
              replace(
                /** @type {MemberExpression} */
                mutation.left
              ),
              mutation.right
            ) : update(mutation.operator, replace(mutation.argument), mutation.prefix),
            untracked
          );
        },
        update: (node2) => {
          return call(
            node2.prefix ? "$.update_pre_store" : "$.update_store",
            build_getter(id(name.slice(1)), context.state),
            call(node2.argument),
            node2.operator === "--" && literal2(-1)
          );
        }
      };
    }
    if (binding.kind === "prop" || binding.kind === "bindable_prop") {
      if (is_prop_source(binding, context.state)) {
        context.state.transform[name] = {
          read: call,
          assign: (node2, value) => call(node2, value),
          mutate: (node2, value) => {
            if (binding.kind === "bindable_prop") {
              return call(node2, value, true_instance);
            }
            return value;
          },
          update: (node2) => {
            return call(
              node2.prefix ? "$.update_pre_prop" : "$.update_prop",
              node2.argument,
              node2.operator === "--" && literal2(-1)
            );
          }
        };
      } else if (binding.prop_alias) {
        const key2 = key(binding.prop_alias);
        context.state.transform[name] = {
          read: (_2) => member(id("$$props"), key2, key2.type === "Literal")
        };
      } else {
        context.state.transform[name] = {
          read: (node2) => member(id("$$props"), node2)
        };
      }
    }
  }
  add_state_transformers(context);
  if (context.state.is_instance) {
    return {
      ...node,
      body: transform_body(
        context.state.analysis.instance_body,
        id("$.run"),
        (node2) => (
          /** @type {Node} */
          context.visit(node2)
        )
      )
    };
  }
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/RenderTag.js
function RenderTag3(node, context) {
  context.state.template.push_comment();
  const call2 = unwrap_optional(node.expression);
  let args = [];
  const memoizer = new Memoizer();
  for (let i = 0; i < call2.arguments.length; i++) {
    const arg = (
      /** @type {Expression} */
      call2.arguments[i]
    );
    const metadata = node.metadata.arguments[i];
    let expression = build_expression(context, arg, metadata);
    const memoized = memoizer.add(expression, metadata);
    if (expression !== memoized) {
      expression = call("$.get", memoized);
    }
    args.push(thunk(expression));
  }
  memoizer.apply();
  const statements = memoizer.deriveds(context.state.analysis.runes);
  let snippet_function = build_expression(
    context,
    /** @type {Expression} */
    call2.callee,
    node.metadata.expression
  );
  if (node.metadata.dynamic) {
    if (node.expression.type === "ChainExpression") {
      snippet_function = logical("??", snippet_function, id("$.noop"));
    }
    statements.push(
      add_svelte_meta(
        call("$.snippet", context.state.node, thunk(snippet_function), ...args),
        node,
        "render"
      )
    );
  } else {
    statements.push(
      add_svelte_meta(
        (node.expression.type === "CallExpression" ? call : maybe_call)(
          snippet_function,
          context.state.node,
          ...args
        ),
        node,
        "render"
      )
    );
  }
  const async_values = memoizer.async_values();
  const blockers = memoizer.blockers();
  if (async_values || blockers) {
    context.state.init.push(
      stmt(
        call(
          "$.async",
          context.state.node,
          blockers,
          memoizer.async_values(),
          arrow([context.state.node, ...memoizer.async_ids()], block(statements))
        )
      )
    );
  } else {
    context.state.init.push(statements.length === 1 ? statements[0] : block(statements));
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SlotElement.js
function SlotElement3(node, context) {
  context.state.template.push_comment();
  const props = [];
  const spreads = [];
  const lets = [];
  const memoizer = new Memoizer();
  let name = literal2("default");
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      spreads.push(thunk(
        /** @type {Expression} */
        context.visit(attribute)
      ));
    } else if (attribute.type === "Attribute") {
      const { value, has_state } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => metadata.has_call || metadata.has_await ? call("$.get", memoizer.add(value2, metadata)) : value2
      );
      if (attribute.name === "name") {
        name = /** @type {Literal} */
        value;
      } else if (attribute.name !== "slot") {
        if (has_state) {
          props.push(get(attribute.name, [return_builder(value)]));
        } else {
          props.push(init(attribute.name, value));
        }
      }
    } else if (attribute.type === "LetDirective") {
      context.visit(attribute, { ...context.state, let_directives: lets });
    }
  }
  memoizer.apply();
  context.state.init.push(...lets);
  const statements = memoizer.deriveds(context.state.analysis.runes);
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", object(props), ...spreads);
  const fallback = node.fragment.nodes.length === 0 ? null_instance : arrow(
    [id("$$anchor")],
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  statements.push(
    stmt(call("$.slot", context.state.node, id("$$props"), name, props_expression, fallback))
  );
  const async_values = memoizer.async_values();
  const blockers = memoizer.blockers();
  if (async_values || blockers) {
    context.state.init.push(
      stmt(
        call(
          "$.async",
          context.state.node,
          blockers,
          async_values,
          arrow([context.state.node, ...memoizer.async_ids()], block(statements))
        )
      )
    );
  } else {
    context.state.init.push(statements.length === 1 ? statements[0] : block(statements));
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SnippetBlock.js
function SnippetBlock3(node, context) {
  const args = [id("$$anchor")];
  let body;
  const declarations = [];
  const transform = { ...context.state.transform };
  const child_state = { ...context.state, transform };
  for (let i = 0; i < node.parameters.length; i++) {
    const argument = node.parameters[i];
    if (!argument) continue;
    if (argument.type === "Identifier") {
      args.push(assignment_pattern(argument, id("$.noop")));
      transform[argument.name] = { read: call };
      continue;
    }
    let arg_alias = `$$arg${i}`;
    args.push(id(arg_alias));
    const { inserts, paths } = extract_paths(argument, maybe_call(id(arg_alias)));
    for (const { id: id2, value } of inserts) {
      id2.name = context.state.scope.generate("$$array");
      transform[id2.name] = { read: get_value };
      declarations.push(
        var_builder(id2, call(
          "$.derived",
          /** @type {Expression} */
          context.visit(thunk(value))
        ))
      );
    }
    for (const path of paths) {
      const name = (
        /** @type {Identifier} */
        path.node.name
      );
      const needs_derived = path.has_default_value;
      const fn = thunk(
        /** @type {Expression} */
        context.visit(path.expression, child_state)
      );
      declarations.push(let_builder(path.node, needs_derived ? call("$.derived_safe_equal", fn) : fn));
      transform[name] = {
        read: needs_derived ? get_value : call
      };
      if (dev) {
        declarations.push(stmt(transform[name].read(id(name))));
      }
    }
  }
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.body, child_state).body
  );
  body = block([
    dev ? stmt(call("$.validate_snippet_args", spread(id("arguments")))) : empty2,
    ...declarations,
    ...block2
  ]);
  let snippet = dev ? call("$.wrap_snippet", id(context.state.analysis.name), function_builder(null, args, body)) : arrow(args, body);
  const declaration2 = const_builder(node.expression, snippet);
  if (context.path.length === 1 && context.path[0].type === "Fragment") {
    if (node.metadata.can_hoist) {
      context.state.module_level_snippets.push(declaration2);
    } else {
      context.state.instance_level_snippets.push(declaration2);
    }
  } else {
    context.state.init.push(declaration2);
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SpreadAttribute.js
function SpreadAttribute3(node, context) {
  return context.visit(node.expression);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/special_element.js
function visit_special_element(node, id2, context) {
  const state = { ...context.state, node: id(id2) };
  for (const attribute of node.attributes) {
    if (attribute.type === "OnDirective") {
      context.state.init.push(stmt(
        /** @type {Expression} */
        context.visit(attribute, state)
      ));
    } else {
      context.visit(attribute, state);
    }
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteBody.js
function SvelteBody2(node, context) {
  visit_special_element(node, "$.document.body", context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteComponent.js
function SvelteComponent3(node, context) {
  const component = build_component(node, "$$component", context);
  context.state.init.push(component);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteDocument.js
function SvelteDocument2(node, context) {
  visit_special_element(node, "$.document", context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteElement.js
function SvelteElement3(node, context) {
  context.state.template.push_comment();
  const attributes = [];
  let dynamic_namespace = void 0;
  const class_directives = [];
  const style_directives = [];
  const statements = [];
  const element_id = id(context.state.scope.generate("$$element"));
  const inner_context = {
    ...context,
    state: {
      ...context.state,
      node: element_id,
      init: [],
      update: [],
      after_update: [],
      memoizer: new Memoizer()
    }
  };
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "xmlns" && !is_text_attribute(attribute)) {
        dynamic_namespace = attribute.value;
      }
      attributes.push(attribute);
    } else if (attribute.type === "SpreadAttribute") {
      attributes.push(attribute);
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
      statements.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    } else if (attribute.type === "OnDirective") {
      const handler = (
        /** @type {Expression} */
        context.visit(attribute, inner_context.state)
      );
      inner_context.state.after_update.push(stmt(handler));
    } else {
      context.visit(attribute, inner_context.state);
    }
  }
  if (attributes.length === 1 && attributes[0].type === "Attribute" && attributes[0].name.toLowerCase() === "class" && is_text_attribute(attributes[0])) {
    build_set_class(node, element_id, attributes[0], class_directives, inner_context, false);
  } else if (attributes.length) {
    build_attribute_effect(
      attributes,
      class_directives,
      style_directives,
      inner_context,
      node,
      element_id
    );
  }
  const is_async = node.metadata.expression.is_async();
  const expression = (
    /** @type {Expression} */
    context.visit(node.tag)
  );
  const get_tag = thunk(is_async ? call("$.get", id("$$tag")) : expression);
  const inner = inner_context.state.init;
  if (inner_context.state.update.length > 0) {
    inner.push(build_render_statement(inner_context.state));
  }
  inner.push(...inner_context.state.after_update);
  inner.push(
    .../** @type {BlockStatement} */
    context.visit(node.fragment, {
      ...context.state,
      metadata: {
        ...context.state.metadata,
        namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
      }
    }).body
  );
  if (dev) {
    if (node.fragment.nodes.length > 0) {
      statements.push(stmt(call("$.validate_void_dynamic_element", get_tag)));
    }
    statements.push(stmt(call("$.validate_dynamic_element_tag", get_tag)));
  }
  const location2 = dev && locator(node.start);
  statements.push(
    stmt(
      call(
        "$.element",
        context.state.node,
        get_tag,
        node.metadata.svg || node.metadata.mathml ? true_instance : false_instance,
        inner.length > 0 && arrow([element_id, id("$$anchor")], block(inner)),
        dynamic_namespace && thunk(build_attribute_value2(dynamic_namespace, context).value),
        location2 && array([literal2(location2.line), literal2(location2.column)])
      )
    )
  );
  if (is_async) {
    context.state.init.push(
      stmt(
        call(
          "$.async",
          context.state.node,
          node.metadata.expression.blockers(),
          array([thunk(expression, node.metadata.expression.has_await)]),
          arrow([context.state.node, id("$$tag")], block(statements))
        )
      )
    );
  } else {
    context.state.init.push(statements.length === 1 ? statements[0] : block(statements));
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteFragment.js
function SvelteFragment3(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      context.visit(attribute);
    }
  }
  context.state.init.push(.../** @type {BlockStatement} */
  context.visit(node.fragment).body);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteBoundary.js
function SvelteBoundary3(node, context) {
  const props = object([]);
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" || attribute.value === true) {
      continue;
    }
    const chunk = Array.isArray(attribute.value) ? (
      /** @type {AST.ExpressionTag} */
      attribute.value[0]
    ) : attribute.value;
    const expression = (
      /** @type {Expression} */
      context.visit(chunk.expression, context.state)
    );
    if (chunk.metadata.expression.has_state) {
      props.properties.push(get(attribute.name, [return_builder(expression)]));
    } else {
      props.properties.push(init(attribute.name, expression));
    }
  }
  const nodes = [];
  const const_tags = [];
  const hoisted = [];
  let has_const = false;
  for (const child of node.fragment.nodes) {
    if (child.type === "ConstTag") {
      has_const = true;
      if (!context.state.options.experimental.async) {
        context.visit(child, {
          ...context.state,
          consts: const_tags,
          scope: context.state.scopes.get(node.fragment) ?? context.state.scope
        });
      }
    }
  }
  for (const child of node.fragment.nodes) {
    if (child.type === "ConstTag") {
      if (context.state.options.experimental.async) {
        nodes.push(child);
      }
      continue;
    }
    if (child.type === "SnippetBlock") {
      if (context.state.options.experimental.async && has_const && !["failed", "pending"].includes(child.expression.name)) {
        nodes.push(child);
      } else {
        const statements = [];
        context.visit(child, { ...context.state, init: statements });
        const snippet = (
          /** @type {VariableDeclaration} */
          statements[0]
        );
        const snippet_fn = dev ? (
          // @ts-expect-error we know this shape is correct
          snippet.declarations[0].init.arguments[1]
        ) : snippet.declarations[0].init;
        if (!context.state.options.experimental.async) {
          snippet_fn.body.body.unshift(
            ...const_tags.filter((node2) => node2.type === "VariableDeclaration")
          );
        }
        if (["failed", "pending"].includes(child.expression.name)) {
          props.properties.push(prop("init", child.expression, child.expression));
        }
        hoisted.push(snippet);
      }
      continue;
    }
    nodes.push(child);
  }
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(
      { ...node.fragment, nodes },
      // Since we're creating a new fragment the reference in scopes can't match, so we gotta attach the right scope manually
      { ...context.state, scope: context.state.scopes.get(node.fragment) ?? context.state.scope }
    )
  );
  if (!context.state.options.experimental.async) {
    block2.body.unshift(...const_tags);
  }
  const boundary = stmt(
    call("$.boundary", context.state.node, props, arrow([id("$$anchor")], block2))
  );
  context.state.template.push_comment();
  context.state.init.push(hoisted.length > 0 ? block([...hoisted, boundary]) : boundary);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteHead.js
function SvelteHead3(node, context) {
  context.state.init.push(
    stmt(
      call(
        "$.head",
        literal2(hash(filename)),
        arrow(
          [id("$$anchor")],
          /** @type {BlockStatement} */
          context.visit(node.fragment)
        )
      )
    )
  );
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteSelf.js
function SvelteSelf3(node, context) {
  const component = build_component(node, context.state.analysis.name, context);
  context.state.init.push(component);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteWindow.js
function SvelteWindow2(node, context) {
  visit_special_element(node, "$.window", context);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/TitleElement.js
function TitleElement3(node, context) {
  const memoizer = new Memoizer();
  const { has_state, value } = build_template_chunk(
    /** @type {any} */
    node.fragment.nodes,
    context,
    context.state,
    (value2, metadata) => memoizer.add(value2, metadata)
  );
  const evaluated = context.state.scope.evaluate(value);
  const statement = stmt(
    assignment(
      "=",
      id("$.document.title"),
      evaluated.is_known ? literal2(evaluated.value) : evaluated.is_defined ? value : logical("??", value, literal2(""))
    )
  );
  if (has_state) {
    context.state.after_update.push(
      stmt(
        call(
          "$.deferred_template_effect",
          arrow(memoizer.apply(), block([statement])),
          memoizer.sync_values(),
          memoizer.async_values(),
          memoizer.blockers()
        )
      )
    );
  } else {
    context.state.after_update.push(stmt(call("$.effect", thunk(block([statement])))));
  }
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/TransitionDirective.js
function TransitionDirective2(node, context) {
  let flags = node.modifiers.includes("global") ? TRANSITION_GLOBAL : 0;
  if (node.intro) flags |= TRANSITION_IN;
  if (node.outro) flags |= TRANSITION_OUT;
  const args = [
    literal2(flags),
    context.state.node,
    thunk(
      /** @type {Expression} */
      context.visit(parse_directive_name(node.name))
    )
  ];
  if (node.expression) {
    args.push(thunk(
      /** @type {Expression} */
      context.visit(node.expression)
    ));
  }
  let statement = stmt(call("$.transition", ...args));
  if (node.metadata.expression.is_async()) {
    statement = stmt(
      call(
        "$.run_after_blockers",
        node.metadata.expression.blockers(),
        thunk(block([statement]))
      )
    );
  }
  context.state.after_update.push(statement);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/UpdateExpression.js
function UpdateExpression3(node, context) {
  const argument = node.argument;
  if (argument.type === "MemberExpression" && argument.object.type === "ThisExpression" && argument.property.type === "PrivateIdentifier" && context.state.state_fields.has("#" + argument.property.name)) {
    let fn = "$.update";
    if (node.prefix) fn += "_pre";
    const args = [argument];
    if (node.operator === "--") {
      args.push(literal2(-1));
    }
    return call(fn, ...args);
  }
  if (argument.type !== "Identifier" && argument.type !== "MemberExpression") {
    throw new Error("An impossible state was reached");
  }
  const left = object2(argument);
  const transformers = left && context.state.transform[left.name];
  if (left === argument && transformers?.update) {
    return transformers.update(node);
  }
  let update2 = (
    /** @type {Expression} */
    context.next()
  );
  if (left && transformers?.mutate) {
    update2 = transformers.mutate(
      left,
      /** @type {AssignmentExpression | UpdateExpression} */
      update2
    );
  }
  return validate_mutation(node, context, update2);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/UseDirective.js
function UseDirective2(node, context) {
  const params = [id("$$node")];
  if (node.expression) {
    params.push(id("$$action_arg"));
  }
  const args = [
    context.state.node,
    arrow(
      params,
      maybe_call(
        /** @type {Expression} */
        context.visit(parse_directive_name(node.name)),
        ...params
      )
    )
  ];
  if (node.expression) {
    args.push(thunk(
      /** @type {Expression} */
      context.visit(node.expression)
    ));
  }
  let statement = stmt(call("$.action", ...args));
  if (node.metadata.expression.is_async()) {
    statement = stmt(
      call(
        "$.run_after_blockers",
        node.metadata.expression.blockers(),
        thunk(block([statement]))
      )
    );
  }
  context.state.init.push(statement);
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AttachTag.js
function AttachTag2(node, context) {
  const expression = build_expression(context, node.expression, node.metadata.expression);
  let statement = stmt(call("$.attach", context.state.node, thunk(expression)));
  if (node.metadata.expression.is_async()) {
    statement = stmt(
      call(
        "$.run_after_blockers",
        node.metadata.expression.blockers(),
        thunk(block([statement]))
      )
    );
  }
  context.state.init.push(statement);
  context.next();
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/visitors/VariableDeclaration.js
function VariableDeclaration2(node, context) {
  const declarations = [];
  if (context.state.analysis.runes) {
    for (const declarator2 of node.declarations) {
      const init3 = (
        /** @type {Expression} */
        declarator2.init
      );
      const rune = get_rune(init3, context.state.scope);
      if (!rune || rune === "$effect.tracking" || rune === "$effect.root" || rune === "$inspect" || rune === "$inspect.trace" || rune === "$state.snapshot" || rune === "$host") {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (rune === "$props.id") {
        continue;
      }
      if (rune === "$props") {
        const seen2 = ["$$slots", "$$events", "$$legacy"];
        if (context.state.analysis.custom_element) {
          seen2.push("$$host");
        }
        if (declarator2.id.type === "Identifier") {
          const args2 = [id("$$props"), array(seen2.map((name) => literal2(name)))];
          if (dev) {
            args2.push(literal2(declarator2.id.name));
          }
          declarations.push(declarator(declarator2.id, call("$.rest_props", ...args2)));
        } else {
          equal(declarator2.id.type, "ObjectPattern");
          for (const property of declarator2.id.properties) {
            if (property.type === "Property") {
              const key2 = (
                /** @type {Identifier | Literal} */
                property.key
              );
              const name = key2.type === "Identifier" ? key2.name : (
                /** @type {string} */
                key2.value
              );
              seen2.push(name);
              let id2 = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
              equal(id2.type, "Identifier");
              const binding = (
                /** @type {Binding} */
                context.state.scope.get(id2.name)
              );
              let initial = binding.initial && /** @type {Expression} */
              context.visit(binding.initial);
              if (initial && binding.kind === "bindable_prop" && should_proxy(initial, context.state.scope)) {
                initial = call("$.proxy", initial);
                if (dev) {
                  initial = call("$.tag_proxy", initial, literal2(id2.name));
                }
              }
              if (is_prop_source(binding, context.state)) {
                declarations.push(
                  declarator(id2, get_prop_source(binding, context.state, name, initial))
                );
              }
            } else {
              const args2 = [id("$$props"), array(seen2.map((name) => literal2(name)))];
              if (dev) {
                args2.push(literal2(
                  /** @type {Identifier} */
                  property.argument.name
                ));
              }
              declarations.push(declarator(property.argument, call("$.rest_props", ...args2)));
            }
          }
        }
        continue;
      }
      const args = (
        /** @type {CallExpression} */
        init3.arguments
      );
      const value = (
        /** @type {Expression} */
        args[0] ?? void0
      );
      if (rune === "$state" || rune === "$state.raw") {
        const create_state_declarator = (id2, value2) => {
          const binding = (
            /** @type {import('#compiler').Binding} */
            context.state.scope.get(id2.name)
          );
          const is_state = is_state_source(binding, context.state.analysis);
          const is_proxy = should_proxy(value2, context.state.scope);
          if (rune === "$state" && is_proxy) {
            value2 = call("$.proxy", value2);
            if (dev && !is_state) {
              value2 = call("$.tag_proxy", value2, literal2(id2.name));
            }
          }
          if (is_state) {
            value2 = call("$.state", value2);
            if (dev) {
              value2 = call("$.tag", value2, literal2(id2.name));
            }
          }
          return value2;
        };
        if (declarator2.id.type === "Identifier") {
          const expression = (
            /** @type {Expression} */
            context.visit(value)
          );
          declarations.push(
            declarator(declarator2.id, create_state_declarator(declarator2.id, expression))
          );
        } else {
          const tmp = id(context.state.scope.generate("tmp"));
          const { inserts, paths } = extract_paths(declarator2.id, tmp);
          declarations.push(
            declarator(
              tmp,
              /** @type {Expression} */
              context.visit(value)
            ),
            ...inserts.map(({ id: id2, value: value2 }) => {
              id2.name = context.state.scope.generate("$$array");
              context.state.transform[id2.name] = { read: get_value };
              const expression = (
                /** @type {Expression} */
                context.visit(thunk(value2))
              );
              let call2 = call("$.derived", expression);
              if (dev) {
                const label = `[$state ${declarator2.id.type === "ArrayPattern" ? "iterable" : "object"}]`;
                call2 = call("$.tag", call2, literal2(label));
              }
              return declarator(id2, call2);
            }),
            ...paths.map((path) => {
              const value2 = (
                /** @type {Expression} */
                context.visit(path.expression)
              );
              const binding = context.state.scope.get(
                /** @type {Identifier} */
                path.node.name
              );
              return declarator(
                path.node,
                binding?.kind === "state" || binding?.kind === "raw_state" ? create_state_declarator(binding.node, value2) : value2
              );
            })
          );
        }
        continue;
      }
      if (rune === "$derived" || rune === "$derived.by") {
        const is_async = context.state.analysis.async_deriveds.has(
          /** @type {CallExpression} */
          init3
        );
        const should_save = context.state.is_instance && context.state.scope.function_depth > 1;
        if (declarator2.id.type === "Identifier") {
          let expression = (
            /** @type {Expression} */
            context.visit(value)
          );
          if (is_async) {
            const location2 = dev && !is_ignored(init3, "await_waterfall") && locate_node(init3);
            let call2 = call(
              "$.async_derived",
              thunk(expression, true),
              location2 ? literal2(location2) : void 0
            );
            call2 = should_save ? save(call2) : await_builder(call2);
            if (dev) call2 = call("$.tag", call2, literal2(declarator2.id.name));
            declarations.push(declarator(declarator2.id, call2));
          } else {
            if (rune === "$derived") expression = thunk(expression);
            let call2 = call("$.derived", expression);
            if (dev) call2 = call("$.tag", call2, literal2(declarator2.id.name));
            declarations.push(declarator(declarator2.id, call2));
          }
        } else {
          const init4 = (
            /** @type {CallExpression} */
            declarator2.init
          );
          let expression = (
            /** @type {Expression} */
            context.visit(value)
          );
          let rhs = value;
          if (rune !== "$derived" || init4.arguments[0].type !== "Identifier") {
            const id2 = id(context.state.scope.generate("$$d"));
            let call2 = call("$.derived", rune === "$derived" ? thunk(expression) : expression);
            rhs = call("$.get", id2);
            if (is_async) {
              const location2 = dev && !is_ignored(init4, "await_waterfall") && locate_node(init4);
              call2 = call(
                "$.async_derived",
                thunk(expression, true),
                location2 ? literal2(location2) : void 0
              );
              call2 = should_save ? save(call2) : await_builder(call2);
            }
            if (dev) {
              const label = `[$derived ${declarator2.id.type === "ArrayPattern" ? "iterable" : "object"}]`;
              call2 = call("$.tag", call2, literal2(label));
            }
            declarations.push(declarator(id2, call2));
          }
          const { inserts, paths } = extract_paths(declarator2.id, rhs);
          for (const { id: id2, value: value2 } of inserts) {
            id2.name = context.state.scope.generate("$$array");
            context.state.transform[id2.name] = { read: get_value };
            const expression2 = (
              /** @type {Expression} */
              context.visit(thunk(value2))
            );
            let call2 = call("$.derived", expression2);
            if (dev) {
              const label = `[$derived ${declarator2.id.type === "ArrayPattern" ? "iterable" : "object"}]`;
              call2 = call("$.tag", call2, literal2(label));
            }
            declarations.push(declarator(id2, call2));
          }
          for (const path of paths) {
            const expression2 = (
              /** @type {Expression} */
              context.visit(path.expression)
            );
            const call2 = call("$.derived", thunk(expression2));
            declarations.push(
              declarator(
                path.node,
                dev ? call("$.tag", call2, literal2(
                  /** @type {Identifier} */
                  path.node.name
                )) : call2
              )
            );
          }
        }
        continue;
      }
    }
  } else {
    for (const declarator2 of node.declarations) {
      const bindings = (
        /** @type {Binding[]} */
        context.state.scope.get_bindings(declarator2)
      );
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = id(context.state.scope.generate("tmp"));
          const { inserts, paths } = extract_paths(declarator2.id, tmp);
          declarations.push(
            declarator(
              tmp,
              /** @type {Expression} */
              context.visit(
                /** @type {Expression} */
                declarator2.init
              )
            )
          );
          for (const { id: id2, value } of inserts) {
            id2.name = context.state.scope.generate("$$array");
            context.state.transform[id2.name] = { read: get_value };
            const expression = (
              /** @type {Expression} */
              context.visit(thunk(value))
            );
            declarations.push(declarator(id2, call("$.derived", expression)));
          }
          for (const path of paths) {
            const name = (
              /** @type {Identifier} */
              path.node.name
            );
            const binding2 = (
              /** @type {Binding} */
              context.state.scope.get(name)
            );
            const value = (
              /** @type {Expression} */
              context.visit(path.expression)
            );
            declarations.push(
              declarator(
                path.node,
                binding2.kind === "bindable_prop" ? get_prop_source(binding2, context.state, binding2.prop_alias ?? name, value) : value
              )
            );
          }
          continue;
        }
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(declarator2.id.name)
        );
        declarations.push(
          declarator(
            declarator2.id,
            get_prop_source(
              binding,
              context.state,
              binding.prop_alias ?? declarator2.id.name,
              declarator2.init && /** @type {Expression} */
              context.visit(declarator2.init)
            )
          )
        );
        continue;
      }
      declarations.push(
        ...create_state_declarators2(
          declarator2,
          context,
          /** @type {Expression} */
          declarator2.init && context.visit(declarator2.init)
        )
      );
    }
  }
  if (declarations.length === 0) {
    return empty2;
  }
  return {
    ...node,
    declarations
  };
}
function create_state_declarators2(declarator2, context, value) {
  if (declarator2.id.type === "Identifier") {
    return [
      declarator(
        declarator2.id,
        call("$.mutable_source", value, context.state.analysis.immutable ? true_instance : void 0)
      )
    ];
  }
  const tmp = id(context.state.scope.generate("tmp"));
  const { inserts, paths } = extract_paths(declarator2.id, tmp);
  return [
    declarator(tmp, value),
    ...inserts.map(({ id: id2, value: value2 }) => {
      id2.name = context.state.scope.generate("$$array");
      context.state.transform[id2.name] = { read: get_value };
      const expression = (
        /** @type {Expression} */
        context.visit(thunk(value2))
      );
      return declarator(id2, call("$.derived", expression));
    }),
    ...paths.map((path) => {
      const value2 = (
        /** @type {Expression} */
        context.visit(path.expression)
      );
      const binding = context.state.scope.get(
        /** @type {Identifier} */
        path.node.name
      );
      return declarator(
        path.node,
        binding?.kind === "state" ? call("$.mutable_source", value2, context.state.analysis.immutable ? true_instance : void 0) : value2
      );
    })
  ];
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/client/transform-client.js
var visitors5 = {
  _: function set_scope2(node, { next: next2, state }) {
    const scope = state.scopes.get(node);
    if (scope && scope !== state.scope) {
      const transform = { ...state.transform };
      for (const [name, binding] of scope.declarations) {
        if (binding.kind === "normal" || // Reads of `$state(...)` declarations are not
        // transformed if they are never reassigned
        binding.kind === "state" && !is_state_source(binding, state.analysis)) {
          delete transform[name];
        }
      }
      next2({ ...state, transform, scope });
    } else {
      next2();
    }
  },
  AnimateDirective: AnimateDirective2,
  ArrowFunctionExpression: ArrowFunctionExpression2,
  AssignmentExpression: AssignmentExpression3,
  Attribute: Attribute2,
  AwaitBlock: AwaitBlock3,
  AwaitExpression: AwaitExpression3,
  BinaryExpression,
  BindDirective: BindDirective2,
  BlockStatement,
  BreakStatement,
  CallExpression: CallExpression3,
  ClassBody: ClassBody3,
  Comment,
  Component: Component3,
  ConstTag: ConstTag3,
  DebugTag: DebugTag3,
  EachBlock: EachBlock3,
  ExportNamedDeclaration: ExportNamedDeclaration2,
  ExpressionStatement: ExpressionStatement3,
  ForOfStatement,
  Fragment: Fragment3,
  FunctionDeclaration: FunctionDeclaration2,
  FunctionExpression: FunctionExpression2,
  HtmlTag: HtmlTag3,
  Identifier: Identifier3,
  IfBlock: IfBlock3,
  KeyBlock: KeyBlock3,
  LabeledStatement: LabeledStatement3,
  LetDirective: LetDirective2,
  MemberExpression: MemberExpression3,
  OnDirective: OnDirective2,
  Program: Program2,
  RegularElement: RegularElement3,
  RenderTag: RenderTag3,
  SlotElement: SlotElement3,
  SnippetBlock: SnippetBlock3,
  SpreadAttribute: SpreadAttribute3,
  SvelteBody: SvelteBody2,
  SvelteComponent: SvelteComponent3,
  SvelteDocument: SvelteDocument2,
  SvelteElement: SvelteElement3,
  SvelteFragment: SvelteFragment3,
  SvelteBoundary: SvelteBoundary3,
  SvelteHead: SvelteHead3,
  SvelteSelf: SvelteSelf3,
  SvelteWindow: SvelteWindow2,
  TitleElement: TitleElement3,
  TransitionDirective: TransitionDirective2,
  UpdateExpression: UpdateExpression3,
  UseDirective: UseDirective2,
  AttachTag: AttachTag2,
  VariableDeclaration: VariableDeclaration2
};
function client_component(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    is_instance: false,
    hoisted: [import_all("$", "svelte/internal/client"), ...analysis.instance_body.hoisted],
    node: (
      /** @type {any} */
      null
    ),
    // populated by the root node
    legacy_reactive_imports: [],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      namespace: options.namespace,
      bound_contenteditable: false
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: options.preserveWhitespace,
    state_fields: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false,
    instance_level_snippets: [],
    module_level_snippets: [],
    // these are set inside the `Fragment` visitor, and cannot be used until then
    init: (
      /** @type {any} */
      null
    ),
    consts: (
      /** @type {any} */
      null
    ),
    let_directives: (
      /** @type {any} */
      null
    ),
    update: (
      /** @type {any} */
      null
    ),
    after_update: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    ),
    memoizer: (
      /** @type {any} */
      null
    )
  };
  const module = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      visitors5
    )
  );
  const instance_state = {
    ...state,
    transform: { ...state.transform },
    scope: analysis.instance.scope,
    scopes: analysis.instance.scopes,
    is_instance: true
  };
  const instance = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.instance.ast,
      instance_state,
      visitors5
    )
  );
  const template2 = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.template.ast,
      {
        ...state,
        transform: instance_state.transform,
        scope: analysis.instance.scope,
        scopes: analysis.template.scopes
      },
      visitors5
    )
  );
  module.body.unshift(...state.legacy_reactive_imports);
  const store_setup = [];
  let store_init = empty2;
  const legacy_reactive_declarations = [];
  let needs_store_cleanup = false;
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "legacy_reactive") {
      legacy_reactive_declarations.push(
        const_builder(
          name,
          call("$.mutable_source", void 0, analysis.immutable ? true_instance : void 0)
        )
      );
    }
    if (binding.kind === "store_sub") {
      if (store_setup.length === 0) {
        needs_store_cleanup = true;
        store_init = const_builder(
          array_pattern([id("$$stores"), id("$$cleanup")]),
          call("$.setup_stores")
        );
      }
      const store_reference = build_getter(id(name.slice(1)), instance_state);
      const store_get = call("$.store_get", store_reference, literal2(name), id("$$stores"));
      store_setup.push(
        const_builder(
          binding.node,
          dev ? thunk(
            sequence([
              call("$.validate_store", store_reference, literal2(name.slice(1))),
              store_get
            ])
          ) : thunk(store_get)
        )
      );
    }
  }
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n2]) => n2 === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    instance.body.push(statement[1]);
  }
  if (analysis.reactive_statements.size > 0) {
    instance.body.push(stmt(call("$.legacy_pre_effect_reset")));
  }
  const group_binding_declarations = [];
  for (const group of analysis.binding_groups.values()) {
    group_binding_declarations.push(const_builder(group.name, array([])));
  }
  const component_returned_object = analysis.exports.flatMap(({ name, alias }) => {
    const binding = instance_state.scope.get(name);
    const expression = build_getter(id(name), instance_state);
    const getter = get(alias ?? name, [return_builder(expression)]);
    if (expression.type === "Identifier") {
      if (binding?.declaration_kind === "let" || binding?.declaration_kind === "var") {
        return [
          getter,
          set(alias ?? name, [stmt(assignment("=", expression, id("$$value")))])
        ];
      } else if (!dev) {
        return init(alias ?? name, expression);
      }
    }
    if (binding?.kind === "prop" || binding?.kind === "bindable_prop") {
      return [getter, set(alias ?? name, [stmt(call(name, id("$$value")))])];
    }
    if (binding?.kind === "state" || binding?.kind === "raw_state") {
      const value = binding.kind === "state" ? call("$.proxy", id("$$value")) : id("$$value");
      return [getter, set(alias ?? name, [stmt(call("$.set", id(name), value))])];
    }
    return getter;
  });
  const properties = [...analysis.instance.scope.declarations].filter(
    ([name, binding]) => (binding.kind === "prop" || binding.kind === "bindable_prop") && !name.startsWith("$$")
  );
  if (analysis.accessors) {
    for (const [name, binding] of properties) {
      const key2 = binding.prop_alias ?? name;
      const getter = get(key2, [return_builder(call(id(name)))]);
      const setter = set(key2, [
        stmt(call(id(name), id("$$value"))),
        stmt(call("$.flush"))
      ]);
      if (analysis.runes && binding.initial) {
        setter.value.params[0] = {
          type: "AssignmentPattern",
          left: id("$$value"),
          right: (
            /** @type {ESTree.Expression} */
            binding.initial
          )
        };
      }
      component_returned_object.push(getter, setter);
    }
  }
  if (options.compatibility.componentApi === 4) {
    component_returned_object.push(
      init("$set", id("$.update_legacy_props")),
      init(
        "$on",
        arrow(
          [id("$$event_name"), id("$$event_cb")],
          call(
            "$.add_legacy_event_listener",
            id("$$props"),
            id("$$event_name"),
            id("$$event_cb")
          )
        )
      )
    );
  } else if (dev) {
    component_returned_object.push(spread(call(id("$.legacy_api"))));
  }
  const push_args = [id("$$props"), literal2(analysis.runes)];
  if (dev) push_args.push(id(analysis.name));
  let component_block = block([
    store_init,
    ...legacy_reactive_declarations,
    ...group_binding_declarations
  ]);
  const should_inject_context = dev || analysis.needs_context || analysis.reactive_statements.size > 0 || component_returned_object.length > 0;
  component_block.body.push(
    ...state.instance_level_snippets,
    .../** @type {ESTree.Statement[]} */
    instance.body
  );
  if (should_inject_context && component_returned_object.length > 0) {
    component_block.body.push(var_builder("$$exports", object(component_returned_object)));
  }
  component_block.body.unshift(...store_setup);
  if (!analysis.runes && analysis.needs_context) {
    component_block.body.push(stmt(call("$.init", analysis.immutable ? true_instance : void 0)));
  }
  component_block.body.push(.../** @type {ESTree.Statement[]} */
  template2.body);
  if (analysis.needs_mutation_validation) {
    component_block.body.unshift(
      var_builder("$$ownership_validator", call("$.create_ownership_validator", id("$$props")))
    );
  }
  let should_inject_props = should_inject_context || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  component_block.loc = instance.loc;
  if (!analysis.runes) {
    for (const { name, alias } of analysis.exports) {
      component_block.body.push(
        stmt(
          call(
            "$.bind_prop",
            id("$$props"),
            literal2(alias ?? name),
            build_getter(id(name), instance_state)
          )
        )
      );
    }
  }
  if (analysis.css.ast !== null && analysis.inject_styles) {
    const hash2 = literal2(analysis.css.hash);
    const code = literal2(render_stylesheet(analysis.source, analysis, options).code);
    state.hoisted.push(const_builder("$$css", object([init("hash", hash2), init("code", code)])));
    component_block.body.unshift(
      stmt(call("$.append_styles", id("$$anchor"), id("$$css")))
    );
  }
  if (should_inject_context) {
    component_block.body.unshift(stmt(call("$.push", ...push_args)));
    let to_push;
    if (component_returned_object.length > 0) {
      let pop_call = call("$.pop", id("$$exports"));
      to_push = needs_store_cleanup ? var_builder("$$pop", pop_call) : return_builder(pop_call);
    } else {
      to_push = stmt(call("$.pop"));
    }
    component_block.body.push(to_push);
  }
  if (needs_store_cleanup) {
    component_block.body.push(stmt(call("$$cleanup")));
    if (component_returned_object.length > 0) {
      component_block.body.push(return_builder(id("$$pop")));
    }
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.legacy_rest_props",
          id("$$sanitized_props"),
          array(named_props.map((name) => literal2(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    const to_remove = [
      literal2("children"),
      literal2("$$slots"),
      literal2("$$events"),
      literal2("$$legacy")
    ];
    if (analysis.custom_element) {
      to_remove.push(literal2("$$host"));
    }
    component_block.body.unshift(
      const_builder(
        "$$sanitized_props",
        call("$.legacy_rest_props", id("$$props"), array(to_remove))
      )
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id("$$props"))));
  }
  const imports3 = [];
  let body = [];
  for (const entry of [...module.body, ...state.hoisted]) {
    if (entry.type === "ImportDeclaration") {
      imports3.push(entry);
    } else {
      body.push(entry);
    }
  }
  body = [...imports3, ...state.module_level_snippets, ...body];
  const component = function_declaration(
    id(analysis.name),
    should_inject_props ? [id("$$anchor"), id("$$props")] : [id("$$anchor")],
    component_block
  );
  if (options.hmr) {
    const id2 = id(analysis.name);
    const HMR2 = id("$.HMR");
    const existing = member(id2, HMR2, true);
    const incoming = member(id("module.default"), HMR2, true);
    const accept_fn_body = [
      stmt(assignment("=", member(incoming, "source"), member(existing, "source"))),
      stmt(call("$.set", member(existing, "source"), member(incoming, "original")))
    ];
    if (analysis.css.hash) {
      accept_fn_body.unshift(stmt(call("$.cleanup_styles", literal2(analysis.css.hash))));
    }
    const hmr = block([
      stmt(assignment("=", id2, call("$.hmr", id2, thunk(member(existing, "source"))))),
      stmt(call("import.meta.hot.accept", arrow([id("module")], block(accept_fn_body))))
    ]);
    body.push(component, if_builder(id("import.meta.hot"), hmr), export_default(id(analysis.name)));
  } else {
    body.push(export_default(component));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id(analysis.name), "$.FILENAME", true), literal2(filename))
      )
    );
  }
  if (options.experimental.async) {
    body.unshift(imports2([], "svelte/internal/flags/async"));
  }
  if (!analysis.runes) {
    body.unshift(imports2([], "svelte/internal/flags/legacy"));
  }
  if (analysis.tracing) {
    body.unshift(imports2([], "svelte/internal/flags/tracing"));
  }
  if (options.discloseVersion) {
    body.unshift(imports2([], "svelte/internal/disclose-version"));
  }
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports2([["createClassComponent", "$$_createClassComponent"]], "svelte/legacy"));
    component_block.body.unshift(
      if_builder(
        id("new.target"),
        return_builder(
          call(
            "$$_createClassComponent",
            // When called with new, the first argument is the constructor options
            object([init("component", id(analysis.name)), spread(id("$$anchor"))])
          )
        )
      )
    );
  } else if (dev) {
    component_block.body.unshift(stmt(call("$.check_target", id("new.target"))));
  }
  if (analysis.props_id) {
    component_block.body.unshift(const_builder(analysis.props_id, call("$.props_id")));
  }
  if (state.events.size > 0) {
    body.push(
      stmt(call("$.delegate", array(Array.from(state.events).map((name) => literal2(name)))))
    );
  }
  const ce = options.customElementOptions ?? options.customElement;
  if (ce) {
    const ce_props = typeof ce === "boolean" ? {} : ce.props || {};
    const props_str = [];
    for (const [name, prop_def2] of Object.entries(ce_props)) {
      const binding = analysis.instance.scope.get(name);
      const key2 = binding?.prop_alias ?? name;
      if (!prop_def2.type && binding?.initial?.type === "Literal" && typeof binding?.initial.value === "boolean") {
        prop_def2.type = "Boolean";
      }
      const value = object(
        /** @type {ESTree.Property[]} */
        [
          prop_def2.attribute ? init("attribute", literal2(prop_def2.attribute)) : void 0,
          prop_def2.reflect ? init("reflect", true_instance) : void 0,
          prop_def2.type ? init("type", literal2(prop_def2.type)) : void 0
        ].filter(Boolean)
      );
      props_str.push(init(key2, value));
    }
    for (const [name, binding] of properties) {
      const key2 = binding.prop_alias ?? name;
      if (ce_props[key2]) continue;
      props_str.push(init(key2, object([])));
    }
    const slots_str = array([...analysis.slot_names.keys()].map((name) => literal2(name)));
    const accessors_str = array(
      analysis.exports.map(({ name, alias }) => literal2(alias ?? name))
    );
    const use_shadow_dom = typeof ce === "boolean" || ce.shadow !== "none" ? true : false;
    const create_ce = call(
      "$.create_custom_element",
      id(analysis.name),
      object(props_str),
      slots_str,
      accessors_str,
      literal2(use_shadow_dom),
      /** @type {any} */
      typeof ce !== "boolean" ? ce.extend : void 0
    );
    if (typeof ce !== "boolean" && typeof ce.tag === "string") {
      const define2 = stmt(call("customElements.define", literal2(ce.tag), create_ce));
      if (options.hmr) {
        body.push(
          if_builder(binary("==", call("customElements.get", literal2(ce.tag)), null_instance), define2)
        );
      } else {
        body.push(define2);
      }
    } else {
      body.push(stmt(create_ce));
    }
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/phases/3-transform/index.js
function transform_component(analysis, source2, options) {
  if (options.generate === false) {
    return {
      js: (
        /** @type {any} */
        null
      ),
      css: null,
      warnings,
      // set afterwards
      metadata: {
        runes: analysis.runes
      },
      ast: (
        /** @type {any} */
        null
      )
      // set afterwards
    };
  }
  const program = options.generate === "server" ? server_component(analysis, options) : client_component(analysis, options);
  const js_source_name = get_source_name(options.filename, options.outputFilename, "input.svelte");
  const js2 = print(
    /** @type {Node} */
    program,
    ts_default({ comments: analysis.comments }),
    {
      // include source content; makes it easier/more robust looking up the source map code
      // (else esrap does return null for source and sourceMapContent which may trip up tooling)
      sourceMapContent: source2,
      sourceMapSource: js_source_name
    }
  );
  merge_with_preprocessor_map(js2, options, js_source_name);
  const css = analysis.css.ast && !analysis.inject_styles ? render_stylesheet(source2, analysis, options) : null;
  return {
    js: js2,
    css,
    warnings,
    // set afterwards. TODO apply preprocessor sourcemap
    metadata: {
      runes: analysis.runes
    },
    ast: (
      /** @type {any} */
      null
    )
    // set afterwards
  };
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/validate-options.js
var common_options = {
  filename: string("(unknown)"),
  // default to process.cwd() where it exists to replicate svelte4 behavior (and make Deno work with this as well)
  // see https://github.com/sveltejs/svelte/blob/b62fc8c8fd2640c9b99168f01b9d958cb2f7574f/packages/svelte/src/compiler/compile/Component.js#L211
  /* eslint-disable */
  rootDir: string(
    typeof process !== "undefined" ? process.cwd?.() : (
      // @ts-expect-error
      typeof Deno !== "undefined" ? (
        // @ts-expect-error
        Deno.cwd()
      ) : void 0
    )
  ),
  /* eslint-enable */
  dev: boolean(false),
  generate: validator("client", (input, keypath) => {
    if (input === "dom" || input === "ssr") {
      warn_once(options_renamed_ssr_dom);
      return input === "dom" ? "client" : "server";
    }
    if (input !== "client" && input !== "server" && input !== false) {
      throw_error2(`${keypath} must be "client", "server" or false`);
    }
    return input;
  }),
  warningFilter: fun(() => true),
  experimental: object3({
    async: boolean(false)
  })
};
var component_options = {
  accessors: deprecate(options_deprecated_accessors, boolean(false)),
  css: validator("external", (input) => {
    if (input === true || input === false) {
      throw_error2(
        'The boolean options have been removed from the css option. Use "external" instead of false and "injected" instead of true'
      );
    }
    if (input === "none") {
      throw_error2(
        'css: "none" is no longer a valid option. If this was crucial for you, please open an issue on GitHub with your use case.'
      );
    }
    if (input !== "external" && input !== "injected") {
      throw_error2(`css should be either "external" (default, recommended) or "injected"`);
    }
    return input;
  }),
  cssHash: fun(({ css, filename: filename2, hash: hash2 }) => {
    return `svelte-${hash2(filename2 === "(unknown)" ? css : filename2 ?? css)}`;
  }),
  // TODO this is a sourcemap option, would be good to put under a sourcemap namespace
  cssOutputFilename: string(void 0),
  customElement: boolean(false),
  discloseVersion: boolean(true),
  immutable: deprecate(options_deprecated_immutable, boolean(false)),
  legacy: removed(
    "The legacy option has been removed. If you are using this because of legacy.componentApi, use compatibility.componentApi instead"
  ),
  compatibility: object3({
    componentApi: list2([4, 5], 5)
  }),
  loopGuardTimeout: warn_removed(options_removed_loop_guard_timeout),
  name: string(void 0),
  namespace: list2(["html", "mathml", "svg"]),
  modernAst: boolean(false),
  outputFilename: string(void 0),
  preserveComments: boolean(false),
  fragments: list2(["html", "tree"]),
  preserveWhitespace: boolean(false),
  runes: boolean(void 0),
  hmr: boolean(false),
  sourcemap: validator(void 0, (input) => {
    return input;
  }),
  enableSourcemap: warn_removed(options_removed_enable_sourcemap),
  hydratable: warn_removed(options_removed_hydratable),
  format: removed(
    'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)'
  ),
  tag: removed(
    'The tag option has been removed in Svelte 5. Use `<svelte:options customElement="tag-name" />` inside the component instead. If that does not solve your use case, please open an issue on GitHub with details.'
  ),
  sveltePath: removed(
    "The sveltePath option has been removed in Svelte 5. If this option was crucial for you, please open an issue on GitHub with your use case."
  ),
  // These two were primarily created for svelte-preprocess (https://github.com/sveltejs/svelte/pull/6194),
  // but with new TypeScript compilation modes strictly separating types it's not necessary anymore
  errorMode: removed(
    "The errorMode option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
  ),
  varsReport: removed(
    "The vars option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
  )
};
var validate_module_options = (
  /** @type {Validator<ModuleCompileOptions, ValidatedModuleCompileOptions>} */
  object3({
    ...common_options,
    ...Object.fromEntries(Object.keys(component_options).map((key2) => [key2, () => {
    }]))
  })
);
var validate_component_options = (
  /** @type {Validator<CompileOptions, ValidatedCompileOptions>} */
  object3({
    ...common_options,
    ...component_options
  })
);
function removed(msg) {
  return (input) => {
    if (input !== void 0) {
      options_removed(null, msg);
    }
    return (
      /** @type {any} */
      void 0
    );
  };
}
var warned2 = /* @__PURE__ */ new Set();
function warn_once(fn) {
  if (!warned2.has(fn)) {
    warned2.add(fn);
    fn(null);
  }
}
function warn_removed(fn) {
  return (input) => {
    if (input !== void 0) warn_once(fn);
    return (
      /** @type {any} */
      void 0
    );
  };
}
function deprecate(fn, validator2) {
  return (input, keypath) => {
    if (input !== void 0) warn_once(fn);
    return validator2(input, keypath);
  };
}
function object3(children, allow_unknown = false) {
  return (input, keypath) => {
    const output = {};
    if (input && typeof input !== "object" || Array.isArray(input)) {
      throw_error2(`${keypath} should be an object`);
    }
    for (const key2 in input) {
      if (!(key2 in children)) {
        if (allow_unknown) {
          output[key2] = input[key2];
        } else {
          options_unrecognised(null, `${keypath ? `${keypath}.${key2}` : key2}`);
        }
      }
    }
    for (const key2 in children) {
      const validator2 = children[key2];
      output[key2] = validator2(input && input[key2], keypath ? `${keypath}.${key2}` : key2);
    }
    return output;
  };
}
function validator(fallback, fn) {
  return (input, keypath) => {
    return input === void 0 ? fallback : fn(input, keypath);
  };
}
function string(fallback, allow_empty = true) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "string") {
      throw_error2(`${keypath} should be a string, if specified`);
    }
    if (!allow_empty && input === "") {
      throw_error2(`${keypath} cannot be empty`);
    }
    return input;
  });
}
function boolean(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "boolean") {
      throw_error2(`${keypath} should be true or false, if specified`);
    }
    return input;
  });
}
function list2(options, fallback = options[0]) {
  return validator(fallback, (input, keypath) => {
    if (!options.includes(input)) {
      const msg = options.length > 2 ? `${keypath} should be one of ${options.slice(0, -1).map((input2) => `"${input2}"`).join(", ")} or "${options[options.length - 1]}"` : `${keypath} should be either "${options[0]}" or "${options[1]}"`;
      throw_error2(msg);
    }
    return input;
  });
}
function fun(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "function") {
      throw_error2(`${keypath} should be a function, if specified`);
    }
    return input;
  });
}
function throw_error2(msg) {
  options_invalid_value(null, msg);
}

// node_modules/.deno/svelte@5.43.14/node_modules/svelte/src/compiler/index.js
function compile(source2, options) {
  source2 = remove_bom(source2);
  reset({ warning: options.warningFilter, filename: options.filename });
  const validated = validate_component_options(options, "");
  let parsed = parse5(source2);
  const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};
  const combined_options = {
    ...validated,
    ...parsed_options,
    customElementOptions
  };
  if (parsed.metadata.ts) {
    parsed = {
      ...parsed,
      fragment: parsed.fragment && remove_typescript_nodes(parsed.fragment),
      instance: parsed.instance && remove_typescript_nodes(parsed.instance),
      module: parsed.module && remove_typescript_nodes(parsed.module)
    };
    if (combined_options.customElementOptions?.extend) {
      combined_options.customElementOptions.extend = remove_typescript_nodes(
        combined_options.customElementOptions?.extend
      );
    }
  }
  const analysis = analyze_component(parsed, source2, combined_options);
  const result = transform_component(analysis, source2, combined_options);
  result.ast = to_public_ast(source2, parsed, options.modernAst);
  return result;
}
function to_public_ast(source2, ast, modern) {
  if (modern) {
    const clean = (node) => {
      delete node.metadata;
    };
    ast.options?.attributes.forEach((attribute) => {
      clean(attribute);
      clean(attribute.value);
      if (Array.isArray(attribute.value)) {
        attribute.value.forEach(clean);
      }
    });
    return walk(ast, null, {
      _(node, { next: next2 }) {
        clean(node);
        next2();
      }
    });
  }
  return convert(source2, ast);
}
function remove_bom(source2) {
  if (source2.charCodeAt(0) === 65279) {
    return source2.slice(1);
  }
  return source2;
}

// node_modules/.deno/es-module-lexer@1.7.0/node_modules/es-module-lexer/dist/lexer.js
var ImportType;
!(function(A2) {
  A2[A2.Static = 1] = "Static", A2[A2.Dynamic = 2] = "Dynamic", A2[A2.ImportMeta = 3] = "ImportMeta", A2[A2.StaticSourcePhase = 4] = "StaticSourcePhase", A2[A2.DynamicSourcePhase = 5] = "DynamicSourcePhase", A2[A2.StaticDeferPhase = 6] = "StaticDeferPhase", A2[A2.DynamicDeferPhase = 7] = "DynamicDeferPhase";
})(ImportType || (ImportType = {}));
var A = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
function parse7(E2, g = "@") {
  if (!C) return init2.then((() => parse7(E2)));
  const I2 = E2.length + 1, w2 = (C.__heap_base.value || C.__heap_base) + 4 * I2 - C.memory.buffer.byteLength;
  w2 > 0 && C.memory.grow(Math.ceil(w2 / 65536));
  const K2 = C.sa(I2 - 1);
  if ((A ? B : Q2)(E2, new Uint16Array(C.memory.buffer, K2, I2)), !C.parse()) throw Object.assign(new Error(`Parse error ${g}:${E2.slice(0, C.e()).split("\n").length}:${C.e() - E2.lastIndexOf("\n", C.e() - 1)}`), { idx: C.e() });
  const o = [], D = [];
  for (; C.ri(); ) {
    const A2 = C.is(), Q3 = C.ie(), B2 = C.it(), g2 = C.ai(), I3 = C.id(), w3 = C.ss(), K3 = C.se();
    let D2;
    C.ip() && (D2 = k(E2.slice(-1 === I3 ? A2 - 1 : A2, -1 === I3 ? Q3 + 1 : Q3))), o.push({ n: D2, t: B2, s: A2, e: Q3, ss: w3, se: K3, d: I3, a: g2 });
  }
  for (; C.re(); ) {
    const A2 = C.es(), Q3 = C.ee(), B2 = C.els(), g2 = C.ele(), I3 = E2.slice(A2, Q3), w3 = I3[0], K3 = B2 < 0 ? void 0 : E2.slice(B2, g2), o2 = K3 ? K3[0] : "";
    D.push({ s: A2, e: Q3, ls: B2, le: g2, n: '"' === w3 || "'" === w3 ? k(I3) : I3, ln: '"' === o2 || "'" === o2 ? k(K3) : K3 });
  }
  function k(A2) {
    try {
      return (0, eval)(A2);
    } catch (A3) {
    }
  }
  return [o, D, !!C.f(), !!C.ms()];
}
function Q2(A2, Q3) {
  const B2 = A2.length;
  let C2 = 0;
  for (; C2 < B2; ) {
    const B3 = A2.charCodeAt(C2);
    Q3[C2++] = (255 & B3) << 8 | B3 >>> 8;
  }
}
function B(A2, Q3) {
  const B2 = A2.length;
  let C2 = 0;
  for (; C2 < B2; ) Q3[C2] = A2.charCodeAt(C2++);
}
var C;
var E = () => {
  return A2 = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKzkQwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQuFDAEKf0EAQQAoArAKIgBBDGoiATYCsApBARApIQJBACgCsAohAwJAAkACQAJAAkACQAJAAkAgAkEuRw0AQQAgA0ECajYCsAoCQEEBECkiAkHkAEYNAAJAIAJB8wBGDQAgAkHtAEcNB0EAKAKwCiICQQJqQZwIQQYQLw0HAkBBACgCnAoiAxAqDQAgAy8BAEEuRg0ICyAAIAAgAkEIakEAKALUCRABDwtBACgCsAoiAkECakGiCEEKEC8NBgJAQQAoApwKIgMQKg0AIAMvAQBBLkYNBwtBACEEQQAgAkEMajYCsApBASEFQQUhBkEBECkhAkEAIQdBASEIDAILQQAoArAKIgIpAAJC5YCYg9CMgDlSDQUCQEEAKAKcCiIDECoNACADLwEAQS5GDQYLQQAhBEEAIAJBCmo2ArAKQQIhCEEHIQZBASEHQQEQKSECQQEhBQwBCwJAAkACQAJAIAJB8wBHDQAgAyABTQ0AIANBAmpBoghBChAvDQACQCADLwEMIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAgsgBEGgAUYNAQtBACEHQQchBkEBIQQgAkHkAEYNAQwCC0EAIQRBACADQQxqIgI2ArAKQQEhBUEBECkhCQJAQQAoArAKIgYgAkYNAEHmACECAkAgCUHmAEYNAEEFIQZBACEHQQEhCCAJIQIMBAtBACEHQQEhCCAGQQJqQawIQQYQLw0EIAYvAQgQIEUNBAtBACEHQQAgAzYCsApBByEGQQEhBEEAIQVBACEIIAkhAgwCCyADIABBCmpNDQBBACEIQeQAIQICQCADKQACQuWAmIPQjIA5Ug0AAkACQCADLwEKIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAQtBACEIIARBoAFHDQELQQAhBUEAIANBCmo2ArAKQSohAkEBIQdBAiEIQQEQKSIJQSpGDQRBACADNgKwCkEBIQRBACEHQQAhCCAJIQIMAgsgAyEGQQAhBwwCC0EAIQVBACEICwJAIAJBKEcNAEEAKAKkCkEALwGYCiICQQN0aiIDQQAoArAKNgIEQQAgAkEBajsBmAogA0EFNgIAQQAoApwKLwEAQS5GDQRBAEEAKAKwCiIDQQJqNgKwCkEBECkhAiAAQQAoArAKQQAgAxABAkACQCAFDQBBACgC8AkhAQwBC0EAKALwCSIBIAY2AhwLQQBBAC8BlgoiA0EBajsBlgpBACgCqAogA0ECdGogATYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKwCkF+ajYCsAoPCyACEBpBAEEAKAKwCkECaiICNgKwCgJAAkACQEEBEClBV2oOBAECAgACC0EAQQAoArAKQQJqNgKwCkEBECkaQQAoAvAJIgMgAjYCBCADQQE6ABggA0EAKAKwCiICNgIQQQAgAkF+ajYCsAoPC0EAKALwCSIDIAI2AgQgA0EBOgAYQQBBAC8BmApBf2o7AZgKIANBACgCsApBAmo2AgxBAEEALwGWCkF/ajsBlgoPC0EAQQAoArAKQX5qNgKwCg8LAkAgBEEBcyACQfsAR3INAEEAKAKwCiECQQAvAZgKDQUDQAJAAkACQCACQQAoArQKTw0AQQEQKSICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKAKwCkECajYCsAoLQQEQKSEDQQAoArAKIQICQCADQeYARw0AIAJBAmpBrAhBBhAvDQcLQQAgAkEIajYCsAoCQEEBECkiAkEiRg0AIAJBJ0cNBwsgACACQQAQKw8LIAIQGgtBAEEAKAKwCkECaiICNgKwCgwACwsCQAJAIAJBWWoOBAMBAQMACyACQSJGDQILQQAoArAKIQYLIAYgAUcNAEEAIABBCmo2ArAKDwsgAkEqRyAHcQ0DQQAvAZgKQf//A3ENA0EAKAKwCiECQQAoArQKIQEDQCACIAFPDQECQAJAIAIvAQAiA0EnRg0AIANBIkcNAQsgACADIAgQKw8LQQAgAkECaiICNgKwCgwACwsQJQsPC0EAIAJBfmo2ArAKDwtBAEEAKAKwCkF+ajYCsAoLRwEDf0EAKAKwCkECaiEAQQAoArQKIQECQANAIAAiAkF+aiABTw0BIAJBAmohACACLwEAQXZqDgQBAAABAAsLQQAgAjYCsAoLmAEBA39BAEEAKAKwCiIBQQJqNgKwCiABQQZqIQFBACgCtAohAgNAAkACQAJAIAFBfGogAk8NACABQX5qLwEAIQMCQAJAIAANACADQSpGDQEgA0F2ag4EAgQEAgQLIANBKkcNAwsgAS8BAEEvRw0CQQAgAUF+ajYCsAoMAQsgAUF+aiEBC0EAIAE2ArAKDwsgAUECaiEBDAALC4gBAQR/QQAoArAKIQFBACgCtAohAgJAAkADQCABIgNBAmohASADIAJPDQEgAS8BACIEIABGDQICQCAEQdwARg0AIARBdmoOBAIBAQIBCyADQQRqIQEgAy8BBEENRw0AIANBBmogASADLwEGQQpGGyEBDAALC0EAIAE2ArAKECUPC0EAIAE2ArAKC2wBAX8CQAJAIABBX2oiAUEFSw0AQQEgAXRBMXENAQsgAEFGakH//wNxQQZJDQAgAEEpRyAAQVhqQf//A3FBB0lxDQACQCAAQaV/ag4EAQAAAQALIABB/QBHIABBhX9qQf//A3FBBElxDwtBAQsuAQF/QQEhAQJAIABBpglBBRAdDQAgAEGWCEEDEB0NACAAQbAJQQIQHSEBCyABC0YBA39BACEDAkAgACACQQF0IgJrIgRBAmoiAEEAKALcCSIFSQ0AIAAgASACEC8NAAJAIAAgBUcNAEEBDwsgBBAmIQMLIAMLgwEBAn9BASEBAkACQAJAAkACQAJAIAAvAQAiAkFFag4EBQQEAQALAkAgAkGbf2oOBAMEBAIACyACQSlGDQQgAkH5AEcNAyAAQX5qQbwJQQYQHQ8LIABBfmovAQBBPUYPCyAAQX5qQbQJQQQQHQ8LIABBfmpByAlBAxAdDwtBACEBCyABC7QDAQJ/QQAhAQJAAkACQAJAAkACQAJAAkACQAJAIAAvAQBBnH9qDhQAAQIJCQkJAwkJBAUJCQYJBwkJCAkLAkACQCAAQX5qLwEAQZd/ag4EAAoKAQoLIABBfGpByghBAhAdDwsgAEF8akHOCEEDEB0PCwJAAkACQCAAQX5qLwEAQY1/ag4DAAECCgsCQCAAQXxqLwEAIgJB4QBGDQAgAkHsAEcNCiAAQXpqQeUAECcPCyAAQXpqQeMAECcPCyAAQXxqQdQIQQQQHQ8LIABBfGpB3AhBBhAdDwsgAEF+ai8BAEHvAEcNBiAAQXxqLwEAQeUARw0GAkAgAEF6ai8BACICQfAARg0AIAJB4wBHDQcgAEF4akHoCEEGEB0PCyAAQXhqQfQIQQIQHQ8LIABBfmpB+AhBBBAdDwtBASEBIABBfmoiAEHpABAnDQQgAEGACUEFEB0PCyAAQX5qQeQAECcPCyAAQX5qQYoJQQcQHQ8LIABBfmpBmAlBBBAdDwsCQCAAQX5qLwEAIgJB7wBGDQAgAkHlAEcNASAAQXxqQe4AECcPCyAAQXxqQaAJQQMQHSEBCyABCzQBAX9BASEBAkAgAEF3akH//wNxQQVJDQAgAEGAAXJBoAFGDQAgAEEuRyAAEChxIQELIAELMAEBfwJAAkAgAEF3aiIBQRdLDQBBASABdEGNgIAEcQ0BCyAAQaABRg0AQQAPC0EBC04BAn9BACEBAkACQCAALwEAIgJB5QBGDQAgAkHrAEcNASAAQX5qQfgIQQQQHQ8LIABBfmovAQBB9QBHDQAgAEF8akHcCEEGEB0hAQsgAQveAQEEf0EAKAKwCiEAQQAoArQKIQECQAJAAkADQCAAIgJBAmohACACIAFPDQECQAJAAkAgAC8BACIDQaR/ag4FAgMDAwEACyADQSRHDQIgAi8BBEH7AEcNAkEAIAJBBGoiADYCsApBAEEALwGYCiICQQFqOwGYCkEAKAKkCiACQQN0aiICQQQ2AgAgAiAANgIEDwtBACAANgKwCkEAQQAvAZgKQX9qIgA7AZgKQQAoAqQKIABB//8DcUEDdGooAgBBA0cNAwwECyACQQRqIQAMAAsLQQAgADYCsAoLECULC3ABAn8CQAJAA0BBAEEAKAKwCiIAQQJqIgE2ArAKIABBACgCtApPDQECQAJAAkAgAS8BACIBQaV/ag4CAQIACwJAIAFBdmoOBAQDAwQACyABQS9HDQIMBAsQLhoMAQtBACAAQQRqNgKwCgwACwsQJQsLNQEBf0EAQQE6APwJQQAoArAKIQBBAEEAKAK0CkECajYCsApBACAAQQAoAtwJa0EBdTYCkAoLQwECf0EBIQECQCAALwEAIgJBd2pB//8DcUEFSQ0AIAJBgAFyQaABRg0AQQAhASACEChFDQAgAkEuRyAAECpyDwsgAQs9AQJ/QQAhAgJAQQAoAtwJIgMgAEsNACAALwEAIAFHDQACQCADIABHDQBBAQ8LIABBfmovAQAQICECCyACC2gBAn9BASEBAkACQCAAQV9qIgJBBUsNAEEBIAJ0QTFxDQELIABB+P8DcUEoRg0AIABBRmpB//8DcUEGSQ0AAkAgAEGlf2oiAkEDSw0AIAJBAUcNAQsgAEGFf2pB//8DcUEESSEBCyABC5wBAQN/QQAoArAKIQECQANAAkACQCABLwEAIgJBL0cNAAJAIAEvAQIiAUEqRg0AIAFBL0cNBBAYDAILIAAQGQwBCwJAAkAgAEUNACACQXdqIgFBF0sNAUEBIAF0QZ+AgARxRQ0BDAILIAIQIUUNAwwBCyACQaABRw0CC0EAQQAoArAKIgNBAmoiATYCsAogA0EAKAK0CkkNAAsLIAILMQEBf0EAIQECQCAALwEAQS5HDQAgAEF+ai8BAEEuRw0AIABBfGovAQBBLkYhAQsgAQumBAEBfwJAIAFBIkYNACABQSdGDQAQJQ8LQQAoArAKIQMgARAaIAAgA0ECakEAKAKwCkEAKALQCRABAkAgAkEBSA0AQQAoAvAJQQRBBiACQQFGGzYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQIMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhAiABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIAJBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiACECA0BBACACQQJqNgKwCgJAAkACQEEBECkiAkEiRg0AIAJBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQIMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSECDAELIAIQLCECCwJAIAJBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAkEiRg0AIAJBJ0YNAEEAIAE2ArAKDwsgAhAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAkEsRg0AIAJB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiECDAELC0EAKALwCSIBIAA2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", "undefined" != typeof Buffer ? Buffer.from(A2, "base64") : Uint8Array.from(atob(A2), ((A3) => A3.charCodeAt(0)));
  var A2;
};
var init2 = WebAssembly.compile(E()).then(WebAssembly.instantiate).then((({ exports: A2 }) => {
  C = A2;
}));

// src/svelte-resolver.js
var convertMessage = ({ message, start, end, filename: filename2, frame }) => ({
  text: message,
  location: start && end && {
    file: filename2,
    line: start.line,
    column: start.column,
    length: start.line === end.line ? end.column - start.column : 0,
    lineText: frame
  }
});
var SVELTE_FILTER = /\.svelte$/;
var sveltePlugin = {
  name: "esbuild-svelte",
  setup(build2) {
    build2.onLoad({ filter: SVELTE_FILTER }, async (args) => {
      console.log("sveltePlugin", args);
      const originalSource = await fetch(args.path).then((res) => res.text());
      const filename2 = new URL(args.path).pathname.split("/").pop();
      const compilerOptions = {
        css: "injected",
        // customElement: true,
        generate: "dom"
      };
      try {
        const source2 = originalSource;
        const { js: js2, css, warnings: warnings2 } = compile(source2, { ...compilerOptions, filename: filename2 });
        let contents = js2.code;
        if ((compilerOptions.css === false || compilerOptions.css === "external") && css.code) {
          const cssPath = args.path.replace(".svelte", ".esbuild-svelte-fake-css").replace(/\\/g, "/");
        }
        const result = {
          contents,
          warnings: warnings2.map(convertMessage)
        };
        console.log("sveltePlugin", result);
        return result;
      } catch (e2) {
        console.error("sveltePlugin", e2);
        return { errors: [convertMessage(e2)] };
      }
    });
  }
};

// src/esbuild.js
async function rewriteImports(str) {
  const [imports] = await parse7(str);
  for (const x of imports.reverse()) {
    let dependency = x.n;
    const npmPackageRegex = /^(?!https?:\/\/)([\w@].*)$/;
    let meta = str.slice(x.a, x.se);
    if (meta) {
      console.log("cant parse", meta);
      try {
        meta = JSON.parse(meta);
      } catch (err) {
        meta = eval(`(${meta})`);
      }
      if (meta.type === "css") delete meta.type;
      meta = JSON.stringify(meta);
      console.log("new meta", meta);
      str = str.slice(0, x.a) + meta + str.slice(x.se);
    }
    if (npmPackageRegex.test(dependency)) {
      str = str.slice(0, x.s) + "https://esm.sh/" + dependency + str.slice(x.e);
    }
  }
  console.log(str);
  return str;
}
export {
  ut as build,
  httpPlugin,
  wt as initialize,
  rewriteImports,
  sveltePlugin
};

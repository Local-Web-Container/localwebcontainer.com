(async () => {
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/native-file-system-adapter/src/util.js
var errors, config;
var init_util = __esm({
  "node_modules/native-file-system-adapter/src/util.js"() {
    errors = {
      INVALID: ["seeking position failed.", "InvalidStateError"],
      GONE: ["A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"],
      MISMATCH: ["The path supplied exists, but was not an entry of requested type.", "TypeMismatchError"],
      MOD_ERR: ["The object can not be modified in this way.", "InvalidModificationError"],
      SYNTAX: (m) => [`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${m}`, "SyntaxError"],
      SECURITY: ["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.", "SecurityError"],
      DISALLOWED: ["The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError"]
    };
    config = {
      writable: globalThis.WritableStream
    };
  }
});

// node_modules/native-file-system-adapter/src/adapters/sandbox.js
var sandbox_exports = {};
__export(sandbox_exports, {
  FileHandle: () => FileHandle,
  FolderHandle: () => FolderHandle,
  default: () => sandbox_default
});
var DISALLOWED, Sink, FileHandle, FolderHandle, sandbox_default;
var init_sandbox = __esm({
  "node_modules/native-file-system-adapter/src/adapters/sandbox.js"() {
    init_util();
    ({ DISALLOWED } = errors);
    Sink = class {
      constructor(writer, fileEntry) {
        this.writer = writer;
        this.fileEntry = fileEntry;
      }
      async write(chunk) {
        if (typeof chunk === "object") {
          if (chunk.type === "write") {
            if (Number.isInteger(chunk.position) && chunk.position >= 0) {
              this.writer.seek(chunk.position);
              if (this.writer.position !== chunk.position) {
                await new Promise((resolve, reject) => {
                  this.writer.onwriteend = resolve;
                  this.writer.onerror = reject;
                  this.writer.truncate(chunk.position);
                });
                this.writer.seek(chunk.position);
              }
            }
            if (!("data" in chunk)) {
              throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument", "SyntaxError");
            }
            chunk = chunk.data;
          } else if (chunk.type === "seek") {
            if (Number.isInteger(chunk.position) && chunk.position >= 0) {
              this.writer.seek(chunk.position);
              if (this.writer.position !== chunk.position) {
                throw new DOMException("seeking position failed", "InvalidStateError");
              }
              return;
            } else {
              throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument", "SyntaxError");
            }
          } else if (chunk.type === "truncate") {
            return new Promise((resolve) => {
              if (Number.isInteger(chunk.size) && chunk.size >= 0) {
                this.writer.onwriteend = (evt) => resolve();
                this.writer.truncate(chunk.size);
              } else {
                throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument", "SyntaxError");
              }
            });
          }
        }
        await new Promise((resolve, reject) => {
          this.writer.onwriteend = resolve;
          this.writer.onerror = reject;
          this.writer.write(new Blob([chunk]));
        });
      }
      close() {
        return new Promise(this.fileEntry.file.bind(this.fileEntry));
      }
    };
    FileHandle = class {
      constructor(file, writable = true) {
        this.file = file;
        this.kind = "file";
        this.writable = writable;
        this.readable = true;
      }
      get name() {
        return this.file.name;
      }
      isSameEntry(other) {
        return this.file.toURL() === other.file.toURL();
      }
      getFile() {
        return new Promise(this.file.file.bind(this.file));
      }
      createWritable(opts) {
        if (!this.writable)
          throw new DOMException(...DISALLOWED);
        return new Promise((resolve, reject) => this.file.createWriter((fileWriter) => {
          if (opts.keepExistingData === false) {
            fileWriter.onwriteend = (evt) => resolve(new Sink(fileWriter, this.file));
            fileWriter.truncate(0);
          } else {
            resolve(new Sink(fileWriter, this.file));
          }
        }, reject));
      }
    };
    FolderHandle = class {
      constructor(dir, writable = true) {
        this.dir = dir;
        this.writable = writable;
        this.readable = true;
        this.kind = "directory";
        this.name = dir.name;
      }
      isSameEntry(other) {
        return this.dir.fullPath === other.dir.fullPath;
      }
      async *entries() {
        const reader = this.dir.createReader();
        const entries = await new Promise(reader.readEntries.bind(reader));
        for (const x of entries) {
          yield [x.name, x.isFile ? new FileHandle(x, this.writable) : new FolderHandle(x, this.writable)];
        }
      }
      getDirectoryHandle(name, opts) {
        return new Promise((resolve, reject) => {
          this.dir.getDirectory(name, opts, (dir) => {
            resolve(new FolderHandle(dir));
          }, reject);
        });
      }
      getFileHandle(name, opts) {
        return new Promise((resolve, reject) => this.dir.getFile(name, opts, (file) => resolve(new FileHandle(file)), reject));
      }
      async removeEntry(name, opts) {
        const entry = await this.getDirectoryHandle(name, { create: false }).catch((err) => err.name === "TypeMismatchError" ? this.getFileHandle(name, { create: false }) : err);
        if (entry instanceof Error)
          throw entry;
        return new Promise((resolve, reject) => {
          if (entry instanceof FolderHandle) {
            opts.recursive ? entry.dir.removeRecursively(() => resolve(), reject) : entry.dir.remove(() => resolve(), reject);
          } else if (entry.file) {
            entry.file.remove(() => resolve(), reject);
          }
        });
      }
    };
    sandbox_default = (opts = {}) => new Promise((resolve, reject) => window.webkitRequestFileSystem(opts._persistent, 0, (e) => resolve(new FolderHandle(e.root)), reject));
  }
});

// node_modules/native-file-system-adapter/src/FileSystemHandle.js
var kAdapter, FileSystemHandle, FileSystemHandle_default;
var init_FileSystemHandle = __esm({
  "node_modules/native-file-system-adapter/src/FileSystemHandle.js"() {
    kAdapter = Symbol("adapter");
    FileSystemHandle = class {
      [kAdapter];
      name;
      kind;
      constructor(adapter) {
        this.kind = adapter.kind;
        this.name = adapter.name;
        this[kAdapter] = adapter;
      }
      async queryPermission({ mode = "read" } = {}) {
        const handle = this[kAdapter];
        if (handle.queryPermission) {
          return handle.queryPermission({ mode });
        }
        if (mode === "read") {
          return "granted";
        } else if (mode === "readwrite") {
          return handle.writable ? "granted" : "denied";
        } else {
          throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
        }
      }
      async requestPermission({ mode = "read" } = {}) {
        const handle = this[kAdapter];
        if (handle.requestPermission) {
          return handle.requestPermission({ mode });
        }
        if (mode === "read") {
          return "granted";
        } else if (mode === "readwrite") {
          return handle.writable ? "granted" : "denied";
        } else {
          throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
        }
      }
      async remove(options = {}) {
        await this[kAdapter].remove(options);
      }
      async isSameEntry(other) {
        if (this === other)
          return true;
        if (!other || typeof other !== "object" || this.kind !== other.kind || !other[kAdapter])
          return false;
        return this[kAdapter].isSameEntry(other[kAdapter]);
      }
    };
    Object.defineProperty(FileSystemHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FileSystemHandle_default = FileSystemHandle;
  }
});

// node_modules/native-file-system-adapter/src/config.js
var config2, config_default;
var init_config = __esm({
  "node_modules/native-file-system-adapter/src/config.js"() {
    config2 = {
      ReadableStream: globalThis.ReadableStream,
      WritableStream: globalThis.WritableStream,
      TransformStream: globalThis.TransformStream,
      DOMException: globalThis.DOMException,
      Blob: globalThis.Blob,
      File: globalThis.File
    };
    config_default = config2;
  }
});

// node_modules/native-file-system-adapter/src/FileSystemWritableFileStream.js
var WritableStream, FileSystemWritableFileStream, FileSystemWritableFileStream_default;
var init_FileSystemWritableFileStream = __esm({
  "node_modules/native-file-system-adapter/src/FileSystemWritableFileStream.js"() {
    init_config();
    ({ WritableStream } = config_default);
    FileSystemWritableFileStream = class extends WritableStream {
      constructor(...args) {
        super(...args);
        Object.setPrototypeOf(this, FileSystemWritableFileStream.prototype);
        this._closed = false;
      }
      close() {
        this._closed = true;
        const w = this.getWriter();
        const p3 = w.close();
        w.releaseLock();
        return p3;
      }
      seek(position) {
        return this.write({ type: "seek", position });
      }
      truncate(size) {
        return this.write({ type: "truncate", size });
      }
      write(data) {
        if (this._closed) {
          return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));
        }
        const writer = this.getWriter();
        const p3 = writer.write(data);
        writer.releaseLock();
        return p3;
      }
    };
    Object.defineProperty(FileSystemWritableFileStream.prototype, Symbol.toStringTag, {
      value: "FileSystemWritableFileStream",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemWritableFileStream.prototype, {
      close: { enumerable: true },
      seek: { enumerable: true },
      truncate: { enumerable: true },
      write: { enumerable: true }
    });
    FileSystemWritableFileStream_default = FileSystemWritableFileStream;
  }
});

// node_modules/native-file-system-adapter/src/FileSystemFileHandle.js
var FileSystemFileHandle_exports = {};
__export(FileSystemFileHandle_exports, {
  FileSystemFileHandle: () => FileSystemFileHandle,
  default: () => FileSystemFileHandle_default
});
var kAdapter2, FileSystemFileHandle, FileSystemFileHandle_default;
var init_FileSystemFileHandle = __esm({
  "node_modules/native-file-system-adapter/src/FileSystemFileHandle.js"() {
    init_FileSystemHandle();
    init_FileSystemWritableFileStream();
    kAdapter2 = Symbol("adapter");
    FileSystemFileHandle = class extends FileSystemHandle_default {
      [kAdapter2];
      constructor(adapter) {
        super(adapter);
        this[kAdapter2] = adapter;
      }
      async createWritable(options = {}) {
        return new FileSystemWritableFileStream_default(await this[kAdapter2].createWritable(options));
      }
      async getFile() {
        return this[kAdapter2].getFile();
      }
    };
    Object.defineProperty(FileSystemFileHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemFileHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemFileHandle.prototype, {
      createWritable: { enumerable: true },
      getFile: { enumerable: true }
    });
    FileSystemFileHandle_default = FileSystemFileHandle;
  }
});

// node_modules/native-file-system-adapter/src/FileSystemDirectoryHandle.js
var FileSystemDirectoryHandle_exports = {};
__export(FileSystemDirectoryHandle_exports, {
  FileSystemDirectoryHandle: () => FileSystemDirectoryHandle,
  default: () => FileSystemDirectoryHandle_default
});
var kAdapter3, FileSystemDirectoryHandle, FileSystemDirectoryHandle_default;
var init_FileSystemDirectoryHandle = __esm({
  "node_modules/native-file-system-adapter/src/FileSystemDirectoryHandle.js"() {
    init_FileSystemHandle();
    kAdapter3 = Symbol("adapter");
    FileSystemDirectoryHandle = class extends FileSystemHandle_default {
      [kAdapter3];
      constructor(adapter) {
        super(adapter);
        this[kAdapter3] = adapter;
      }
      async getDirectoryHandle(name, options = {}) {
        if (name === "") {
          throw new TypeError(`Name can't be an empty string.`);
        }
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.create = !!options.create;
        const handle = await this[kAdapter3].getDirectoryHandle(name, options);
        return new FileSystemDirectoryHandle(handle);
      }
      async *entries() {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        for await (const [_, entry] of this[kAdapter3].entries())
          yield [entry.name, entry.kind === "file" ? new FileSystemFileHandle2(entry) : new FileSystemDirectoryHandle(entry)];
      }
      async *getEntries() {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        console.warn("deprecated, use .entries() instead");
        for await (let entry of this[kAdapter3].entries())
          yield entry.kind === "file" ? new FileSystemFileHandle2(entry) : new FileSystemDirectoryHandle(entry);
      }
      async getFileHandle(name, options = {}) {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        if (name === "")
          throw new TypeError(`Name can't be an empty string.`);
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.create = !!options.create;
        const handle = await this[kAdapter3].getFileHandle(name, options);
        return new FileSystemFileHandle2(handle);
      }
      async removeEntry(name, options = {}) {
        if (name === "") {
          throw new TypeError(`Name can't be an empty string.`);
        }
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.recursive = !!options.recursive;
        return this[kAdapter3].removeEntry(name, options);
      }
      async resolve(possibleDescendant) {
        if (await possibleDescendant.isSameEntry(this)) {
          return [];
        }
        const openSet = [{ handle: this, path: [] }];
        while (openSet.length) {
          let { handle: current, path } = openSet.pop();
          for await (const entry of current.values()) {
            if (await entry.isSameEntry(possibleDescendant)) {
              return [...path, entry.name];
            }
            if (entry.kind === "directory") {
              openSet.push({ handle: entry, path: [...path, entry.name] });
            }
          }
        }
        return null;
      }
      async *keys() {
        for await (const [name] of this[kAdapter3].entries())
          yield name;
      }
      async *values() {
        for await (const [_, entry] of this)
          yield entry;
      }
      [Symbol.asyncIterator]() {
        return this.entries();
      }
    };
    Object.defineProperty(FileSystemDirectoryHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemDirectoryHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemDirectoryHandle.prototype, {
      getDirectoryHandle: { enumerable: true },
      entries: { enumerable: true },
      getFileHandle: { enumerable: true },
      removeEntry: { enumerable: true }
    });
    FileSystemDirectoryHandle_default = FileSystemDirectoryHandle;
  }
});

// src/main/resources/topdomain/itty-router.js
function Router({ routes = [] } = {}) {
  return {
    __proto__: new Proxy({}, {
      get: (target, prop, receiver) => (matcher, ...handlers) => {
        if (typeof matcher !== "function") {
          const pattern = typeof matcher === "object" || matcher?.startsWith("http") ? new URLPattern(matcher) : new URLPattern({ pathname: matcher });
          matcher = (o) => o.match = pattern.exec(o.url);
        }
        return routes.push([
          prop.toUpperCase(),
          matcher,
          handlers
        ]) && receiver;
      }
    }),
    routes,
    async handle(event, ctx = {}) {
      let response;
      ctx.url = new URL(event.request.url);
      ctx.event = event;
      ctx.request = event.request;
      ctx.match = void 0;
      ctx.response = {
        status: 200,
        headers: new Headers(),
        body: null
      };
      ctx.metadata = {};
      for (let [method, matcher, handlers] of routes) {
        const matchMethod = method === "ALL" || method === ctx.request.method;
        if (matchMethod && matcher(ctx)) {
          for (let handler of handlers) {
            if ((response = await handler(ctx)) !== void 0)
              return response;
          }
        }
      }
    }
  };
}

// src/main/resources/topdomain/http-resolver.js
var RESOLVE_EXTENSIONS = ["tsx", "ts", "jsx", "js", "css", "json"];
function inferLoader(p3, h) {
  if (h?.includes("javascript"))
    return "js";
  const ext = p3.split(".").pop();
  if (RESOLVE_EXTENSIONS.includes(ext))
    return ext;
  if (ext === "mjs" || ext === "cjs")
    return "js";
  return "text";
}
var httpPlugin = {
  name: "http",
  setup(build) {
    build.onResolve({ filter: /^https?:\/\// }, (args) => ({
      path: args.path,
      namespace: "http-url"
    }));
    build.onResolve({ filter: /.*/, namespace: "http-url" }, (args) => ({
      path: new URL(args.path, args.importer).toString(),
      namespace: "http-url"
    }));
    build.onLoad({ filter: /.*/, namespace: "http-url" }, async (args) => {
      const url = args.path;
      const res = await fetch(url);
      const text = await res.text();
      if (!res.ok)
        throw new Error(`GET ${url} failed: status ${res.status}`);
      return {
        contents: text,
        loader: inferLoader(url, res.headers.get("content-type"))
      };
    });
  }
};

// src/main/resources/topdomain/extern.js
var extern_default = globalThis;

// src/main/resources/topdomain/clientmyadmin/shared/kv.js
var p;
var query = (method, ...args) => (p ??= new Promise((rs) => {
  const open = indexedDB.open("clientmyadmin-kv");
  open.onupgradeneeded = () => open.result.createObjectStore("kv");
  open.onsuccess = () => {
    const db = open.result;
    query = (method2, ...args2) => {
      const q = db.transaction("kv", "readwrite").objectStore("kv")[method2](...args2);
      return new Promise((rs2, rj) => {
        q.onsuccess = () => rs2(q.result);
        q.onerror = () => rj(q.error);
      });
    };
    rs();
  };
})).then(() => query(method, ...args));
var kv_default = (...args) => query(...args);

// src/main/resources/topdomain/clientmyadmin/shared/fs.js
async function findHandle(root2, path) {
  if (path.length === 0) {
    return root2;
  }
  const name = path.shift();
  if (root2.kind === "directory") {
    const handle = await root2.getDirectoryHandle(name).catch((err) => {
      if (err.name === "TypeMismatchError") {
        return root2.getFileHandle(name);
      } else {
        throw err;
      }
    });
    return findHandle(handle, path);
  }
  throw new Error(`'${root2.name}' is a file, not a directory, cannot search for '${root2.name}/${name}'`);
}
async function mkdirp(dirHandle, paths) {
  for (const path of paths) {
    dirHandle = await dirHandle.getDirectoryHandle(path, { create: true });
  }
  return dirHandle;
}
async function touch(dirHandle, paths) {
  const file = paths.pop();
  if (!file)
    throw new Error("touch: no file name provided");
  dirHandle = await mkdirp(dirHandle, paths);
  return dirHandle.getFileHandle(file, { create: true });
}
async function* walkHandleRecursive(source) {
  yield source;
  console.log(source.kind);
  if (source.kind === "directory") {
    for await (const [name, child] of source) {
      yield* walkHandleRecursive(child);
    }
  }
}
async function emptyDir(source) {
  for await (const [name, handle] of source) {
    await handle.remove({ recursive: true });
  }
  return source;
}
async function cp(source, dest, newName) {
  if (source.kind === "file") {
    const file = await source.getFile();
    const fileHandle = await dest.getFileHandle(newName, { create: true });
    const writer = await fileHandle.createWritable();
    await writer.write(file);
    await writer.close();
  } else {
    const dirHandle = await dest.getDirectoryHandle(newName, { create: true });
    for await (const [name, child] of source) {
      await cp(child, dirHandle, name);
    }
  }
}
var fs_default = {
  mkdirp,
  touch,
  cp,
  walkHandleRecursive,
  emptyDir,
  open(root2, path) {
    return findHandle(root2, path.split("/").filter(Boolean));
  }
};

// src/main/resources/topdomain/clientmyadmin/mime/standard.json
var application_andrew_inset = ["ez"];
var application_applixware = ["aw"];
var application_atom_xml = ["atom"];
var application_atomcat_xml = ["atomcat"];
var application_atomdeleted_xml = ["atomdeleted"];
var application_atomsvc_xml = ["atomsvc"];
var application_atsc_dwd_xml = ["dwd"];
var application_atsc_held_xml = ["held"];
var application_atsc_rsat_xml = ["rsat"];
var application_bdoc = ["bdoc"];
var application_calendar_xml = ["xcs"];
var application_ccxml_xml = ["ccxml"];
var application_cdfx_xml = ["cdfx"];
var application_cdmi_capability = ["cdmia"];
var application_cdmi_container = ["cdmic"];
var application_cdmi_domain = ["cdmid"];
var application_cdmi_object = ["cdmio"];
var application_cdmi_queue = ["cdmiq"];
var application_cu_seeme = ["cu"];
var application_dash_xml = ["mpd"];
var application_davmount_xml = ["davmount"];
var application_docbook_xml = ["dbk"];
var application_dssc_der = ["dssc"];
var application_dssc_xml = ["xdssc"];
var application_ecmascript = ["es", "ecma"];
var application_emma_xml = ["emma"];
var application_emotionml_xml = ["emotionml"];
var application_epub_zip = ["epub"];
var application_exi = ["exi"];
var application_express = ["exp"];
var application_fdt_xml = ["fdt"];
var application_font_tdpfr = ["pfr"];
var application_geo_json = ["geojson"];
var application_gml_xml = ["gml"];
var application_gpx_xml = ["gpx"];
var application_gxf = ["gxf"];
var application_gzip = ["gz"];
var application_hjson = ["hjson"];
var application_hyperstudio = ["stk"];
var application_inkml_xml = ["ink", "inkml"];
var application_ipfix = ["ipfix"];
var application_its_xml = ["its"];
var application_java_archive = ["jar", "war", "ear"];
var application_java_serialized_object = ["ser"];
var application_java_vm = ["class"];
var application_javascript = ["js", "mjs"];
var application_json = ["json", "map"];
var application_json5 = ["json5"];
var application_jsonml_json = ["jsonml"];
var application_ld_json = ["jsonld"];
var application_lgr_xml = ["lgr"];
var application_lost_xml = ["lostxml"];
var application_mac_binhex40 = ["hqx"];
var application_mac_compactpro = ["cpt"];
var application_mads_xml = ["mads"];
var application_manifest_json = ["webmanifest"];
var application_marc = ["mrc"];
var application_marcxml_xml = ["mrcx"];
var application_mathematica = ["ma", "nb", "mb"];
var application_mathml_xml = ["mathml"];
var application_mbox = ["mbox"];
var application_mediaservercontrol_xml = ["mscml"];
var application_metalink_xml = ["metalink"];
var application_metalink4_xml = ["meta4"];
var application_mets_xml = ["mets"];
var application_mmt_aei_xml = ["maei"];
var application_mmt_usd_xml = ["musd"];
var application_mods_xml = ["mods"];
var application_mp21 = ["m21", "mp21"];
var application_mp4 = ["mp4s", "m4p"];
var application_msword = ["doc", "dot"];
var application_mxf = ["mxf"];
var application_n_quads = ["nq"];
var application_n_triples = ["nt"];
var application_node = ["cjs"];
var application_octet_stream = ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"];
var application_oda = ["oda"];
var application_oebps_package_xml = ["opf"];
var application_ogg = ["ogx"];
var application_omdoc_xml = ["omdoc"];
var application_onenote = ["onetoc", "onetoc2", "onetmp", "onepkg"];
var application_oxps = ["oxps"];
var application_p2p_overlay_xml = ["relo"];
var application_patch_ops_error_xml = ["xer"];
var application_pdf = ["pdf"];
var application_pgp_encrypted = ["pgp"];
var application_pgp_signature = ["asc", "sig"];
var application_pics_rules = ["prf"];
var application_pkcs10 = ["p10"];
var application_pkcs7_mime = ["p7m", "p7c"];
var application_pkcs7_signature = ["p7s"];
var application_pkcs8 = ["p8"];
var application_pkix_attr_cert = ["ac"];
var application_pkix_cert = ["cer"];
var application_pkix_crl = ["crl"];
var application_pkix_pkipath = ["pkipath"];
var application_pkixcmp = ["pki"];
var application_pls_xml = ["pls"];
var application_postscript = ["ai", "eps", "ps"];
var application_provenance_xml = ["provx"];
var application_pskc_xml = ["pskcxml"];
var application_raml_yaml = ["raml"];
var application_rdf_xml = ["rdf", "owl"];
var application_reginfo_xml = ["rif"];
var application_relax_ng_compact_syntax = ["rnc"];
var application_resource_lists_xml = ["rl"];
var application_resource_lists_diff_xml = ["rld"];
var application_rls_services_xml = ["rs"];
var application_route_apd_xml = ["rapd"];
var application_route_s_tsid_xml = ["sls"];
var application_route_usd_xml = ["rusd"];
var application_rpki_ghostbusters = ["gbr"];
var application_rpki_manifest = ["mft"];
var application_rpki_roa = ["roa"];
var application_rsd_xml = ["rsd"];
var application_rss_xml = ["rss"];
var application_rtf = ["rtf"];
var application_sbml_xml = ["sbml"];
var application_scvp_cv_request = ["scq"];
var application_scvp_cv_response = ["scs"];
var application_scvp_vp_request = ["spq"];
var application_scvp_vp_response = ["spp"];
var application_sdp = ["sdp"];
var application_senml_xml = ["senmlx"];
var application_sensml_xml = ["sensmlx"];
var application_set_payment_initiation = ["setpay"];
var application_set_registration_initiation = ["setreg"];
var application_shf_xml = ["shf"];
var application_sieve = ["siv", "sieve"];
var application_smil_xml = ["smi", "smil"];
var application_sparql_query = ["rq"];
var application_sparql_results_xml = ["srx"];
var application_srgs = ["gram"];
var application_srgs_xml = ["grxml"];
var application_sru_xml = ["sru"];
var application_ssdl_xml = ["ssdl"];
var application_ssml_xml = ["ssml"];
var application_swid_xml = ["swidtag"];
var application_tei_xml = ["tei", "teicorpus"];
var application_thraud_xml = ["tfi"];
var application_timestamped_data = ["tsd"];
var application_toml = ["toml"];
var application_trig = ["trig"];
var application_ttml_xml = ["ttml"];
var application_ubjson = ["ubj"];
var application_urc_ressheet_xml = ["rsheet"];
var application_urc_targetdesc_xml = ["td"];
var application_voicexml_xml = ["vxml"];
var application_wasm = ["wasm"];
var application_widget = ["wgt"];
var application_winhlp = ["hlp"];
var application_wsdl_xml = ["wsdl"];
var application_wspolicy_xml = ["wspolicy"];
var application_xaml_xml = ["xaml"];
var application_xcap_att_xml = ["xav"];
var application_xcap_caps_xml = ["xca"];
var application_xcap_diff_xml = ["xdf"];
var application_xcap_el_xml = ["xel"];
var application_xcap_ns_xml = ["xns"];
var application_xenc_xml = ["xenc"];
var application_xhtml_xml = ["xhtml", "xht"];
var application_xliff_xml = ["xlf"];
var application_xml = ["xml", "xsl", "xsd", "rng"];
var application_xml_dtd = ["dtd"];
var application_xop_xml = ["xop"];
var application_xproc_xml = ["xpl"];
var application_xslt_xml = ["*xsl", "xslt"];
var application_xspf_xml = ["xspf"];
var application_xv_xml = ["mxml", "xhvml", "xvml", "xvm"];
var application_yang = ["yang"];
var application_yin_xml = ["yin"];
var application_zip = ["zip"];
var audio_3gpp = ["*3gpp"];
var audio_adpcm = ["adp"];
var audio_amr = ["amr"];
var audio_basic = ["au", "snd"];
var audio_midi = ["mid", "midi", "kar", "rmi"];
var audio_mobile_xmf = ["mxmf"];
var audio_mp3 = ["*mp3"];
var audio_mp4 = ["m4a", "mp4a"];
var audio_mpeg = ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"];
var audio_ogg = ["oga", "ogg", "spx", "opus"];
var audio_s3m = ["s3m"];
var audio_silk = ["sil"];
var audio_wav = ["wav"];
var audio_wave = ["*wav"];
var audio_webm = ["weba"];
var audio_xm = ["xm"];
var font_collection = ["ttc"];
var font_otf = ["otf"];
var font_ttf = ["ttf"];
var font_woff = ["woff"];
var font_woff2 = ["woff2"];
var image_aces = ["exr"];
var image_apng = ["apng"];
var image_avif = ["avif"];
var image_bmp = ["bmp"];
var image_cgm = ["cgm"];
var image_dicom_rle = ["drle"];
var image_emf = ["emf"];
var image_fits = ["fits"];
var image_g3fax = ["g3"];
var image_gif = ["gif"];
var image_heic = ["heic"];
var image_heic_sequence = ["heics"];
var image_heif = ["heif"];
var image_heif_sequence = ["heifs"];
var image_hej2k = ["hej2"];
var image_hsj2 = ["hsj2"];
var image_ief = ["ief"];
var image_jls = ["jls"];
var image_jp2 = ["jp2", "jpg2"];
var image_jpeg = ["jpeg", "jpg", "jpe"];
var image_jph = ["jph"];
var image_jphc = ["jhc"];
var image_jpm = ["jpm"];
var image_jpx = ["jpx", "jpf"];
var image_jxr = ["jxr"];
var image_jxra = ["jxra"];
var image_jxrs = ["jxrs"];
var image_jxs = ["jxs"];
var image_jxsc = ["jxsc"];
var image_jxsi = ["jxsi"];
var image_jxss = ["jxss"];
var image_ktx = ["ktx"];
var image_ktx2 = ["ktx2"];
var image_png = ["png"];
var image_sgi = ["sgi"];
var image_svg_xml = ["svg", "svgz"];
var image_t38 = ["t38"];
var image_tiff = ["tif", "tiff"];
var image_tiff_fx = ["tfx"];
var image_webp = ["webp"];
var image_wmf = ["wmf"];
var message_disposition_notification = ["disposition-notification"];
var message_global = ["u8msg"];
var message_global_delivery_status = ["u8dsn"];
var message_global_disposition_notification = ["u8mdn"];
var message_global_headers = ["u8hdr"];
var message_rfc822 = ["eml", "mime"];
var model_3mf = ["3mf"];
var model_gltf_json = ["gltf"];
var model_gltf_binary = ["glb"];
var model_iges = ["igs", "iges"];
var model_mesh = ["msh", "mesh", "silo"];
var model_mtl = ["mtl"];
var model_obj = ["obj"];
var model_step_xml = ["stpx"];
var model_step_zip = ["stpz"];
var model_step_xml_zip = ["stpxz"];
var model_stl = ["stl"];
var model_vrml = ["wrl", "vrml"];
var model_x3d_binary = ["*x3db", "x3dbz"];
var model_x3d_fastinfoset = ["x3db"];
var model_x3d_vrml = ["*x3dv", "x3dvz"];
var model_x3d_xml = ["x3d", "x3dz"];
var model_x3d_vrml2 = ["x3dv"];
var text_cache_manifest = ["appcache", "manifest"];
var text_calendar = ["ics", "ifb"];
var text_coffeescript = ["coffee", "litcoffee"];
var text_css = ["css"];
var text_csv = ["csv"];
var text_html = ["html", "htm", "shtml"];
var text_jade = ["jade"];
var text_jsx = ["jsx"];
var text_less = ["less"];
var text_markdown = ["markdown", "md"];
var text_mathml = ["mml"];
var text_mdx = ["mdx"];
var text_n3 = ["n3"];
var text_plain = ["txt", "text", "conf", "def", "list", "log", "in", "ini"];
var text_richtext = ["rtx"];
var text_rtf = ["*rtf"];
var text_sgml = ["sgml", "sgm"];
var text_shex = ["shex"];
var text_slim = ["slim", "slm"];
var text_spdx = ["spdx"];
var text_stylus = ["stylus", "styl"];
var text_tab_separated_values = ["tsv"];
var text_troff = ["t", "tr", "roff", "man", "me", "ms"];
var text_turtle = ["ttl"];
var text_uri_list = ["uri", "uris", "urls"];
var text_vcard = ["vcard"];
var text_vtt = ["vtt"];
var text_xml = ["*xml"];
var text_yaml = ["yaml", "yml"];
var video_3gpp = ["3gp", "3gpp"];
var video_3gpp2 = ["3g2"];
var video_h261 = ["h261"];
var video_h263 = ["h263"];
var video_h264 = ["h264"];
var video_iso_segment = ["m4s"];
var video_jpeg = ["jpgv"];
var video_jpm = ["*jpm", "jpgm"];
var video_mj2 = ["mj2", "mjp2"];
var video_mp2t = ["ts"];
var video_mp4 = ["mp4", "mp4v", "mpg4"];
var video_mpeg = ["mpeg", "mpg", "mpe", "m1v", "m2v"];
var video_ogg = ["ogv"];
var video_quicktime = ["qt", "mov"];
var video_webm = ["webm"];
var standard_default = { "application/andrew-inset": application_andrew_inset, "application/applixware": application_applixware, "application/atom+xml": application_atom_xml, "application/atomcat+xml": application_atomcat_xml, "application/atomdeleted+xml": application_atomdeleted_xml, "application/atomsvc+xml": application_atomsvc_xml, "application/atsc-dwd+xml": application_atsc_dwd_xml, "application/atsc-held+xml": application_atsc_held_xml, "application/atsc-rsat+xml": application_atsc_rsat_xml, "application/bdoc": application_bdoc, "application/calendar+xml": application_calendar_xml, "application/ccxml+xml": application_ccxml_xml, "application/cdfx+xml": application_cdfx_xml, "application/cdmi-capability": application_cdmi_capability, "application/cdmi-container": application_cdmi_container, "application/cdmi-domain": application_cdmi_domain, "application/cdmi-object": application_cdmi_object, "application/cdmi-queue": application_cdmi_queue, "application/cu-seeme": application_cu_seeme, "application/dash+xml": application_dash_xml, "application/davmount+xml": application_davmount_xml, "application/docbook+xml": application_docbook_xml, "application/dssc+der": application_dssc_der, "application/dssc+xml": application_dssc_xml, "application/ecmascript": application_ecmascript, "application/emma+xml": application_emma_xml, "application/emotionml+xml": application_emotionml_xml, "application/epub+zip": application_epub_zip, "application/exi": application_exi, "application/express": application_express, "application/fdt+xml": application_fdt_xml, "application/font-tdpfr": application_font_tdpfr, "application/geo+json": application_geo_json, "application/gml+xml": application_gml_xml, "application/gpx+xml": application_gpx_xml, "application/gxf": application_gxf, "application/gzip": application_gzip, "application/hjson": application_hjson, "application/hyperstudio": application_hyperstudio, "application/inkml+xml": application_inkml_xml, "application/ipfix": application_ipfix, "application/its+xml": application_its_xml, "application/java-archive": application_java_archive, "application/java-serialized-object": application_java_serialized_object, "application/java-vm": application_java_vm, "application/javascript": application_javascript, "application/json": application_json, "application/json5": application_json5, "application/jsonml+json": application_jsonml_json, "application/ld+json": application_ld_json, "application/lgr+xml": application_lgr_xml, "application/lost+xml": application_lost_xml, "application/mac-binhex40": application_mac_binhex40, "application/mac-compactpro": application_mac_compactpro, "application/mads+xml": application_mads_xml, "application/manifest+json": application_manifest_json, "application/marc": application_marc, "application/marcxml+xml": application_marcxml_xml, "application/mathematica": application_mathematica, "application/mathml+xml": application_mathml_xml, "application/mbox": application_mbox, "application/mediaservercontrol+xml": application_mediaservercontrol_xml, "application/metalink+xml": application_metalink_xml, "application/metalink4+xml": application_metalink4_xml, "application/mets+xml": application_mets_xml, "application/mmt-aei+xml": application_mmt_aei_xml, "application/mmt-usd+xml": application_mmt_usd_xml, "application/mods+xml": application_mods_xml, "application/mp21": application_mp21, "application/mp4": application_mp4, "application/msword": application_msword, "application/mxf": application_mxf, "application/n-quads": application_n_quads, "application/n-triples": application_n_triples, "application/node": application_node, "application/octet-stream": application_octet_stream, "application/oda": application_oda, "application/oebps-package+xml": application_oebps_package_xml, "application/ogg": application_ogg, "application/omdoc+xml": application_omdoc_xml, "application/onenote": application_onenote, "application/oxps": application_oxps, "application/p2p-overlay+xml": application_p2p_overlay_xml, "application/patch-ops-error+xml": application_patch_ops_error_xml, "application/pdf": application_pdf, "application/pgp-encrypted": application_pgp_encrypted, "application/pgp-signature": application_pgp_signature, "application/pics-rules": application_pics_rules, "application/pkcs10": application_pkcs10, "application/pkcs7-mime": application_pkcs7_mime, "application/pkcs7-signature": application_pkcs7_signature, "application/pkcs8": application_pkcs8, "application/pkix-attr-cert": application_pkix_attr_cert, "application/pkix-cert": application_pkix_cert, "application/pkix-crl": application_pkix_crl, "application/pkix-pkipath": application_pkix_pkipath, "application/pkixcmp": application_pkixcmp, "application/pls+xml": application_pls_xml, "application/postscript": application_postscript, "application/provenance+xml": application_provenance_xml, "application/pskc+xml": application_pskc_xml, "application/raml+yaml": application_raml_yaml, "application/rdf+xml": application_rdf_xml, "application/reginfo+xml": application_reginfo_xml, "application/relax-ng-compact-syntax": application_relax_ng_compact_syntax, "application/resource-lists+xml": application_resource_lists_xml, "application/resource-lists-diff+xml": application_resource_lists_diff_xml, "application/rls-services+xml": application_rls_services_xml, "application/route-apd+xml": application_route_apd_xml, "application/route-s-tsid+xml": application_route_s_tsid_xml, "application/route-usd+xml": application_route_usd_xml, "application/rpki-ghostbusters": application_rpki_ghostbusters, "application/rpki-manifest": application_rpki_manifest, "application/rpki-roa": application_rpki_roa, "application/rsd+xml": application_rsd_xml, "application/rss+xml": application_rss_xml, "application/rtf": application_rtf, "application/sbml+xml": application_sbml_xml, "application/scvp-cv-request": application_scvp_cv_request, "application/scvp-cv-response": application_scvp_cv_response, "application/scvp-vp-request": application_scvp_vp_request, "application/scvp-vp-response": application_scvp_vp_response, "application/sdp": application_sdp, "application/senml+xml": application_senml_xml, "application/sensml+xml": application_sensml_xml, "application/set-payment-initiation": application_set_payment_initiation, "application/set-registration-initiation": application_set_registration_initiation, "application/shf+xml": application_shf_xml, "application/sieve": application_sieve, "application/smil+xml": application_smil_xml, "application/sparql-query": application_sparql_query, "application/sparql-results+xml": application_sparql_results_xml, "application/srgs": application_srgs, "application/srgs+xml": application_srgs_xml, "application/sru+xml": application_sru_xml, "application/ssdl+xml": application_ssdl_xml, "application/ssml+xml": application_ssml_xml, "application/swid+xml": application_swid_xml, "application/tei+xml": application_tei_xml, "application/thraud+xml": application_thraud_xml, "application/timestamped-data": application_timestamped_data, "application/toml": application_toml, "application/trig": application_trig, "application/ttml+xml": application_ttml_xml, "application/ubjson": application_ubjson, "application/urc-ressheet+xml": application_urc_ressheet_xml, "application/urc-targetdesc+xml": application_urc_targetdesc_xml, "application/voicexml+xml": application_voicexml_xml, "application/wasm": application_wasm, "application/widget": application_widget, "application/winhlp": application_winhlp, "application/wsdl+xml": application_wsdl_xml, "application/wspolicy+xml": application_wspolicy_xml, "application/xaml+xml": application_xaml_xml, "application/xcap-att+xml": application_xcap_att_xml, "application/xcap-caps+xml": application_xcap_caps_xml, "application/xcap-diff+xml": application_xcap_diff_xml, "application/xcap-el+xml": application_xcap_el_xml, "application/xcap-ns+xml": application_xcap_ns_xml, "application/xenc+xml": application_xenc_xml, "application/xhtml+xml": application_xhtml_xml, "application/xliff+xml": application_xliff_xml, "application/xml": application_xml, "application/xml-dtd": application_xml_dtd, "application/xop+xml": application_xop_xml, "application/xproc+xml": application_xproc_xml, "application/xslt+xml": application_xslt_xml, "application/xspf+xml": application_xspf_xml, "application/xv+xml": application_xv_xml, "application/yang": application_yang, "application/yin+xml": application_yin_xml, "application/zip": application_zip, "audio/3gpp": audio_3gpp, "audio/adpcm": audio_adpcm, "audio/amr": audio_amr, "audio/basic": audio_basic, "audio/midi": audio_midi, "audio/mobile-xmf": audio_mobile_xmf, "audio/mp3": audio_mp3, "audio/mp4": audio_mp4, "audio/mpeg": audio_mpeg, "audio/ogg": audio_ogg, "audio/s3m": audio_s3m, "audio/silk": audio_silk, "audio/wav": audio_wav, "audio/wave": audio_wave, "audio/webm": audio_webm, "audio/xm": audio_xm, "font/collection": font_collection, "font/otf": font_otf, "font/ttf": font_ttf, "font/woff": font_woff, "font/woff2": font_woff2, "image/aces": image_aces, "image/apng": image_apng, "image/avif": image_avif, "image/bmp": image_bmp, "image/cgm": image_cgm, "image/dicom-rle": image_dicom_rle, "image/emf": image_emf, "image/fits": image_fits, "image/g3fax": image_g3fax, "image/gif": image_gif, "image/heic": image_heic, "image/heic-sequence": image_heic_sequence, "image/heif": image_heif, "image/heif-sequence": image_heif_sequence, "image/hej2k": image_hej2k, "image/hsj2": image_hsj2, "image/ief": image_ief, "image/jls": image_jls, "image/jp2": image_jp2, "image/jpeg": image_jpeg, "image/jph": image_jph, "image/jphc": image_jphc, "image/jpm": image_jpm, "image/jpx": image_jpx, "image/jxr": image_jxr, "image/jxra": image_jxra, "image/jxrs": image_jxrs, "image/jxs": image_jxs, "image/jxsc": image_jxsc, "image/jxsi": image_jxsi, "image/jxss": image_jxss, "image/ktx": image_ktx, "image/ktx2": image_ktx2, "image/png": image_png, "image/sgi": image_sgi, "image/svg+xml": image_svg_xml, "image/t38": image_t38, "image/tiff": image_tiff, "image/tiff-fx": image_tiff_fx, "image/webp": image_webp, "image/wmf": image_wmf, "message/disposition-notification": message_disposition_notification, "message/global": message_global, "message/global-delivery-status": message_global_delivery_status, "message/global-disposition-notification": message_global_disposition_notification, "message/global-headers": message_global_headers, "message/rfc822": message_rfc822, "model/3mf": model_3mf, "model/gltf+json": model_gltf_json, "model/gltf-binary": model_gltf_binary, "model/iges": model_iges, "model/mesh": model_mesh, "model/mtl": model_mtl, "model/obj": model_obj, "model/step+xml": model_step_xml, "model/step+zip": model_step_zip, "model/step-xml+zip": model_step_xml_zip, "model/stl": model_stl, "model/vrml": model_vrml, "model/x3d+binary": model_x3d_binary, "model/x3d+fastinfoset": model_x3d_fastinfoset, "model/x3d+vrml": model_x3d_vrml, "model/x3d+xml": model_x3d_xml, "model/x3d-vrml": model_x3d_vrml2, "text/cache-manifest": text_cache_manifest, "text/calendar": text_calendar, "text/coffeescript": text_coffeescript, "text/css": text_css, "text/csv": text_csv, "text/html": text_html, "text/jade": text_jade, "text/jsx": text_jsx, "text/less": text_less, "text/markdown": text_markdown, "text/mathml": text_mathml, "text/mdx": text_mdx, "text/n3": text_n3, "text/plain": text_plain, "text/richtext": text_richtext, "text/rtf": text_rtf, "text/sgml": text_sgml, "text/shex": text_shex, "text/slim": text_slim, "text/spdx": text_spdx, "text/stylus": text_stylus, "text/tab-separated-values": text_tab_separated_values, "text/troff": text_troff, "text/turtle": text_turtle, "text/uri-list": text_uri_list, "text/vcard": text_vcard, "text/vtt": text_vtt, "text/xml": text_xml, "text/yaml": text_yaml, "video/3gpp": video_3gpp, "video/3gpp2": video_3gpp2, "video/h261": video_h261, "video/h263": video_h263, "video/h264": video_h264, "video/iso.segment": video_iso_segment, "video/jpeg": video_jpeg, "video/jpm": video_jpm, "video/mj2": video_mj2, "video/mp2t": video_mp2t, "video/mp4": video_mp4, "video/mpeg": video_mpeg, "video/ogg": video_ogg, "video/quicktime": video_quicktime, "video/webm": video_webm };

// src/main/resources/topdomain/clientmyadmin/mime/mod.js
var Mime = class {
  #types = /* @__PURE__ */ Object.create(null);
  #extensions = /* @__PURE__ */ Object.create(null);
  constructor(...args) {
    for (let i = 0; i < args.length; i++) {
      this.define(args[i]);
    }
  }
  define(typeMap, force) {
    for (let type in typeMap) {
      const extensions = typeMap[type].map((t2) => t2.toLowerCase());
      type = type.toLowerCase();
      for (let i = 0; i < extensions.length; i++) {
        const ext = extensions[i];
        if (ext[0] === "*")
          continue;
        if (!force && ext in this.#types) {
          throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this.#types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
        }
        this.#types[ext] = type;
      }
      if (force || !this.#extensions[type]) {
        const ext = extensions[0];
        this.#extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
      }
    }
  }
  getType(path) {
    const last = path.replace(/^.*[/\\]/, "").toLowerCase();
    const ext = last.replace(/^.*\./, "").toLowerCase();
    const hasPath = last.length < path.length;
    const hasDot = ext.length < last.length - 1;
    return (hasDot || !hasPath) && this.#types[ext];
  }
  getExtension(type) {
    type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
    return type && this.#extensions[type.toLowerCase()];
  }
};
var mod_default = new Mime(standard_default);

// src/main/resources/topdomain/clientmyadmin/shared/zip64/read.js
var ERR_BAD_FORMAT = "File format is not recognized.";
var ZIP_COMMENT_MAX = 65536;
var EOCDR_MIN = 22;
var EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;
var MAX_VALUE_32BITS = 4294967295;
var decoder = new TextDecoder();
var uint16e = (b, n) => b[n] | b[n + 1] << 8;
var GZIP_HEADER = Uint8Array.from([
  31,
  139,
  8,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function getRawChunk(file, entry) {
  return file.slice(entry.offset + 26, entry.offset + 30).arrayBuffer().then((ab) => {
    const bytes = new Uint8Array(ab);
    const localFileOffset = uint16e(bytes, 0) + uint16e(bytes, 2) + 30;
    const start = entry.offset + localFileOffset;
    const end = start + entry.compressedSize;
    return file.slice(start, end);
  });
}
var Entry = class {
  #dataView;
  #fileLike;
  #extraFields = {};
  #name;
  type = "";
  constructor(dataView, fileLike) {
    if (dataView.getUint32(0) !== 1347092738) {
      throw new Error("ERR_BAD_FORMAT");
    }
    const dv = dataView;
    this.#dataView = dv;
    this.#fileLike = fileLike;
    for (let i = 46 + this.filenameLength; i < dv.byteLength; ) {
      const id = dv.getUint16(i, true);
      const len = dv.getUint16(i + 2, true);
      const start = dv.byteOffset + i + 4;
      this.#extraFields[id] = new DataView(dv.buffer.slice(start, start + len));
      i += len + 4;
    }
  }
  get versionMadeBy() {
    return this.#dataView.getUint16(4, true);
  }
  get versionNeeded() {
    return this.#dataView.getUint16(6, true);
  }
  get bitFlag() {
    return this.#dataView.getUint16(8, true);
  }
  get encrypted() {
    return (this.bitFlag & 1) === 1;
  }
  get compressionMethod() {
    return this.#dataView.getUint16(10, true);
  }
  get crc32() {
    return this.#dataView.getUint32(16, true);
  }
  get compressedSize() {
    return this.#dataView.getUint32(20, true);
  }
  get filenameLength() {
    return this.#dataView.getUint16(28, true);
  }
  get extraFieldLength() {
    return this.#dataView.getUint16(30, true);
  }
  get commentLength() {
    return this.#dataView.getUint16(32, true);
  }
  get diskNumberStart() {
    return this.#dataView.getUint16(34, true);
  }
  get internalFileAttributes() {
    return this.#dataView.getUint16(36, true);
  }
  get externalFileAttributes() {
    return this.#dataView.getUint32(38, true);
  }
  get directory() {
    return !!(this.#dataView.getUint8(38) & 16) || this.size === 0 && this.name.endsWith("/");
  }
  get offset() {
    return this.#dataView.getUint32(42, true);
  }
  get zip64() {
    return this.#dataView.getUint32(24, true) === MAX_VALUE_32BITS;
  }
  get comment() {
    const dv = this.#dataView;
    const uint8 = new Uint8Array(dv.buffer, dv.byteOffset + this.filenameLength + this.extraFieldLength + 46, this.commentLength);
    return decoder.decode(uint8);
  }
  get lastModified() {
    const t2 = this.#dataView.getUint32(12, true);
    return new Date((t2 >> 25 & 127) + 1980, (t2 >> 21 & 15) - 1, t2 >> 16 & 31, t2 >> 11 & 31, t2 >> 5 & 63, (t2 & 31) << 1).getTime();
  }
  set lastModified(v) {
    if (typeof v !== "number")
      throw new TypeError("lastModified must be a number");
    const date = new Date(v);
    const val = date.getFullYear() - 1980 << 25 | date.getMonth() + 1 << 21 | date.getDate() << 16 | date.getHours() << 11 | date.getMinutes() << 5 | date.getSeconds() >> 1;
    this.#dataView.setUint32(12, val, true);
  }
  get name() {
    if (this.#name !== void 0)
      return this.#name;
    if (!this.bitFlag && this.#extraFields[28789]) {
      return this.#name = decoder.decode(this.#extraFields[28789].buffer.slice(5));
    }
    const dv = this.#dataView;
    const uint8 = new Uint8Array(dv.buffer, dv.byteOffset + 46, this.filenameLength);
    return this.#name = decoder.decode(uint8);
  }
  set name(v) {
    if (typeof v !== "string")
      throw new TypeError("name must be a string");
    this.#name = v;
  }
  get size() {
    const size = this.#dataView.getUint32(24, true);
    return size === MAX_VALUE_32BITS ? this.#extraFields[1].getUint8(0) : size;
  }
  set size(size) {
    if (size > MAX_VALUE_32BITS) {
      this.#extraFields[1] = new DataView(new ArrayBuffer(1));
      this.#extraFields[1].setUint8(0, size);
    } else {
    }
  }
  rawBytes() {
    return getRawChunk(this.#fileLike, this);
  }
  stream() {
    const ts = new TransformStream();
    const crc = this.crc32;
    const uncompressedSize = this.size;
    this.rawBytes().then((chunk) => {
      chunk.stream().pipeTo(ts.writable);
    });
    return this.compressionMethod ? ts.readable.pipeThrough(new TransformStream({
      start(controller) {
        controller.enqueue(GZIP_HEADER);
      },
      flush(controller) {
        const tmp = new DataView(new ArrayBuffer(8));
        tmp.setUint32(0, crc, true);
        tmp.setUint32(4, uncompressedSize, true);
        controller.enqueue(new Uint8Array(tmp.buffer));
      }
    })).pipeThrough(new DecompressionStream("gzip")) : ts.readable;
  }
  async arrayBuffer() {
    if (!this.compressionMethod) {
      return getRawChunk(this.#fileLike, this).then((c) => c.arrayBuffer());
    }
    return new Response(this.stream()).arrayBuffer().catch((e) => {
      throw new Error(`Failed to read Entry
${e}`);
    });
  }
  async text() {
    if (!this.compressionMethod) {
      return getRawChunk(this.#fileLike, this).then((c) => c.text());
    }
    return new Response(this.stream()).text().catch((e) => {
      throw new Error(`Failed to read Entry
${e}`);
    });
  }
  async file() {
    const reader = this.compressionMethod ? this.arrayBuffer() : getRawChunk(this.#fileLike, this);
    return reader.then((chunk) => new File([chunk], this.name, { lastModified: this.lastModified })).catch((err) => {
      throw new Error(`Failed to read Entry
${err}`);
    });
  }
};
function getBigInt64(view, position, littleEndian = false) {
  return view.getBigInt64(position, littleEndian);
}
async function* Reader(file) {
  if (file.size < EOCDR_MIN)
    throw new Error(ERR_BAD_FORMAT);
  async function doSeek(length) {
    const ab = await file.slice(file.size - length).arrayBuffer();
    const bytes2 = new Uint8Array(ab);
    for (let i = bytes2.length - EOCDR_MIN; i >= 0; i--) {
      if (bytes2[i] === 80 && bytes2[i + 1] === 75 && bytes2[i + 2] === 5 && bytes2[i + 3] === 6) {
        return new DataView(bytes2.buffer, i, EOCDR_MIN);
      }
    }
    return null;
  }
  let dv = await doSeek(EOCDR_MIN) || await doSeek(Math.min(EOCDR_MAX, file.size));
  if (!dv)
    throw new Error(ERR_BAD_FORMAT);
  let fileslength = dv.getUint16(8, true);
  let centralDirSize = dv.getUint32(12, true);
  let centralDirOffset = dv.getUint32(16, true);
  const isZip64 = centralDirOffset === MAX_VALUE_32BITS;
  if (isZip64) {
    const l = -dv.byteLength - 20;
    dv = new DataView(await file.slice(l, -dv.byteLength).arrayBuffer());
    const signature = dv.getUint32(0, true);
    const diskWithZip64CentralDirStart = dv.getUint32(4, true);
    const relativeOffsetEndOfZip64CentralDir = Number(getBigInt64(dv, 8, true));
    const numberOfDisks = dv.getUint32(16, true);
    const zip64centralBlob = file.slice(relativeOffsetEndOfZip64CentralDir, l);
    dv = new DataView(await zip64centralBlob.arrayBuffer());
    fileslength = Number(getBigInt64(dv, 32, true));
    centralDirSize = Number(getBigInt64(dv, 40, true));
    centralDirOffset = Number(getBigInt64(dv, 48, true));
  }
  if (centralDirOffset < 0 || centralDirOffset >= file.size) {
    throw new Error(ERR_BAD_FORMAT);
  }
  const start = centralDirOffset;
  const end = centralDirOffset + centralDirSize;
  const blob = file.slice(start, end);
  const bytes = new Uint8Array(await blob.arrayBuffer());
  for (let i = 0, index = 0; i < fileslength; i++) {
    const size = uint16e(bytes, index + 28) + uint16e(bytes, index + 30) + uint16e(bytes, index + 32) + 46;
    if (index + size > bytes.length) {
      throw new Error("Invalid ZIP file.");
    }
    yield new Entry(new DataView(bytes.buffer, index, size), file);
    index += size;
  }
}
var read_default = Reader;

// node_modules/native-file-system-adapter/src/getOriginPrivateDirectory.js
if (globalThis.DataTransferItem && !DataTransferItem.prototype.getAsFileSystemHandle) {
  DataTransferItem.prototype.getAsFileSystemHandle = async function() {
    const entry = this.webkitGetAsEntry();
    const [
      { FileHandle: FileHandle3, FolderHandle: FolderHandle3 },
      { FileSystemDirectoryHandle: FileSystemDirectoryHandle2 },
      { FileSystemFileHandle: FileSystemFileHandle2 }
    ] = await Promise.all([
      Promise.resolve().then(() => (init_sandbox(), sandbox_exports)),
      Promise.resolve().then(() => (init_FileSystemDirectoryHandle(), FileSystemDirectoryHandle_exports)),
      Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports))
    ]);
    return entry.isFile ? new FileSystemFileHandle2(new FileHandle3(entry, false)) : new FileSystemDirectoryHandle2(new FolderHandle3(entry, false));
  };
}
async function getOriginPrivateDirectory(driver, options = {}) {
  if (!driver) {
    return globalThis.navigator?.storage?.getDirectory() || globalThis.getOriginPrivateDirectory();
  }
  const { FileSystemDirectoryHandle: FileSystemDirectoryHandle2 } = await Promise.resolve().then(() => (init_FileSystemDirectoryHandle(), FileSystemDirectoryHandle_exports));
  const module = await driver;
  const sandbox = await (module.default ? module.default(options) : module(options));
  return new FileSystemDirectoryHandle2(sandbox);
}
var getOriginPrivateDirectory_default = getOriginPrivateDirectory;

// node_modules/native-file-system-adapter/src/adapters/jsdelivr.js
init_util();
var { GONE, MISMATCH, SYNTAX, DISALLOWED: DISALLOWED2 } = errors;
var FileHandle2 = class {
  constructor(entry, root2) {
    this.name = entry.name;
    this.kind = "file";
    this._deleted = false;
    this._root = root2;
    this._entry = entry;
    this.writable = false;
    this.readable = true;
  }
  async getFile() {
    const res = await fetch(`https://cdn.jsdelivr.net/${this._root}/${this.name}`);
    const blob = await res.blob();
    return new File([blob], this.name, {
      type: blob.type,
      lastModified: this._entry.time
    });
  }
  async createWritable() {
    throw new DOMException(...DISALLOWED2);
  }
  async isSameEntry(other) {
    return this === other;
  }
};
function toDic(files, root2) {
  const dic = {};
  for (const x of files) {
    x.time = +new Date(x.time);
    if (x.type === "file") {
      dic[x.name] = new FileHandle2(x, root2);
    } else {
      dic[x.name] = new FolderHandle2(x.files, `${root2}/${x.name}`, x.name);
    }
  }
  return dic;
}
var FolderHandle2 = class {
  constructor(files, root2, name = "") {
    this.name = name;
    this.kind = "directory";
    this._deleted = false;
    this._entries = toDic(files, root2);
    this.writable = false;
    this.readable = true;
  }
  async *entries() {
    yield* Object.entries(this._entries);
  }
  async isSameEntry(other) {
    return this === other;
  }
  async getDirectoryHandle(name, opts) {
    if (this._deleted)
      throw new DOMException(...GONE);
    const entry = this._entries[name];
    if (entry) {
      if (entry instanceof FileHandle2) {
        throw new DOMException(...MISMATCH);
      } else {
        return entry;
      }
    } else {
      if (opts.create) {
        throw new DOMException(...DISALLOWED2);
      } else {
        throw new DOMException(...GONE);
      }
    }
  }
  async getFileHandle(name, opts) {
    const entry = this._entries[name];
    const isFile = entry instanceof FileHandle2;
    if (entry && isFile)
      return entry;
    if (entry && !isFile)
      throw new DOMException(...MISMATCH);
    if (!entry && !opts.create)
      throw new DOMException(...GONE);
    if (!entry && opts.create) {
      throw new DOMException(...DISALLOWED2);
    }
  }
  async removeEntry(name, opts) {
    throw new DOMException(...DISALLOWED2);
  }
};
var jsdelivr_default = async (root2) => {
  const res = await fetch(`https://data.jsdelivr.com/v1/package/${root2}`);
  const { files } = await res.json();
  return new FolderHandle2(files, root2);
};

// src/main/resources/topdomain/shimport.js
function get_alias(specifiers, name) {
  var i = specifiers.length;
  while (i--) {
    if (specifiers[i].name === name) {
      return specifiers[i].as;
    }
  }
}
function importDecl(str, start, end, specifiers, source) {
  var name = get_alias(specifiers, "*") || get_alias(specifiers, "default");
  return {
    start,
    end,
    source,
    name,
    specifiers,
    toString() {
      return "/*" + str.slice(start, end) + "*/";
    }
  };
}
function exportDefaultDeclaration(str, start, end) {
  var match = /^\s*(?:(class)(\s+extends|\s*{)|(function)\s*\()/.exec(str.slice(end));
  if (match) {
    end += match[0].length;
    var name = "__default_export";
    return {
      start,
      end,
      name,
      as: "default",
      toString() {
        return match[1] ? "class " + name + match[2] : "function " + name + "(";
      }
    };
  }
  return {
    start,
    end,
    toString() {
      return "__exports.default =";
    }
  };
}
function exportSpecifiersDeclaration(str, start, specifiersStart, specifiersEnd, end, source) {
  var specifiers = processSpecifiers(str.slice(specifiersStart + 1, specifiersEnd - 1).trim());
  return {
    start,
    end,
    source,
    toString(nameBySource) {
      var name = source && nameBySource.get(source);
      return specifiers.map(function(s) {
        return "__exports." + s.as + " = " + (name ? name + "." + s.name : s.name) + "; ";
      }).join("") + "/*" + str.slice(start, end) + "*/";
    }
  };
}
function exportDecl(str, start, c) {
  var end = c;
  while (str[c] && /\S/.test(str[c])) {
    c += 1;
  }
  while (str[c] && !/\S/.test(str[c])) {
    c += 1;
  }
  var nameStart = c;
  while (str[c] && !punctuatorChars.test(str[c]) && !isWhitespace(str[c])) {
    c += 1;
  }
  var nameEnd = c;
  var name = str.slice(nameStart, nameEnd);
  if (name === "function") {
    while (str[c] && /\S/.test(str[c])) {
      c += 1;
    }
    while (str[c] && !/\S/.test(str[c])) {
      c += 1;
    }
    nameStart = c;
    while (str[c] && !punctuatorChars.test(str[c]) && !isWhitespace(str[c])) {
      c += 1;
    }
    nameEnd = c;
    name = str.slice(nameStart, nameEnd);
  }
  return {
    start,
    end,
    name,
    toString() {
      return "";
    }
  };
}
function exportStarDeclaration(str, start, end, source) {
  return {
    start,
    end,
    source,
    toString(nameBySource) {
      return "Object.assign(__exports, " + nameBySource.get(source) + "); /*" + str.slice(start, end) + "*/";
    }
  };
}
var keywords = /\b(case|default|delete|do|else|in|instanceof|new|return|throw|typeof|void)\s*$/;
var punctuators = /(^|\{|\(|\[\.|;|,|<|>|<=|>=|==|!=|===|!==|\+|-|\*\%|<<|>>|>>>|&|\||\^|!|~|&&|\|\||\?|:|=|\+=|-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|\/=|\/)\s*$/;
var ambiguous = /(\}|\)|\+\+|--)\s*$/;
var punctuatorChars = /[{}()[.;,<>=+\-*%&|\^!~?:/]/;
var keywordChars = /[a-zA-Z_$0-9]/;
var whitespace_obj = { " ": 1, "	": 1, "\n": 1, "\r": 1, "\f": 1, "\v": 1, "\xA0": 1, "\u2028": 1, "\u2029": 1 };
function isWhitespace(char) {
  return char in whitespace_obj;
}
function isQuote(char) {
  return char === "'" || char === '"';
}
var namespaceImport = /^\*\s+as\s+(\w+)$/;
var defaultAndStarImport = /(\w+)\s*,\s*\*\s*as\s*(\w+)$/;
var defaultAndNamedImport = /(\w+)\s*,\s*{(.+)}$/;
function processImportSpecifiers(str) {
  var match = namespaceImport.exec(str);
  if (match) {
    return [{ name: "*", as: match[1] }];
  }
  match = defaultAndStarImport.exec(str);
  if (match) {
    return [{ name: "default", as: match[1] }, { name: "*", as: match[2] }];
  }
  match = defaultAndNamedImport.exec(str);
  if (match) {
    return [{ name: "default", as: match[1] }].concat(processSpecifiers(match[2].trim()));
  }
  if (str[0] === "{") {
    return processSpecifiers(str.slice(1, -1).trim());
  }
  if (str) {
    return [{ name: "default", as: str }];
  }
  return [];
}
function processSpecifiers(str) {
  return str ? str.split(",").map(function(part) {
    var ref = part.trim().split(/[^\S]+/);
    var name = ref[0];
    var as = ref[2];
    return { name, as: as || name };
  }) : [];
}
function getImportDeclaration(str, i) {
  var start = i;
  var specifierStart = i += 6;
  while (str[i] && isWhitespace(str[i])) {
    i += 1;
  }
  while (str[i] && !isQuote(str[i])) {
    i += 1;
  }
  var specifierEnd = i;
  var sourceStart = i += 1;
  while (str[i] && !isQuote(str[i])) {
    i += 1;
  }
  var sourceEnd = i++;
  return importDecl(str, start, i, processImportSpecifiers(str.slice(specifierStart, specifierEnd).replace(/from\s*$/, "").trim()), str.slice(sourceStart, sourceEnd));
}
function getImportStatement(i) {
  return {
    start: i,
    end: i + 6,
    toString() {
      return "__import";
    }
  };
}
var importMetaUrlPattern = /^import\s*\.\s*meta\s*\.\s*url/;
function getImportMetaUrl(str, start, id) {
  var match = importMetaUrlPattern.exec(str.slice(start));
  if (match) {
    return {
      start,
      end: start + match[0].length,
      toString() {
        return JSON.stringify("" + id);
      }
    };
  }
}
function getExportDeclaration(str, i) {
  var start = i;
  i += 6;
  while (str[i] && isWhitespace(str[i])) {
    i += 1;
  }
  var declarationStart = i;
  if (str[i] === "{") {
    while (str[i] !== "}") {
      i += 1;
    }
    i += 1;
    var specifiersEnd = i;
    var source = null;
    while (isWhitespace(str[i])) {
      i += 1;
    }
    if (/^from[\s\n'"]/.test(str.slice(i, i + 5))) {
      i += 4;
      while (isWhitespace(str[i])) {
        i += 1;
      }
      while (str[i] && !isQuote(str[i])) {
        i += 1;
      }
      var sourceStart = i += 1;
      while (str[i] && !isQuote(str[i])) {
        i += 1;
      }
      source = str.slice(sourceStart, i);
      i += 1;
    }
    return exportSpecifiersDeclaration(str, start, declarationStart, specifiersEnd, i, source);
  }
  if (str[i] === "*") {
    i += 1;
    while (isWhitespace(str[i])) {
      i += 1;
    }
    i += 4;
    while (str[i] && !isQuote(str[i])) {
      i += 1;
    }
    var sourceStart$1 = i += 1;
    while (str[i] && !isQuote(str[i])) {
      i += 1;
    }
    var sourceEnd = i++;
    return exportStarDeclaration(str, start, i, str.slice(sourceStart$1, sourceEnd));
  }
  if (/^default\b/.test(str.slice(i, i + 8))) {
    return exportDefaultDeclaration(str, start, declarationStart + 7);
  }
  return exportDecl(str, start, declarationStart);
}
function find(str, id) {
  var escapedFrom;
  var regexEnabled = true;
  var pfixOp = false;
  var stack = [];
  var lsci = -1;
  var lsc = function() {
    return str[lsci];
  };
  var parenMatches = {};
  var openingParenPositions = {};
  var parenDepth = 0;
  var importDeclarations = [];
  var importStatements = [];
  var importMetaUrls = [];
  var exportDeclarations = [];
  function tokenClosesExpression() {
    if (lsc() === ")") {
      var c = parenMatches[lsci];
      while (isWhitespace(str[c - 1])) {
        c -= 1;
      }
      return !/(if|while)$/.test(str.slice(c - 5, c));
    }
    return true;
  }
  var base2 = {
    pattern: /(?:(\()|(\))|({)|(})|(")|(')|(\/\/)|(\/\*)|(\/)|(`)|(import)|(export)|(\+\+|--))/g,
    handlers: [
      function(i) {
        lsci = i;
        openingParenPositions[parenDepth++] = i;
      },
      function(i) {
        lsci = i;
        parenMatches[i] = openingParenPositions[--parenDepth];
      },
      function(i) {
        lsci = i;
        stack.push(base2);
      },
      function(i) {
        lsci = i;
        return stack.pop();
      },
      function(i) {
        stack.push(base2);
        return double_quoted;
      },
      function(i) {
        stack.push(base2);
        return single_quoted;
      },
      function(i) {
        return line_comment;
      },
      function(i) {
        return block_comment;
      },
      function(i) {
        var b = i;
        while (b > 0 && isWhitespace(str[b - 1])) {
          b -= 1;
        }
        if (b > 0) {
          var a = b;
          if (punctuatorChars.test(str[a - 1])) {
            while (a > 0 && punctuatorChars.test(str[a - 1])) {
              a -= 1;
            }
          } else {
            while (a > 0 && keywordChars.test(str[a - 1])) {
              a -= 1;
            }
          }
          var token = str.slice(a, b);
          regexEnabled = token ? keywords.test(token) || punctuators.test(token) || ambiguous.test(token) && !tokenClosesExpression() : false;
        } else {
          regexEnabled = true;
        }
        return slash;
      },
      function(i) {
        return template_string;
      },
      function(i) {
        if (i === 0 || isWhitespace(str[i - 1]) || punctuatorChars.test(str[i - 1])) {
          var j2 = i + 6;
          var char;
          do {
            char = str[j2++];
          } while (isWhitespace(char));
          var hasWhitespace = j2 > i + 7;
          if (/^['"{*]$/.test(char) || hasWhitespace && /^[a-zA-Z_$]$/.test(char)) {
            var d = getImportDeclaration(str, i);
            importDeclarations.push(d);
            p3 = d.end;
          } else if (char === "(") {
            var s = getImportStatement(i);
            importStatements.push(s);
            p3 = s.end;
          } else if (char === ".") {
            var u = getImportMetaUrl(str, i, id);
            if (u) {
              importMetaUrls.push(u);
              p3 = u.end;
            }
          }
        }
      },
      function(i) {
        if (i === 0 || isWhitespace(str[i - 1]) || punctuatorChars.test(str[i - 1])) {
          if (/export[\s\n{]/.test(str.slice(i, i + 7))) {
            var d = getExportDeclaration(str, i);
            exportDeclarations.push(d);
            p3 = d.end;
          }
        }
      },
      function(i) {
        pfixOp = !pfixOp && str[i - 1] === "+";
      }
    ]
  };
  var slash = {
    pattern: /(?:(\[)|(\\)|(.))/g,
    handlers: [
      function(i) {
        return regexEnabled ? regex_character : base2;
      },
      function(i) {
        return escapedFrom = regex, escaped;
      },
      function(i) {
        return regexEnabled && !pfixOp ? regex : base2;
      }
    ]
  };
  var regex = {
    pattern: /(?:(\[)|(\\)|(\/))/g,
    handlers: [
      function() {
        return regex_character;
      },
      function() {
        return escapedFrom = regex, escaped;
      },
      function() {
        return base2;
      }
    ]
  };
  var regex_character = {
    pattern: /(?:(\])|(\\))/g,
    handlers: [
      function() {
        return regex;
      },
      function() {
        return escapedFrom = regex_character, escaped;
      }
    ]
  };
  var double_quoted = {
    pattern: /(?:(\\)|("))/g,
    handlers: [
      function() {
        return escapedFrom = double_quoted, escaped;
      },
      function() {
        return stack.pop();
      }
    ]
  };
  var single_quoted = {
    pattern: /(?:(\\)|('))/g,
    handlers: [
      function() {
        return escapedFrom = single_quoted, escaped;
      },
      function() {
        return stack.pop();
      }
    ]
  };
  var escaped = {
    pattern: /(.)/g,
    handlers: [
      function() {
        return escapedFrom;
      }
    ]
  };
  var template_string = {
    pattern: /(?:(\${)|(\\)|(`))/g,
    handlers: [
      function() {
        stack.push(template_string);
        return base2;
      },
      function() {
        return escapedFrom = template_string, escaped;
      },
      function() {
        return base2;
      }
    ]
  };
  var line_comment = {
    pattern: /((?:\n|$))/g,
    handlers: [
      function() {
        return base2;
      }
    ]
  };
  var block_comment = {
    pattern: /(\*\/)/g,
    handlers: [
      function() {
        return base2;
      }
    ]
  };
  var state = base2;
  var p3 = 0;
  while (p3 < str.length) {
    state.pattern.lastIndex = p3;
    var match = state.pattern.exec(str);
    if (!match) {
      if (stack.length > 0 || state !== base2) {
        throw new Error("Unexpected end of file");
      }
      break;
    }
    p3 = match.index + match[0].length;
    for (var j = 1; j < match.length; j += 1) {
      if (match[j]) {
        state = state.handlers[j - 1](match.index) || state;
        break;
      }
    }
  }
  return [
    importDeclarations,
    importStatements,
    importMetaUrls,
    exportDeclarations
  ];
}
function transform(source, id) {
  var ref = find(source, id);
  var importDeclarations = ref[0];
  var importStatements = ref[1];
  var importMetaUrls = ref[2];
  var exportDeclarations = ref[3];
  var nameBySource = /* @__PURE__ */ new Map();
  importDeclarations.forEach(function(d) {
    if (nameBySource.has(d.source)) {
      return;
    }
    nameBySource.set(d.source, d.name || "__dep_" + nameBySource.size);
  });
  exportDeclarations.forEach(function(d) {
    if (!d.source) {
      return;
    }
    if (nameBySource.has(d.source)) {
      return;
    }
    nameBySource.set(d.source, d.name || "__dep_" + nameBySource.size);
  });
  var deps = Array.from(nameBySource.keys()).map(function(s) {
    return "'" + s + "'";
  }).join(", ");
  var names = ["__import", "__exports"].concat(Array.from(nameBySource.values())).join(", ");
  var hoisted = [];
  importDeclarations.forEach(function(decl) {
    var name = nameBySource.get(decl.source);
    decl.specifiers.sort(function(a, b) {
      if (a.name === "default") {
        return 1;
      }
      if (b.name === "default") {
        return -1;
      }
    }).forEach(function(s) {
      if (s.name !== "*") {
        var assignment = s.name === "default" && s.as === name ? s.as + " = " + name + ".default; " : "var " + s.as + " = " + name + "." + s.name + "; ";
        hoisted.push(assignment);
      }
    });
  });
  var transformed = "__shimport__.define('" + id + "', [" + deps + "], function(" + names + "){ " + hoisted.join("");
  var ranges = importDeclarations.concat(importStatements, importMetaUrls, exportDeclarations).sort(function(a, b) {
    return a.start - b.start;
  });
  var c = 0;
  for (var i = 0; i < ranges.length; i += 1) {
    var range = ranges[i];
    transformed += source.slice(c, range.start) + range.toString(nameBySource);
    c = range.end;
  }
  transformed += source.slice(c);
  exportDeclarations.forEach(function(d) {
    if (d.name) {
      transformed += "\n__exports." + (d.as || d.name) + " = " + d.name + ";";
    }
  });
  transformed += "\n});\n//# sourceURL=" + id;
  return transformed;
}
var promises = {};
function define(id, deps, factory) {
  var __import = function(dep) {
    return load(new URL(dep, id).toString());
  };
  return Promise.all(deps.map(__import)).then(function(__deps) {
    var __exports = {};
    factory.apply(void 0, [__import, __exports].concat(__deps));
    return __exports;
  });
}
async function load(url) {
  return promises[url] ??= fetch(url).then((r) => {
    if (!r.ok)
      throw new Error(url + " returned non ok response");
    return r.text();
  }).then((text) => evaluate(transform(text, url)));
}
function evaluate(code) {
  return (0, eval)(code);
}
globalThis.__shimport__ = {
  define,
  load,
  transform
};

// src/main/resources/topdomain/sw-container.js
var { hasOwn } = Object;
var base = location.origin.includes("localhost") ? "http://localhost:4445" : "https://localwebcontainer.com";
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
async function cacheFirst(req) {
  const cache = await caches.open("v1");
  const cached = await cache.match(req);
  if (cached)
    return cached;
  const res = await fetch(req);
  await cache.put(req, res.clone());
  return res;
}
extern_default.addEventListener("install", () => {
  caches.open("v1").then((cache) => cache.addAll([
    "https://sindresorhus.com/github-markdown-css/github-markdown.css",
    base + "/clientmyadmin/index.html",
    base + "/clientmyadmin/json.html",
    base + "/clientmyadmin/style.css",
    base + "/clientmyadmin/markdown.html",
    base + "/clientmyadmin/style.html",
    base + "/clientmyadmin/allowread.html",
    base + "/clientmyadmin/shared/kv.js",
    base + "/clientmyadmin/shared/fs.js"
  ]));
});
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  return hasOwn(prot, "isPrototypeOf");
}
var origFetch = globalThis.fetch;
globalThis.fetch = async function fetch2(...a) {
  if (!(a[0] instanceof Request))
    return fetch2(new Request(...a));
  if (a[0].url.startsWith(origin)) {
    const pathname = new URL(a[0].url).pathname.replace(/^\/+/, "");
    const entries = /* @__PURE__ */ new Map();
    const x = await kv_default("get", "root");
    root ??= x;
    if (root?.type === "jsdelivr") {
      root = await getOriginPrivateDirectory_default(jsdelivr_default, root.root);
    }
    if (root) {
      globalThis.x = root;
      const x2 = await root.queryPermission({ mode: "read" });
      if (x2 === "prompt")
        return fetch2(`${base}/clientmyadmin/allowread.html`);
      let p3 = "";
      try {
        p3 = decodeURIComponent(pathname);
      } catch (e) {
        return new Response("Not Found.", {
          status: 404,
          statusText: "Not found"
        });
      }
      const handle = await fs_default.open(root, p3);
      if (handle.kind === "file") {
        return handle.getFile().then(renderFile);
      } else {
        for await (const [name, entry2] of handle) {
          entries.set(`${pathname}/${name}`.replace(/^\//, ""), entry2);
        }
        return renderTreeList(entries);
      }
    }
    const zipBlob = await kv_default("get", "zip-file");
    if (!zipBlob)
      return Response.redirect("/clientmyadmin");
    for await (const entry2 of read_default(zipBlob)) {
      if (!entry2.directory)
        entries.set(entry2.name, entry2);
    }
    const entry = entries.get(pathname);
    return entry ? renderFile(entry) : renderTreeList(entries);
  }
  return caches.match(a[0]).then((res) => {
    return res || origFetch(a[0]);
  });
};
var p2;
async function init() {
  const { initialize } = await load(base + "/esbuild.min.js");
  const res = await cacheFirst(base + "/esbuild.wasm");
  await initialize({
    worker: false,
    wasmModule: await WebAssembly.compileStreaming(res)
  });
}
async function _import(url, opts) {
  await (p2 ??= init());
  const { build } = await load(base + "/esbuild.min.js");
  const options = {
    entryPoints: [url],
    format: "esm",
    minify: true,
    globalName: "xyz",
    sourcemap: true,
    bundle: true,
    plugins: [httpPlugin],
    ...opts
  };
  console.groupCollapsed("esbuild building " + url);
  console.info("options", options);
  console.groupEnd();
  const result = await build(options);
  return new TextDecoder().decode(result.outputFiles[0].contents);
}
var router = Router();
var root;
router.all("*", async (ctx) => {
  ctx.headers;
});
router.get((o) => ["script", "worker"].includes(o.request.destination), (ctx) => {
  if (ctx.request.url.endsWith(".ts")) {
    return _import(ctx.request.url).then((str) => new Response(str, {
      headers: { "content-type": "application/javascript" }
    }));
  }
});
router.get((o) => o.url.searchParams.get("installFrom"), async (ctx) => {
  root = void 0;
  return fetch(`${base}/clientmyadmin/installfrom.html`);
});
router.get("/clientmyadmin", (ctx) => {
  return Response.redirect("/clientmyadmin/", 302);
});
router.get("/clientmyadmin/clients", async (o) => {
  const clients = await extern_default.clients.matchAll();
  const m = clients.map((client) => {
    const res = {};
    for (const key in client) {
      if (typeof client[key] !== "function") {
        res[key] = client[key];
      }
    }
    return res;
  });
  return Response.json({
    self: o.event.clientId,
    clients: m
  });
});
router.get((o) => o.request.destination === "document" && o.request.url.includes("/clientmyadmin/inspector"), (ctx) => fetch(`${base}/clientmyadmin/inspector.html`));
router.get(location.origin + "/clientmyadmin/*", (ctx) => {
  ctx.request = new Request(ctx.request.url.replace(location.origin, base));
  ctx.url = new URL(ctx.request.url);
});
var singleton = {};
router.all("/functions/*", async (ctx) => {
  const url = new URL(ctx.url.pathname, location.origin);
  const path = url.toString();
  let module;
  if (url.pathname.endsWith(".ts")) {
    singleton[path] ??= _import(path, { format: "iife" }).then(load2);
    module = await singleton[path];
  } else {
    module = await load(path);
  }
  let method = ctx.request.method;
  method = method[0].toUpperCase() + method.slice(1).toLowerCase();
  const fn = module[`onRequest${method}`];
  return fn?.(ctx);
});
router.all((o) => o.request.destination === "document" && o.url.pathname.toLowerCase().endsWith(".md"), (_) => fetch(`${base}/clientmyadmin/markdown.html`));
router.all((o) => o.request.destination === "document" && o.url.pathname.toLowerCase().endsWith(".json"), (_) => fetch(`${base}/clientmyadmin/json.html`));
router.all({}, async (ctx) => {
  return fetch(ctx.request);
});
function errorHandler(error) {
  console.error(error);
  return new Response(error.stack || "Server Error", {
    status: error.status || 200
  });
}
function convertToResponse(thing) {
  if (thing instanceof Response)
    return thing;
  if (typeof thing === void 0) {
    return new Response("Not Found.", { status: 404 });
  }
  if (Array.isArray(thing) || isPlainObject(thing)) {
    return Response.json(thing);
  }
  return new Response(thing);
}
extern_default.addEventListener("fetch", (evt) => evt.respondWith(router.handle(evt).then(convertToResponse).catch(errorHandler)));
var t = (evt, fn) => evt.waitUntil(fn().catch(console.error));
extern_default.onactivate = (evt) => t(evt, () => extern_default.clients.claim());
extern_default.onmessage = async (evt) => {
  const { data, ports } = evt;
  if (data !== "claimMe")
    return;
  t(evt, async () => {
    await extern_default.clients.claim();
    ports[0].postMessage("claimed");
  });
};
function renderTreeList(entries) {
  const files = Array.from(entries.keys()).sort();
  const html = `<!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <meta name='viewport' content='width=device-width, initial-scale=1'>
        <link rel="stylesheet" href="/clientmyadmin/style.css">
        <style>
          body {
            margin: 20px;
            max-width: initial;
          }
        </style>
      </head>
      <body>
        <ul>
          ${files.map((file) => {
    return entries.get(file).crc32 ? `<li><a href="/${file}">${file}</a> ${entries.get(file).size.toString().padStart(6, " ")}b </li>` : `<li><a href="/${file}">${file}</a></li>`;
  }).join("")}
        </ul>
      </body>
    </html>`;
  return new Response(html, {
    headers: { "content-type": "text/html" },
    status: 404,
    statusText: "Not found"
  });
}
function load2(str) {
  const body = `${str}; 
 return xyz`;
  const mod = new Function(body)();
  const result = mod?.default || mod;
  return result;
}
async function renderFile(file) {
  const headers = {
    "content-type": mod_default.getType(file.name) || file.type,
    "content-length": file.size
  };
  return new Response(file.stream(), { headers });
}
/*! zip64. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
})()
//# sourceMappingURL=sw-container.min.js.map

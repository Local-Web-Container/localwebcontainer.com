(async () => {
var __create = Object.create;
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target2, all) => {
  for (var name in all)
    __defProp(target2, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/util.js
var errors, config;
var init_util = __esm({
  "node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/util.js"() {
    errors = {
      INVALID: ["seeking position failed.", "InvalidStateError"],
      GONE: ["A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"],
      MISMATCH: ["The path supplied exists, but was not an entry of requested type.", "TypeMismatchError"],
      MOD_ERR: ["The object can not be modified in this way.", "InvalidModificationError"],
      SYNTAX: (m) => [`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${m}`, "SyntaxError"],
      SECURITY: ["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.", "SecurityError"],
      DISALLOWED: ["The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError"]
    };
    config = {
      writable: globalThis.WritableStream
    };
  }
});

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/adapters/sandbox.js
var sandbox_exports = {};
__export(sandbox_exports, {
  FileHandle: () => FileHandle,
  FolderHandle: () => FolderHandle,
  default: () => sandbox_default
});
var DISALLOWED, Sink, FileHandle, FolderHandle, sandbox_default;
var init_sandbox = __esm({
  "node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/adapters/sandbox.js"() {
    init_util();
    ({ DISALLOWED } = errors);
    Sink = class {
      /**
       * @param {FileWriter} writer
       * @param {FileEntry} fileEntry
       */
      constructor(writer, fileEntry) {
        this.writer = writer;
        this.fileEntry = fileEntry;
      }
      /**
       * @param {BlobPart | Object} chunk
       */
      async write(chunk) {
        if (typeof chunk === "object") {
          if (chunk.type === "write") {
            if (Number.isInteger(chunk.position) && chunk.position >= 0) {
              this.writer.seek(chunk.position);
              if (this.writer.position !== chunk.position) {
                await new Promise((resolve, reject) => {
                  this.writer.onwriteend = resolve;
                  this.writer.onerror = reject;
                  this.writer.truncate(chunk.position);
                });
                this.writer.seek(chunk.position);
              }
            }
            if (!("data" in chunk)) {
              throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument", "SyntaxError");
            }
            chunk = chunk.data;
          } else if (chunk.type === "seek") {
            if (Number.isInteger(chunk.position) && chunk.position >= 0) {
              this.writer.seek(chunk.position);
              if (this.writer.position !== chunk.position) {
                throw new DOMException("seeking position failed", "InvalidStateError");
              }
              return;
            } else {
              throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument", "SyntaxError");
            }
          } else if (chunk.type === "truncate") {
            return new Promise((resolve) => {
              if (Number.isInteger(chunk.size) && chunk.size >= 0) {
                this.writer.onwriteend = (evt) => resolve();
                this.writer.truncate(chunk.size);
              } else {
                throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument", "SyntaxError");
              }
            });
          }
        }
        await new Promise((resolve, reject) => {
          this.writer.onwriteend = resolve;
          this.writer.onerror = reject;
          this.writer.write(new Blob([chunk]));
        });
      }
      close() {
        return new Promise(this.fileEntry.file.bind(this.fileEntry));
      }
    };
    FileHandle = class {
      /** @param {FileEntry} file */
      constructor(file, writable = true) {
        this.file = file;
        this.kind = "file";
        this.writable = writable;
        this.readable = true;
      }
      get name() {
        return this.file.name;
      }
      /**
       * @param {{ file: { toURL: () => string; }; }} other
       */
      isSameEntry(other) {
        return this.file.toURL() === other.file.toURL();
      }
      /** @return {Promise<File>} */
      getFile() {
        return new Promise(this.file.file.bind(this.file));
      }
      /** @return {Promise<Sink>} */
      createWritable(opts) {
        if (!this.writable) throw new DOMException(...DISALLOWED);
        return new Promise(
          (resolve, reject) => this.file.createWriter((fileWriter) => {
            if (opts.keepExistingData === false) {
              fileWriter.onwriteend = (evt) => resolve(new Sink(fileWriter, this.file));
              fileWriter.truncate(0);
            } else {
              resolve(new Sink(fileWriter, this.file));
            }
          }, reject)
        );
      }
    };
    FolderHandle = class _FolderHandle {
      /** @param {DirectoryEntry} dir */
      constructor(dir, writable = true) {
        this.dir = dir;
        this.writable = writable;
        this.readable = true;
        this.kind = "directory";
        this.name = dir.name;
      }
      /** @param {FolderHandle} other */
      isSameEntry(other) {
        return this.dir.fullPath === other.dir.fullPath;
      }
      /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */
      async *entries() {
        const reader = this.dir.createReader();
        const entries = await new Promise(reader.readEntries.bind(reader));
        for (const x of entries) {
          yield [x.name, x.isFile ? new FileHandle(x, this.writable) : new _FolderHandle(x, this.writable)];
        }
      }
      /**
       * @param {string} name
       * @param {{ create: boolean; }} opts
       * @returns {Promise<FolderHandle>}
       */
      getDirectoryHandle(name, opts) {
        return new Promise((resolve, reject) => {
          this.dir.getDirectory(name, opts, (dir) => {
            resolve(new _FolderHandle(dir));
          }, reject);
        });
      }
      /**
       * @param {string} name
       * @param {{ create: boolean; }} opts
       * @returns {Promise<FileHandle>}
       */
      getFileHandle(name, opts) {
        return new Promise(
          (resolve, reject) => this.dir.getFile(name, opts, (file) => resolve(new FileHandle(file)), reject)
        );
      }
      /**
       * @param {string} name
       * @param {{ recursive: boolean; }} opts
       */
      async removeEntry(name, opts) {
        const entry = await this.getDirectoryHandle(name, { create: false }).catch(
          (err) => err.name === "TypeMismatchError" ? this.getFileHandle(name, { create: false }) : err
        );
        if (entry instanceof Error) throw entry;
        return new Promise((resolve, reject) => {
          if (entry instanceof _FolderHandle) {
            opts.recursive ? entry.dir.removeRecursively(() => resolve(), reject) : entry.dir.remove(() => resolve(), reject);
          } else if (entry.file) {
            entry.file.remove(() => resolve(), reject);
          }
        });
      }
    };
    sandbox_default = (opts = {}) => new Promise(
      (resolve, reject) => window.webkitRequestFileSystem(
        opts._persistent,
        0,
        (e) => resolve(new FolderHandle(e.root)),
        reject
      )
    );
  }
});

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemHandle.js
var kAdapter, FileSystemHandle, FileSystemHandle_default;
var init_FileSystemHandle = __esm({
  "node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemHandle.js"() {
    kAdapter = Symbol("adapter");
    FileSystemHandle = class {
      /** @type {FileSystemHandle} */
      [kAdapter];
      /** @type {string} */
      name;
      /** @type {('file'|'directory')} */
      kind;
      /** @param {FileSystemHandle & {writable}} adapter */
      constructor(adapter) {
        this.kind = adapter.kind;
        this.name = adapter.name;
        this[kAdapter] = adapter;
      }
      /** @param {FileSystemHandlePermissionDescriptor} descriptor */
      async queryPermission(descriptor = {}) {
        const { mode = "read" } = descriptor;
        const handle = this[kAdapter];
        if (handle.queryPermission) {
          return handle.queryPermission({ mode });
        }
        if (mode === "read") {
          return "granted";
        } else if (mode === "readwrite") {
          return handle.writable ? "granted" : "denied";
        } else {
          throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
        }
      }
      async requestPermission({ mode = "read" } = {}) {
        const handle = this[kAdapter];
        if (handle.requestPermission) {
          return handle.requestPermission({ mode });
        }
        if (mode === "read") {
          return "granted";
        } else if (mode === "readwrite") {
          return handle.writable ? "granted" : "denied";
        } else {
          throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
        }
      }
      /**
       * Attempts to remove the entry represented by handle from the underlying file system.
       *
       * @param {object} options
       * @param {boolean} [options.recursive=false]
       */
      async remove(options = {}) {
        await this[kAdapter].remove(options);
      }
      /**
       * @param {FileSystemHandle} other
       */
      async isSameEntry(other) {
        if (this === other) return true;
        if (!other || typeof other !== "object" || this.kind !== other.kind || !other[kAdapter]) return false;
        return this[kAdapter].isSameEntry(other[kAdapter]);
      }
    };
    Object.defineProperty(FileSystemHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    if (globalThis.FileSystemHandle) {
      globalThis.FileSystemHandle.prototype.queryPermission ??= function(descriptor) {
        return "granted";
      };
    }
    FileSystemHandle_default = FileSystemHandle;
  }
});

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/config.js
var config2, config_default;
var init_config = __esm({
  "node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/config.js"() {
    config2 = {
      ReadableStream: globalThis.ReadableStream,
      WritableStream: globalThis.WritableStream,
      TransformStream: globalThis.TransformStream,
      DOMException: globalThis.DOMException,
      Blob: globalThis.Blob,
      File: globalThis.File
    };
    config_default = config2;
  }
});

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemWritableFileStream.js
var WritableStream, FileSystemWritableFileStream, FileSystemWritableFileStream_default;
var init_FileSystemWritableFileStream = __esm({
  "node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemWritableFileStream.js"() {
    init_config();
    ({ WritableStream } = config_default);
    FileSystemWritableFileStream = class _FileSystemWritableFileStream extends WritableStream {
      #writer;
      constructor(writer) {
        super(writer);
        this.#writer = writer;
        Object.setPrototypeOf(this, _FileSystemWritableFileStream.prototype);
        this._closed = false;
      }
      async close() {
        this._closed = true;
        const w = this.getWriter();
        const p3 = w.close();
        w.releaseLock();
        return p3;
      }
      /** @param {number} position */
      seek(position) {
        return this.write({ type: "seek", position });
      }
      /** @param {number} size */
      truncate(size) {
        return this.write({ type: "truncate", size });
      }
      // The write(data) method steps are:
      write(data) {
        if (this._closed) {
          return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));
        }
        const writer = this.getWriter();
        const result = writer.write(data);
        writer.releaseLock();
        return result;
      }
    };
    Object.defineProperty(FileSystemWritableFileStream.prototype, Symbol.toStringTag, {
      value: "FileSystemWritableFileStream",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemWritableFileStream.prototype, {
      close: { enumerable: true },
      seek: { enumerable: true },
      truncate: { enumerable: true },
      write: { enumerable: true }
    });
    if (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable && !globalThis.FileSystemWritableFileStream) {
      globalThis.FileSystemWritableFileStream = FileSystemWritableFileStream;
    }
    FileSystemWritableFileStream_default = FileSystemWritableFileStream;
  }
});

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemFileHandle.js
var FileSystemFileHandle_exports = {};
__export(FileSystemFileHandle_exports, {
  FileSystemFileHandle: () => FileSystemFileHandle,
  default: () => FileSystemFileHandle_default
});
var INVALID, SYNTAX, GONE, kAdapter2, FileSystemFileHandle, FileSystemFileHandle_default;
var init_FileSystemFileHandle = __esm({
  "node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemFileHandle.js"() {
    init_FileSystemHandle();
    init_FileSystemWritableFileStream();
    init_util();
    ({ INVALID, SYNTAX, GONE } = errors);
    kAdapter2 = Symbol("adapter");
    FileSystemFileHandle = class extends FileSystemHandle_default {
      /** @type {FileSystemFileHandle} */
      [kAdapter2];
      constructor(adapter) {
        super(adapter);
        this[kAdapter2] = adapter;
      }
      /**
       * @param  {Object} [options={}]
       * @param  {boolean} [options.keepExistingData]
       * @returns {Promise<FileSystemWritableFileStream>}
       */
      async createWritable(options = {}) {
        return new FileSystemWritableFileStream_default(
          await this[kAdapter2].createWritable(options)
        );
      }
      /**
       * @returns {Promise<File>}
       */
      async getFile() {
        return this[kAdapter2].getFile();
      }
    };
    Object.defineProperty(FileSystemFileHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemFileHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemFileHandle.prototype, {
      createWritable: { enumerable: true },
      getFile: { enumerable: true }
    });
    if (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable) {
      const wm = /* @__PURE__ */ new WeakMap();
      let workerUrl;
      const code = () => {
        let fileHandle, handle;
        onmessage = async (evt) => {
          const port = evt.ports[0];
          const cmd = evt.data;
          switch (cmd.type) {
            case "open":
              const file = cmd.name;
              let dir = await navigator.storage.getDirectory();
              for (const folder of cmd.path) {
                dir = await dir.getDirectoryHandle(folder);
              }
              fileHandle = await dir.getFileHandle(file);
              handle = await fileHandle.createSyncAccessHandle();
              break;
            case "write":
              handle.write(cmd.data, { at: cmd.position });
              handle.flush();
              break;
            case "truncate":
              handle.truncate(cmd.size);
              break;
            case "abort":
            case "close":
              handle.close();
              break;
          }
          port.postMessage(0);
        };
      };
      globalThis.FileSystemFileHandle.prototype.createWritable = async function(options) {
        if (!workerUrl) {
          const stringCode = `(${code.toString()})()`;
          const blob = new Blob([stringCode], {
            type: "text/javascript"
          });
          workerUrl = URL.createObjectURL(blob);
        }
        const worker = new Worker(workerUrl, { type: "module" });
        let position = 0;
        const textEncoder = new TextEncoder();
        let size = await this.getFile().then((file) => file.size);
        const send = (message) => new Promise((resolve, reject) => {
          const mc = new MessageChannel();
          mc.port1.onmessage = (evt) => {
            if (evt.data instanceof Error) reject(evt.data);
            else resolve(evt.data);
            mc.port1.close();
            mc.port2.close();
            mc.port1.onmessage = null;
          };
          worker.postMessage(message, [mc.port2]);
        });
        const root2 = await navigator.storage.getDirectory();
        const parent = await wm.get(this);
        const path = await root2.resolve(parent);
        if (path === null) throw new DOMException(...GONE);
        let controller;
        await send({ type: "open", path, name: this.name });
        if (options?.keepExistingData === false) {
          await send({ type: "truncate", size: 0 });
          size = 0;
        }
        const ws = new FileSystemWritableFileStream_default({
          start: (ctrl) => {
            controller = ctrl;
          },
          async write(chunk) {
            const isPlainObject2 = chunk?.constructor === Object;
            if (isPlainObject2) {
              chunk = { ...chunk };
            } else {
              chunk = { type: "write", data: chunk, position };
            }
            if (chunk.type === "write") {
              if (!("data" in chunk)) {
                await send({ type: "close" });
                throw new DOMException(...SYNTAX("write requires a data argument"));
              }
              chunk.position ??= position;
              if (typeof chunk.data === "string") {
                chunk.data = textEncoder.encode(chunk.data);
              } else if (chunk.data instanceof ArrayBuffer) {
                chunk.data = new Uint8Array(chunk.data);
              } else if (!(chunk.data instanceof Uint8Array) && ArrayBuffer.isView(chunk.data)) {
                chunk.data = new Uint8Array(chunk.data.buffer, chunk.data.byteOffset, chunk.data.byteLength);
              } else if (!(chunk.data instanceof Uint8Array)) {
                const ab = await new Response(chunk.data).arrayBuffer();
                chunk.data = new Uint8Array(ab);
              }
              if (Number.isInteger(chunk.position) && chunk.position >= 0) {
                position = chunk.position;
              }
              position += chunk.data.byteLength;
              size += chunk.data.byteLength;
            } else if (chunk.type === "seek") {
              if (Number.isInteger(chunk.position) && chunk.position >= 0) {
                if (size < chunk.position) {
                  throw new DOMException(...INVALID);
                }
                console.log("seeking", chunk);
                position = chunk.position;
                return;
              } else {
                await send({ type: "close" });
                throw new DOMException(...SYNTAX("seek requires a position argument"));
              }
            } else if (chunk.type === "truncate") {
              if (Number.isInteger(chunk.size) && chunk.size >= 0) {
                size = chunk.size;
                if (position > size) {
                  position = size;
                }
              } else {
                await send({ type: "close" });
                throw new DOMException(...SYNTAX("truncate requires a size argument"));
              }
            }
            await send(chunk);
          },
          async close() {
            await send({ type: "close" });
            worker.terminate();
          },
          async abort(reason) {
            await send({ type: "abort", reason });
            worker.terminate();
          }
        });
        return ws;
      };
      const orig = FileSystemDirectoryHandle.prototype.getFileHandle;
      FileSystemDirectoryHandle.prototype.getFileHandle = async function(...args) {
        const handle = await orig.call(this, ...args);
        wm.set(handle, this);
        return handle;
      };
    }
    FileSystemFileHandle_default = FileSystemFileHandle;
  }
});

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemDirectoryHandle.js
var FileSystemDirectoryHandle_exports = {};
__export(FileSystemDirectoryHandle_exports, {
  FileSystemDirectoryHandle: () => FileSystemDirectoryHandle2,
  default: () => FileSystemDirectoryHandle_default
});
var GONE2, MOD_ERR, kAdapter3, FileSystemDirectoryHandle2, FileSystemDirectoryHandle_default;
var init_FileSystemDirectoryHandle = __esm({
  "node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/FileSystemDirectoryHandle.js"() {
    init_FileSystemHandle();
    init_util();
    ({ GONE: GONE2, MOD_ERR } = errors);
    kAdapter3 = Symbol("adapter");
    FileSystemDirectoryHandle2 = class _FileSystemDirectoryHandle extends FileSystemHandle_default {
      /** @type {FileSystemDirectoryHandle} */
      [kAdapter3];
      constructor(adapter) {
        super(adapter);
        this[kAdapter3] = adapter;
      }
      /**
       * @param {string} name Name of the directory
       * @param {object} [options]
       * @param {boolean} [options.create] create the directory if don't exist
       * @returns {Promise<FileSystemDirectoryHandle>}
       */
      async getDirectoryHandle(name, options = {}) {
        if (name === "") {
          throw new TypeError(`Name can't be an empty string.`);
        }
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.create = !!options.create;
        const handle = await this[kAdapter3].getDirectoryHandle(name, options);
        return new _FileSystemDirectoryHandle(handle);
      }
      /** @returns {AsyncGenerator<[string, FileSystemHandle | FileSystemDirectoryHandle]>} */
      async *entries() {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        for await (const [_, entry] of this[kAdapter3].entries())
          yield [entry.name, entry.kind === "file" ? new FileSystemFileHandle2(entry) : new _FileSystemDirectoryHandle(entry)];
      }
      /** @deprecated use .entries() instead */
      async *getEntries() {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        console.warn("deprecated, use .entries() instead");
        for await (let entry of this[kAdapter3].entries())
          yield entry.kind === "file" ? new FileSystemFileHandle2(entry) : new _FileSystemDirectoryHandle(entry);
      }
      /**
       * @param {string} name Name of the file
       * @param {object} [options]
       * @param {boolean} [options.create] create the file if don't exist
       */
      async getFileHandle(name, options = {}) {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        if (name === "") throw new TypeError(`Name can't be an empty string.`);
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.create = !!options.create;
        const handle = await this[kAdapter3].getFileHandle(name, options);
        return new FileSystemFileHandle2(handle);
      }
      /**
       * @param {string} name
       * @param {object} [options]
       * @param {boolean} [options.recursive]
       */
      async removeEntry(name, options = {}) {
        if (name === "") {
          throw new TypeError(`Name can't be an empty string.`);
        }
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.recursive = !!options.recursive;
        return this[kAdapter3].removeEntry(name, options);
      }
      async resolve(possibleDescendant) {
        if (await possibleDescendant.isSameEntry(this)) {
          return [];
        }
        const openSet = [{ handle: this, path: [] }];
        while (openSet.length) {
          let { handle: current, path } = openSet.pop();
          for await (const entry of current.values()) {
            if (await entry.isSameEntry(possibleDescendant)) {
              return [...path, entry.name];
            }
            if (entry.kind === "directory") {
              openSet.push({ handle: entry, path: [...path, entry.name] });
            }
          }
        }
        return null;
      }
      async *keys() {
        for await (const [name] of this[kAdapter3].entries())
          yield name;
      }
      async *values() {
        for await (const [_, entry] of this)
          yield entry;
      }
      [Symbol.asyncIterator]() {
        return this.entries();
      }
    };
    Object.defineProperty(FileSystemDirectoryHandle2.prototype, Symbol.toStringTag, {
      value: "FileSystemDirectoryHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemDirectoryHandle2.prototype, {
      getDirectoryHandle: { enumerable: true },
      entries: { enumerable: true },
      getFileHandle: { enumerable: true },
      removeEntry: { enumerable: true }
    });
    if (globalThis.FileSystemDirectoryHandle) {
      const proto = globalThis.FileSystemDirectoryHandle.prototype;
      proto.resolve = async function resolve(possibleDescendant) {
        if (await possibleDescendant.isSameEntry(this)) {
          return [];
        }
        const openSet = [{ handle: this, path: [] }];
        while (openSet.length) {
          let { handle: current, path } = openSet.pop();
          for await (const entry of current.values()) {
            if (await entry.isSameEntry(possibleDescendant)) {
              return [...path, entry.name];
            }
            if (entry.kind === "directory") {
              openSet.push({ handle: entry, path: [...path, entry.name] });
            }
          }
        }
        return null;
      };
      async function ensureDoActuallyStillExist(handle) {
        const root2 = await navigator.storage.getDirectory();
        const path = await root2.resolve(handle);
        if (path === null) {
          throw new DOMException(...GONE2);
        }
      }
      const entries = proto.entries;
      proto.entries = async function* () {
        await ensureDoActuallyStillExist(this);
        yield* entries.call(this);
      };
      proto[Symbol.asyncIterator] = async function* () {
        yield* this.entries();
      };
      const removeEntry = proto.removeEntry;
      proto.removeEntry = async function(name, options = {}) {
        return removeEntry.call(this, name, options).catch(async (err) => {
          const unknown = err instanceof DOMException && err.name === "UnknownError";
          if (unknown && !options.recursive) {
            const empty = (await entries.call(this).next()).done;
            if (!empty) {
              throw new DOMException(...MOD_ERR);
            }
          }
          throw err;
        });
      };
    }
    FileSystemDirectoryHandle_default = FileSystemDirectoryHandle2;
  }
});

// node_modules/.deno/range-parser@1.2.1/node_modules/range-parser/index.js
var require_range_parser = __commonJS({
  "node_modules/.deno/range-parser@1.2.1/node_modules/range-parser/index.js"(exports, module) {
    "use strict";
    module.exports = rangeParser;
    function rangeParser(size, str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var index = str.indexOf("=");
      if (index === -1) {
        return -2;
      }
      var arr = str.slice(index + 1).split(",");
      var ranges = [];
      ranges.type = str.slice(0, index);
      for (var i = 0; i < arr.length; i++) {
        var range = arr[i].split("-");
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        } else if (isNaN(end)) {
          end = size - 1;
        }
        if (end > size - 1) {
          end = size - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
          continue;
        }
        ranges.push({
          start,
          end
        });
      }
      if (ranges.length < 1) {
        return -1;
      }
      return options && options.combine ? combineRanges(ranges) : ranges;
    }
    function combineRanges(ranges) {
      var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
      for (var j = 0, i = 1; i < ordered.length; i++) {
        var range = ordered[i];
        var current = ordered[j];
        if (range.start > current.end + 1) {
          ordered[++j] = range;
        } else if (range.end > current.end) {
          current.end = range.end;
          current.index = Math.min(current.index, range.index);
        }
      }
      ordered.length = j + 1;
      var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
      combined.type = ranges.type;
      return combined;
    }
    function mapWithIndex(range, index) {
      return {
        start: range.start,
        end: range.end,
        index
      };
    }
    function mapWithoutIndex(range) {
      return {
        start: range.start,
        end: range.end
      };
    }
    function sortByRangeIndex(a, b) {
      return a.index - b.index;
    }
    function sortByRangeStart(a, b) {
      return a.start - b.start;
    }
  }
});

// clientmyadmin/shared/kv.js
var p;
var query = (method, ...args) => (p ??= new Promise((rs) => {
  const open = indexedDB.open("clientmyadmin-kv");
  open.onupgradeneeded = () => open.result.createObjectStore("kv");
  open.onsuccess = () => {
    const db = open.result;
    query = (method2, ...args2) => {
      const q = db.transaction("kv", "readwrite").objectStore("kv")[method2](...args2);
      return new Promise((rs2, rj) => {
        q.onsuccess = () => rs2(q.result);
        q.onerror = () => rj(q.error);
      });
    };
    rs();
  };
})).then(() => query(method, ...args));
var kv_default = (...args) => query(...args);

// clientmyadmin/event-handler.js
var sw = (
  /** @type {ServiceWorkerGlobalScope & typeof globalThis} */
  globalThis
);
var EventTargetPolyfill = class {
  #listeners = {};
  #deferredEvents = [];
  #init;
  addEventListener(type, callback) {
    this.#listeners[type] ??= /* @__PURE__ */ new Set();
    const callbacks = this.#listeners[type];
    callbacks.add(callback);
    console.log(`Adding event listener for "${type}"`, this.#listeners);
  }
  removeEventListener(type, callback) {
    const callbacks = this.#listeners[type];
    if (!callbacks) return;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      delete this.#listeners[type];
    }
  }
  dispatchEvent(event) {
    const { type } = event;
    const callbacks = this.#listeners[type];
    if (callbacks?.size) {
      for (const callback of callbacks) {
        callback.call(this, event);
      }
    } else {
      const deferredEvents = this.#deferredEvents;
      if (deferredEvents) {
        console.log(`Event "${type}" is not yet registered, deferring...`, event);
        deferredEvents.push(event);
        event.waitUntil((async () => {
          this.#init ??= loadLocalServiceWorker();
          await this.#init;
          this.#deferredEvents = void 0;
          for (const evt of deferredEvents) {
            console.log(`Dispatching deferred event "${evt.type}"`, evt);
            const calls = this.#listeners[evt.type];
            console.log(`Found ${calls?.size || 0} listeners for "${evt.type}"`, calls);
            if (calls) {
              for (const callback of calls) {
                await callback.call(this, evt);
              }
            }
          }
        })());
      }
    }
    return true;
  }
};
var ET = new EventTargetPolyfill();
Object.keys(sw).forEach((eventName) => {
  if (!eventName.startsWith("on")) return;
  sw.addEventListener(eventName.slice(2), (evt) => {
    ET.dispatchEvent(evt);
  });
});
globalThis.addEventListener = ET.addEventListener.bind(ET);
globalThis.removeEventListener = ET.removeEventListener.bind(ET);
globalThis.dispatchEvent = ET.dispatchEvent.bind(ET);

// itty-router.js
function Router({ routes = [] } = {}) {
  return {
    __proto__: new Proxy({}, {
      get: (target2, prop, receiver) => (matcher, ...handlers) => {
        if (typeof matcher !== "function") {
          const pattern = typeof matcher === "object" || matcher?.startsWith("http") ? new URLPattern(matcher) : new URLPattern({ pathname: matcher });
          matcher = (o) => o.match = pattern.exec(o.url);
        }
        return routes.push([
          prop.toUpperCase(),
          matcher,
          handlers
        ]) && receiver;
      }
    }),
    routes,
    async handle(event, ctx = {}) {
      let response;
      ctx.url = new URL(event.request.url);
      ctx.event = event;
      ctx.request = event.request;
      ctx.match = void 0;
      ctx.response = {
        status: 200,
        headers: new Headers(),
        body: null
      };
      ctx.metadata = {};
      for (let [method, matcher, handlers] of routes) {
        const matchMethod = method === "ALL" || method === ctx.request.method;
        if (matchMethod && matcher(ctx)) {
          for (let handler of handlers) {
            if ((response = await handler(ctx)) !== void 0) return response;
          }
        }
      }
      return fetch(ctx.request);
    }
  };
}

// clientmyadmin/shared/fs.js
async function findHandle(root2, path) {
  if (path.length === 0) {
    return root2;
  }
  const name = (
    /** @type {string} */
    path.shift()
  );
  if (await root2.kind === "directory") {
    const handle = await root2.getDirectoryHandle(name).catch((err) => {
      if (err.name === "TypeMismatchError") {
        return root2.getFileHandle(name);
      } else {
        throw err;
      }
    });
    return findHandle(handle, path);
  }
  throw new Error(`'${root2.name}' is a file, not a directory, cannot search for '${root2.name}/${name}'`);
}
async function mkdirp(dirHandle, paths) {
  for (const path of paths) {
    dirHandle = await dirHandle.getDirectoryHandle(path, { create: true });
  }
  return dirHandle;
}
async function touch(dirHandle, paths) {
  const file = paths.pop();
  if (!file) throw new Error("touch: no file name provided");
  dirHandle = await mkdirp(dirHandle, paths);
  return dirHandle.getFileHandle(file, { create: true });
}
async function* walkHandleRecursive(source) {
  yield source;
  console.log(source.kind);
  if (source.kind === "directory") {
    for await (const [name, child] of await source.entries()) {
      yield* walkHandleRecursive(child);
    }
  }
}
async function emptyDir(source) {
  for await (const [name, handle] of await source.entries()) {
    await handle.remove({ recursive: true });
  }
  return source;
}
async function cp(source, dest, newName) {
  if (source.kind === "file") {
    const file = await source.getFile();
    const fileHandle = await dest.getFileHandle(newName, { create: true });
    const writer = await fileHandle.createWritable();
    await writer.write(file);
    await writer.close();
  } else {
    const dirHandle = await dest.getDirectoryHandle(newName, { create: true });
    for await (const [name, child] of source) {
      await cp(child, dirHandle, name);
    }
  }
}
var fs_default = {
  mkdirp,
  touch,
  cp,
  walkHandleRecursive,
  emptyDir,
  open(root2, path) {
    return findHandle(root2, path.split("/").filter(Boolean));
  }
};

// clientmyadmin/mime/standard.json
var standard_default = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };

// clientmyadmin/mime/mod.js
var Mime = class {
  #types = /* @__PURE__ */ Object.create(null);
  #extensions = /* @__PURE__ */ Object.create(null);
  constructor(...args) {
    for (let i = 0; i < args.length; i++) {
      this.define(args[i]);
    }
  }
  /**
   * Define mimetype -> extension mappings.  Each key is a mime-type that maps
   * to an array of extensions associated with the type.  The first extension is
   * used as the default extension for the type.
   *
   * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
   *
   * If a type declares an extension that has already been defined, an error will
   * be thrown.  To suppress this error and force the extension to be associated
   * with the new type, pass `force`=true.  Alternatively, you may prefix the
   * extension with "*" to map the type to extension, without mapping the
   * extension to the type.
   *
   * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
   *
   *
   * @param {Object} typeMap type definitions
   * @param {boolean} [force] if true, force overriding of existing definitions
   */
  define(typeMap, force) {
    for (let type in typeMap) {
      const extensions = typeMap[type].map((t2) => t2.toLowerCase());
      type = type.toLowerCase();
      for (let i = 0; i < extensions.length; i++) {
        const ext = extensions[i];
        if (ext[0] === "*") continue;
        if (!force && ext in this.#types) {
          throw new Error(
            'Attempt to change mapping for "' + ext + '" extension from "' + this.#types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
          );
        }
        this.#types[ext] = type;
      }
      if (force || !this.#extensions[type]) {
        const ext = extensions[0];
        this.#extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
      }
    }
  }
  /**
   * Lookup a mime type based on extension
   * @param {string} path
   */
  getType(path) {
    const last = path.replace(/^.*[/\\]/, "").toLowerCase();
    const ext = last.replace(/^.*\./, "").toLowerCase();
    const hasPath = last.length < path.length;
    const hasDot = ext.length < last.length - 1;
    return (hasDot || !hasPath) && this.#types[ext];
  }
  /**
   * Return file extension associated with a mime type
   * @param {string} type
   */
  getExtension(type) {
    type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
    return type && this.#extensions[type.toLowerCase()];
  }
};
var mod_default = new Mime(standard_default);

// clientmyadmin/shared/zip64/read.js
var ERR_BAD_FORMAT = "File format is not recognized.";
var ZIP_COMMENT_MAX = 65536;
var EOCDR_MIN = 22;
var EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;
var MAX_VALUE_32BITS = 4294967295;
var decoder = new TextDecoder();
var uint16e = (b, n) => b[n] | b[n + 1] << 8;
var GZIP_HEADER = Uint8Array.from([
  31,
  139,
  // gzip magic
  8,
  // deflate
  0,
  // no extra fields
  0,
  0,
  0,
  0,
  // mtime (n/a)
  0,
  0
  // extra flags, OS
]);
function getRawChunk(file, entry) {
  return file.slice(entry.offset + 26, entry.offset + 30).arrayBuffer().then((ab) => {
    const bytes = new Uint8Array(ab);
    const localFileOffset = uint16e(bytes, 0) + uint16e(bytes, 2) + 30;
    const start = entry.offset + localFileOffset;
    const end = start + entry.compressedSize;
    return file.slice(start, end);
  });
}
var Entry = class {
  #dataView;
  #fileLike;
  /** @type {Object<string, DataView>} */
  #extraFields = {};
  #name;
  type = "";
  /**
   * @param {DataView} dataView
   * @param {File} fileLike
   */
  constructor(dataView, fileLike) {
    if (dataView.getUint32(0) !== 1347092738) {
      throw new Error("ERR_BAD_FORMAT");
    }
    const dv = dataView;
    this.#dataView = dv;
    this.#fileLike = fileLike;
    for (let i = 46 + this.filenameLength; i < dv.byteLength; ) {
      const id = dv.getUint16(i, true);
      const len = dv.getUint16(i + 2, true);
      const start = dv.byteOffset + i + 4;
      this.#extraFields[id] = new DataView(dv.buffer.slice(start, start + len));
      i += len + 4;
    }
  }
  get versionMadeBy() {
    return this.#dataView.getUint16(4, true);
  }
  get versionNeeded() {
    return this.#dataView.getUint16(6, true);
  }
  get bitFlag() {
    return this.#dataView.getUint16(8, true);
  }
  get encrypted() {
    return (this.bitFlag & 1) === 1;
  }
  get compressionMethod() {
    return this.#dataView.getUint16(10, true);
  }
  get crc32() {
    return this.#dataView.getUint32(16, true);
  }
  get compressedSize() {
    return this.#dataView.getUint32(20, true);
  }
  get filenameLength() {
    return this.#dataView.getUint16(28, true);
  }
  get extraFieldLength() {
    return this.#dataView.getUint16(30, true);
  }
  get commentLength() {
    return this.#dataView.getUint16(32, true);
  }
  get diskNumberStart() {
    return this.#dataView.getUint16(34, true);
  }
  get internalFileAttributes() {
    return this.#dataView.getUint16(36, true);
  }
  get externalFileAttributes() {
    return this.#dataView.getUint32(38, true);
  }
  get directory() {
    return !!(this.#dataView.getUint8(38) & 16) || this.size === 0 && this.name.endsWith("/");
  }
  get offset() {
    return this.#dataView.getUint32(42, true);
  }
  get zip64() {
    return this.#dataView.getUint32(24, true) === MAX_VALUE_32BITS;
  }
  get comment() {
    const dv = this.#dataView;
    const uint8 = new Uint8Array(
      dv.buffer,
      dv.byteOffset + this.filenameLength + this.extraFieldLength + 46,
      this.commentLength
    );
    return decoder.decode(uint8);
  }
  get lastModified() {
    const t2 = this.#dataView.getUint32(12, true);
    return new Date(
      (t2 >> 25 & 127) + 1980,
      // year
      (t2 >> 21 & 15) - 1,
      // month
      t2 >> 16 & 31,
      // day
      t2 >> 11 & 31,
      // hour
      t2 >> 5 & 63,
      // minute
      (t2 & 31) << 1
      // second
    ).getTime();
  }
  /** @param {number} v timestamp in ms */
  set lastModified(v) {
    if (typeof v !== "number") throw new TypeError("lastModified must be a number");
    const date = new Date(v);
    const val = date.getFullYear() - 1980 << 25 | date.getMonth() + 1 << 21 | date.getDate() << 16 | date.getHours() << 11 | date.getMinutes() << 5 | date.getSeconds() >> 1;
    this.#dataView.setUint32(12, val, true);
  }
  get name() {
    if (this.#name !== void 0) return this.#name;
    if (!this.bitFlag && this.#extraFields[28789]) {
      return this.#name = decoder.decode(this.#extraFields[28789].buffer.slice(5));
    }
    const dv = this.#dataView;
    const uint8 = new Uint8Array(
      dv.buffer,
      dv.byteOffset + 46,
      this.filenameLength
    );
    return this.#name = decoder.decode(uint8);
  }
  /** @param {string} v */
  set name(v) {
    if (typeof v !== "string") throw new TypeError("name must be a string");
    this.#name = v;
  }
  get size() {
    const size = this.#dataView.getUint32(24, true);
    return size === MAX_VALUE_32BITS ? this.#extraFields[1].getUint8(0) : size;
  }
  set size(size) {
    if (size > MAX_VALUE_32BITS) {
      this.#extraFields[1] = new DataView(new ArrayBuffer(1));
      this.#extraFields[1].setUint8(0, size);
    } else {
    }
  }
  rawBytes() {
    return getRawChunk(this.#fileLike, this);
  }
  stream() {
    const ts = new TransformStream();
    const crc = this.crc32;
    const uncompressedSize = this.size;
    this.rawBytes().then((chunk) => {
      chunk.stream().pipeTo(ts.writable);
    });
    return this.compressionMethod ? ts.readable.pipeThrough(new TransformStream({
      start(controller) {
        controller.enqueue(GZIP_HEADER);
      },
      flush(controller) {
        const tmp = new DataView(new ArrayBuffer(8));
        tmp.setUint32(0, crc, true);
        tmp.setUint32(4, uncompressedSize, true);
        controller.enqueue(new Uint8Array(tmp.buffer));
      }
    })).pipeThrough(new DecompressionStream("gzip")) : ts.readable;
  }
  async arrayBuffer() {
    if (!this.compressionMethod) {
      return getRawChunk(this.#fileLike, this).then((c) => c.arrayBuffer());
    }
    return new Response(this.stream()).arrayBuffer().catch((e) => {
      throw new Error(`Failed to read Entry
${e}`);
    });
  }
  async text() {
    if (!this.compressionMethod) {
      return getRawChunk(this.#fileLike, this).then((c) => c.text());
    }
    return new Response(this.stream()).text().catch((e) => {
      throw new Error(`Failed to read Entry
${e}`);
    });
  }
  async file() {
    const reader = this.compressionMethod ? this.arrayBuffer() : getRawChunk(this.#fileLike, this);
    return reader.then((chunk) => new File([chunk], this.name, { lastModified: this.lastModified })).catch((err) => {
      throw new Error(`Failed to read Entry
${err}`);
    });
  }
};
async function* Reader(file) {
  if (file.size < EOCDR_MIN) throw new Error(ERR_BAD_FORMAT);
  async function doSeek(length) {
    const ab = await file.slice(file.size - length).arrayBuffer();
    const bytes2 = new Uint8Array(ab);
    for (let i = bytes2.length - EOCDR_MIN; i >= 0; i--) {
      if (bytes2[i] === 80 && bytes2[i + 1] === 75 && bytes2[i + 2] === 5 && bytes2[i + 3] === 6) {
        return new DataView(bytes2.buffer, i, EOCDR_MIN);
      }
    }
    return null;
  }
  let dv = await doSeek(EOCDR_MIN) || await doSeek(Math.min(EOCDR_MAX, file.size));
  if (!dv) throw new Error(ERR_BAD_FORMAT);
  let fileslength = dv.getUint16(8, true);
  let centralDirSize = dv.getUint32(12, true);
  let centralDirOffset = dv.getUint32(16, true);
  const isZip64 = centralDirOffset === MAX_VALUE_32BITS;
  if (isZip64) {
    const l = -dv.byteLength - 20;
    dv = new DataView(await file.slice(l, -dv.byteLength).arrayBuffer());
    const signature = dv.getUint32(0, true);
    const diskWithZip64CentralDirStart = dv.getUint32(4, true);
    const relativeOffsetEndOfZip64CentralDir = Number(
      dv.getBigInt64(8, true)
    );
    const numberOfDisks = dv.getUint32(16, true);
    const zip64centralBlob = file.slice(relativeOffsetEndOfZip64CentralDir, l);
    dv = new DataView(await zip64centralBlob.arrayBuffer());
    fileslength = Number(dv.getBigInt64(32, true));
    centralDirSize = Number(dv.getBigInt64(40, true));
    centralDirOffset = Number(dv.getBigInt64(48, true));
  }
  if (centralDirOffset < 0 || centralDirOffset >= file.size) {
    throw new Error(ERR_BAD_FORMAT);
  }
  const start = centralDirOffset;
  const end = centralDirOffset + centralDirSize;
  const blob = file.slice(start, end);
  const bytes = new Uint8Array(await blob.arrayBuffer());
  for (let i = 0, index = 0; i < fileslength; i++) {
    const size = uint16e(bytes, index + 28) + // filenameLength
    uint16e(bytes, index + 30) + // extraFieldLength
    uint16e(bytes, index + 32) + // commentLength
    46;
    if (index + size > bytes.length) {
      throw new Error("Invalid ZIP file.");
    }
    yield new Entry(new DataView(bytes.buffer, index, size), file);
    index += size;
  }
}
var read_default = Reader;

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/getOriginPrivateDirectory.js
if (globalThis.DataTransferItem && !DataTransferItem.prototype.getAsFileSystemHandle) {
  DataTransferItem.prototype.getAsFileSystemHandle = async function() {
    const entry = this.webkitGetAsEntry();
    const [
      { FileHandle: FileHandle3, FolderHandle: FolderHandle3 },
      { FileSystemDirectoryHandle: FileSystemDirectoryHandle3 },
      { FileSystemFileHandle: FileSystemFileHandle2 }
    ] = await Promise.all([
      Promise.resolve().then(() => (init_sandbox(), sandbox_exports)),
      Promise.resolve().then(() => (init_FileSystemDirectoryHandle(), FileSystemDirectoryHandle_exports)),
      Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports))
    ]);
    return entry.isFile ? new FileSystemFileHandle2(new FileHandle3(entry, false)) : new FileSystemDirectoryHandle3(new FolderHandle3(entry, false));
  };
}
async function getOriginPrivateDirectory(driver, options = {}) {
  if (!driver) {
    return globalThis.navigator?.storage?.getDirectory() || globalThis.getOriginPrivateDirectory();
  }
  const { FileSystemDirectoryHandle: FileSystemDirectoryHandle3 } = await Promise.resolve().then(() => (init_FileSystemDirectoryHandle(), FileSystemDirectoryHandle_exports));
  const module = await driver;
  const sandbox = await (module.default ? module.default(options) : module(options));
  return new FileSystemDirectoryHandle3(sandbox);
}
var getOriginPrivateDirectory_default = getOriginPrivateDirectory;

// node_modules/.deno/native-file-system-adapter@3.0.1/node_modules/native-file-system-adapter/src/adapters/jsdelivr.js
init_util();
var { GONE: GONE3, MISMATCH, SYNTAX: SYNTAX2, DISALLOWED: DISALLOWED2 } = errors;
var FileHandle2 = class {
  constructor(entry, root2) {
    this.name = entry.name;
    this.kind = "file";
    this._deleted = false;
    this._root = root2;
    this._entry = entry;
    this.writable = false;
    this.readable = true;
  }
  async getFile() {
    const res = await fetch(`https://cdn.jsdelivr.net/${this._root}/${this.name}`);
    const blob = await res.blob();
    return new File([blob], this.name, {
      type: blob.type,
      lastModified: this._entry.time
    });
  }
  async createWritable() {
    throw new DOMException(...DISALLOWED2);
  }
  async isSameEntry(other) {
    return this === other;
  }
};
function toDic(files, root2) {
  const dic = {};
  for (const x of files) {
    x.time = +new Date(x.time);
    if (x.type === "file") {
      dic[x.name] = new FileHandle2(x, root2);
    } else {
      dic[x.name] = new FolderHandle2(x.files, `${root2}/${x.name}`, x.name);
    }
  }
  return dic;
}
var FolderHandle2 = class {
  /** @param {string} name */
  constructor(files, root2, name = "") {
    this.name = name;
    this.kind = "directory";
    this._deleted = false;
    this._entries = toDic(files, root2);
    this.writable = false;
    this.readable = true;
  }
  /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */
  async *entries() {
    yield* Object.entries(this._entries);
  }
  async isSameEntry(other) {
    return this === other;
  }
  /**
   * @param {string} name
   * @param {{ create: boolean; }} opts
   */
  async getDirectoryHandle(name, opts) {
    if (this._deleted) throw new DOMException(...GONE3);
    const entry = this._entries[name];
    if (entry) {
      if (entry instanceof FileHandle2) {
        throw new DOMException(...MISMATCH);
      } else {
        return entry;
      }
    } else {
      if (opts.create) {
        throw new DOMException(...DISALLOWED2);
      } else {
        throw new DOMException(...GONE3);
      }
    }
  }
  /**
   * @param {string} name
   * @param {{ create: boolean; }} opts
   */
  async getFileHandle(name, opts) {
    const entry = this._entries[name];
    const isFile = entry instanceof FileHandle2;
    if (entry && isFile) return entry;
    if (entry && !isFile) throw new DOMException(...MISMATCH);
    if (!entry && !opts.create) throw new DOMException(...GONE3);
    if (!entry && opts.create) {
      throw new DOMException(...DISALLOWED2);
    }
  }
  async removeEntry(name, opts) {
    throw new DOMException(...DISALLOWED2);
  }
};
var jsdelivr_default = async (root2) => {
  const res = await fetch(`https://data.jsdelivr.com/v1/package/${root2}`);
  const { files } = await res.json();
  return new FolderHandle2(files, root2);
};

// clientmyadmin/cross-origion.js
init_util();
var { GONE: GONE4, MISMATCH: MISMATCH2, SYNTAX: SYNTAX3, DISALLOWED: DISALLOWED3 } = errors;

// shimport.js
function get_alias(specifiers, name) {
  let i = specifiers.length;
  while (i--) {
    if (specifiers[i].name === name) {
      return specifiers[i].as;
    }
  }
}
function importDecl(str, start, end, specifiers, source) {
  const name = get_alias(specifiers, "*") || get_alias(specifiers, "default");
  return {
    start,
    end,
    source,
    name,
    specifiers,
    toString() {
      return "/*" + str.slice(start, end) + "*/";
    }
  };
}
function exportDefaultDeclaration(str, start, end) {
  const match = /^\s*(?:(class)(\s+extends|\s*{)|(function)\s*\()/.exec(str.slice(end));
  if (match) {
    end += match[0].length;
    const name = "__default_export";
    return {
      start,
      end,
      name,
      as: "default",
      toString() {
        return match[1] ? "class " + name + match[2] : "function " + name + "(";
      }
    };
  }
  return {
    start,
    end,
    toString() {
      return "__exports.default =";
    }
  };
}
function exportSpecifiersDeclaration(str, start, specifiersStart, specifiersEnd, end, source) {
  const specifiers = processSpecifiers(str.slice(specifiersStart + 1, specifiersEnd - 1).trim());
  return {
    start,
    end,
    source,
    /** @param {Map<string, string>} nameBySource */
    toString(nameBySource) {
      const name = source && nameBySource.get(source);
      return specifiers.map(function(s) {
        return "__exports." + s.as + " = " + (name ? name + "." + s.name : s.name) + "; ";
      }).join("") + "/*" + str.slice(start, end) + "*/";
    }
  };
}
function exportDecl(str, start, c) {
  const end = c;
  while (str[c] && /\S/.test(str[c])) {
    c += 1;
  }
  while (str[c] && !/\S/.test(str[c])) {
    c += 1;
  }
  let nameStart = c;
  while (str[c] && !punctuatorChars.test(str[c]) && !isWhitespace(str[c])) {
    c += 1;
  }
  let nameEnd = c;
  let name = str.slice(nameStart, nameEnd);
  if (name === "function") {
    while (str[c] && /\S/.test(str[c])) {
      c += 1;
    }
    while (str[c] && !/\S/.test(str[c])) {
      c += 1;
    }
    nameStart = c;
    while (str[c] && !punctuatorChars.test(str[c]) && !isWhitespace(str[c])) {
      c += 1;
    }
    nameEnd = c;
    name = str.slice(nameStart, nameEnd);
  }
  return {
    start,
    end,
    name,
    toString() {
      return "";
    }
  };
}
function exportStarDeclaration(str, start, end, source) {
  return {
    start,
    end,
    source,
    /**
     * @param {Map<string, string>} nameBySource
     */
    toString(nameBySource) {
      return "Object.assign(__exports, " + nameBySource.get(source) + "); /*" + str.slice(start, end) + "*/";
    }
  };
}
var keywords = /\b(case|default|delete|do|else|in|instanceof|new|return|throw|typeof|void)\s*$/;
var punctuators = /(^|\{|\(|\[\.|;|,|<|>|<=|>=|==|!=|===|!==|\+|-|\*\%|<<|>>|>>>|&|\||\^|!|~|&&|\|\||\?|:|=|\+=|-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|\/=|\/)\s*$/;
var ambiguous = /(\}|\)|\+\+|--)\s*$/;
var punctuatorChars = /[{}()[.;,<>=+\-*%&|\^!~?:/]/;
var keywordChars = /[a-zA-Z_$0-9]/;
var whitespace_obj = { " ": 1, "	": 1, "\n": 1, "\r": 1, "\f": 1, "\v": 1, "\xA0": 1, "\u2028": 1, "\u2029": 1 };
function isWhitespace(char) {
  return char in whitespace_obj;
}
function isQuote(char) {
  return char === "'" || char === '"';
}
var namespaceImport = /^\*\s+as\s+(\w+)$/;
var defaultAndStarImport = /(\w+)\s*,\s*\*\s*as\s*(\w+)$/;
var defaultAndNamedImport = /(\w+)\s*,\s*{(.+)}$/;
function processImportSpecifiers(str) {
  let match = namespaceImport.exec(str);
  if (match) {
    return [{ name: "*", as: match[1] }];
  }
  match = defaultAndStarImport.exec(str);
  if (match) {
    return [{ name: "default", as: match[1] }, { name: "*", as: match[2] }];
  }
  match = defaultAndNamedImport.exec(str);
  if (match) {
    return [{ name: "default", as: match[1] }].concat(processSpecifiers(match[2].trim()));
  }
  if (str[0] === "{") {
    return processSpecifiers(str.slice(1, -1).trim());
  }
  if (str) {
    return [{ name: "default", as: str }];
  }
  return [];
}
function processSpecifiers(str) {
  return str ? str.split(",").map(function(part) {
    const ref = part.trim().split(/[^\S]+/);
    const name = ref[0];
    const as = ref[2];
    return { name, as: as || name };
  }) : [];
}
function getImportDeclaration(str, i) {
  const start = i;
  const specifierStart = i += 6;
  while (str[i] && isWhitespace(str[i])) {
    i += 1;
  }
  while (str[i] && !isQuote(str[i])) {
    i += 1;
  }
  const specifierEnd = i;
  const sourceStart = i += 1;
  while (str[i] && !isQuote(str[i])) {
    i += 1;
  }
  const sourceEnd = i++;
  return importDecl(
    str,
    start,
    i,
    processImportSpecifiers(str.slice(specifierStart, specifierEnd).replace(/from\s*$/, "").trim()),
    str.slice(sourceStart, sourceEnd)
  );
}
function getImportStatement(i) {
  return {
    start: i,
    end: i + 6,
    toString() {
      return "__import";
    }
  };
}
var importMetaUrlPattern = /^import\s*\.\s*meta\s*\.\s*url/;
function getImportMetaUrl(str, start, id) {
  const match = importMetaUrlPattern.exec(str.slice(start));
  if (match) {
    return {
      start,
      end: start + match[0].length,
      toString() {
        return JSON.stringify("" + id);
      }
    };
  }
}
function getExportDeclaration(str, i) {
  const start = i;
  i += 6;
  while (str[i] && isWhitespace(str[i])) {
    i += 1;
  }
  const declarationStart = i;
  if (str[i] === "{") {
    while (str[i] !== "}") {
      i += 1;
    }
    i += 1;
    const specifiersEnd = i;
    let source = null;
    while (isWhitespace(str[i])) {
      i += 1;
    }
    if (/^from[\s\n'"]/.test(str.slice(i, i + 5))) {
      i += 4;
      while (isWhitespace(str[i])) {
        i += 1;
      }
      while (str[i] && !isQuote(str[i])) {
        i += 1;
      }
      const sourceStart = i += 1;
      while (str[i] && !isQuote(str[i])) {
        i += 1;
      }
      source = str.slice(sourceStart, i);
      i += 1;
    }
    return exportSpecifiersDeclaration(
      str,
      start,
      declarationStart,
      specifiersEnd,
      i,
      source
    );
  }
  if (str[i] === "*") {
    i += 1;
    while (isWhitespace(str[i])) {
      i += 1;
    }
    i += 4;
    while (str[i] && !isQuote(str[i])) {
      i += 1;
    }
    const sourceStart$1 = i += 1;
    while (str[i] && !isQuote(str[i])) {
      i += 1;
    }
    const sourceEnd = i++;
    return exportStarDeclaration(
      str,
      start,
      i,
      str.slice(sourceStart$1, sourceEnd)
    );
  }
  if (/^default\b/.test(str.slice(i, i + 8))) {
    return exportDefaultDeclaration(
      str,
      start,
      declarationStart + 7
    );
  }
  return exportDecl(
    str,
    start,
    declarationStart
  );
}
function find(str, id) {
  let escapedFrom;
  let regexEnabled = true;
  let pfixOp = false;
  const stack = [];
  let lsci = -1;
  const lsc = function() {
    return str[lsci];
  };
  const parenMatches = {};
  const openingParenPositions = {};
  let parenDepth = 0;
  const importDeclarations = [];
  const importStatements = [];
  const importMetaUrls = [];
  const exportDeclarations = [];
  function tokenClosesExpression() {
    if (lsc() === ")") {
      let c = parenMatches[lsci];
      while (isWhitespace(str[c - 1])) {
        c -= 1;
      }
      return !/(if|while)$/.test(str.slice(c - 5, c));
    }
    return true;
  }
  var base2 = {
    pattern: /(?:(\()|(\))|({)|(})|(")|(')|(\/\/)|(\/\*)|(\/)|(`)|(import)|(export)|(\+\+|--))/g,
    handlers: [
      // (
      function(i) {
        lsci = i;
        openingParenPositions[parenDepth++] = i;
      },
      // )
      function(i) {
        lsci = i;
        parenMatches[i] = openingParenPositions[--parenDepth];
      },
      // {
      function(i) {
        lsci = i;
        stack.push(base2);
      },
      // }
      function(i) {
        lsci = i;
        return stack.pop();
      },
      // "
      function(i) {
        stack.push(base2);
        return double_quoted;
      },
      // '
      function(i) {
        stack.push(base2);
        return single_quoted;
      },
      // //
      function(i) {
        return line_comment;
      },
      // /*
      function(i) {
        return block_comment;
      },
      // /
      function(i) {
        let b = i;
        while (b > 0 && isWhitespace(str[b - 1])) {
          b -= 1;
        }
        if (b > 0) {
          let a = b;
          if (punctuatorChars.test(str[a - 1])) {
            while (a > 0 && punctuatorChars.test(str[a - 1])) {
              a -= 1;
            }
          } else {
            while (a > 0 && keywordChars.test(str[a - 1])) {
              a -= 1;
            }
          }
          const token = str.slice(a, b);
          regexEnabled = token ? keywords.test(token) || punctuators.test(token) || ambiguous.test(token) && !tokenClosesExpression() : false;
        } else {
          regexEnabled = true;
        }
        return slash;
      },
      // `
      function(i) {
        return template_string;
      },
      // import
      function(i) {
        if (i === 0 || isWhitespace(str[i - 1]) || punctuatorChars.test(str[i - 1])) {
          let j = i + 6;
          let char;
          do {
            char = str[j++];
          } while (isWhitespace(char));
          const hasWhitespace = j > i + 7;
          if (/^['"{*]$/.test(char) || hasWhitespace && /^[a-zA-Z_$]$/.test(char)) {
            const d = getImportDeclaration(str, i);
            importDeclarations.push(d);
            p3 = d.end;
          } else if (char === "(") {
            const s = getImportStatement(i);
            importStatements.push(s);
            p3 = s.end;
          } else if (char === ".") {
            const u = getImportMetaUrl(str, i, id);
            if (u) {
              importMetaUrls.push(u);
              p3 = u.end;
            }
          }
        }
      },
      // export
      function(i) {
        if (i === 0 || isWhitespace(str[i - 1]) || punctuatorChars.test(str[i - 1])) {
          if (/export[\s\n{]/.test(str.slice(i, i + 7))) {
            const d = getExportDeclaration(str, i);
            exportDeclarations.push(d);
            p3 = d.end;
          }
        }
      },
      // ++/--
      function(i) {
        pfixOp = !pfixOp && str[i - 1] === "+";
      }
    ]
  };
  var slash = {
    pattern: /(?:(\[)|(\\)|(.))/g,
    handlers: [
      // [
      (i) => regexEnabled ? regex_character : base2,
      // \\
      (i) => (escapedFrom = regex, escaped),
      // anything else
      (i) => regexEnabled && !pfixOp ? regex : base2
    ]
  };
  var regex = {
    pattern: /(?:(\[)|(\\)|(\/))/g,
    handlers: [
      // [
      () => regex_character,
      // \\
      () => (escapedFrom = regex, escaped),
      // /
      () => base2
    ]
  };
  var regex_character = {
    pattern: /(?:(\])|(\\))/g,
    handlers: [
      // ]
      (_) => regex,
      // \\
      (_) => (escapedFrom = regex_character, escaped)
    ]
  };
  var double_quoted = {
    pattern: /(?:(\\)|("))/g,
    handlers: [
      // \\
      function() {
        return escapedFrom = double_quoted, escaped;
      },
      // "
      function() {
        return stack.pop();
      }
    ]
  };
  var single_quoted = {
    pattern: /(?:(\\)|('))/g,
    handlers: [
      // \\
      function() {
        return escapedFrom = single_quoted, escaped;
      },
      // '
      function() {
        return stack.pop();
      }
    ]
  };
  var escaped = {
    pattern: /(.)/g,
    handlers: [
      function() {
        return escapedFrom;
      }
    ]
  };
  var template_string = {
    pattern: /(?:(\${)|(\\)|(`))/g,
    handlers: [
      // ${
      function() {
        stack.push(template_string);
        return base2;
      },
      // \\
      function() {
        return escapedFrom = template_string, escaped;
      },
      // `
      function() {
        return base2;
      }
    ]
  };
  var line_comment = {
    pattern: /((?:\n|$))/g,
    handlers: [
      // \n
      function() {
        return base2;
      }
    ]
  };
  var block_comment = {
    pattern: /(\*\/)/g,
    handlers: [
      // \n
      function() {
        return base2;
      }
    ]
  };
  let state = base2;
  var p3 = 0;
  while (p3 < str.length) {
    state.pattern.lastIndex = p3;
    const match = state.pattern.exec(str);
    if (!match) {
      if (stack.length > 0 || state !== base2) {
        throw new Error("Unexpected end of file");
      }
      break;
    }
    p3 = match.index + match[0].length;
    for (let j = 1; j < match.length; j += 1) {
      if (match[j]) {
        state = state.handlers[j - 1](match.index) || state;
        break;
      }
    }
  }
  return [
    importDeclarations,
    importStatements,
    importMetaUrls,
    exportDeclarations
  ];
}
function transform(source, id) {
  const ref = find(source, id);
  const importDeclarations = ref[0];
  const importStatements = ref[1];
  const importMetaUrls = ref[2];
  const exportDeclarations = ref[3];
  const nameBySource = /* @__PURE__ */ new Map();
  importDeclarations.forEach(function(d) {
    if (nameBySource.has(d.source)) {
      return;
    }
    nameBySource.set(d.source, d.name || "__dep_" + nameBySource.size);
  });
  exportDeclarations.forEach(function(d) {
    if (!d.source || nameBySource.has(d.source)) return;
    nameBySource.set(d.source, d.name || "__dep_" + nameBySource.size);
  });
  const deps = Array.from(nameBySource.keys()).map(function(s) {
    return "'" + s + "'";
  }).join(", ");
  const names = ["__import", "__exports"].concat(Array.from(nameBySource.values())).join(", ");
  const hoisted = [];
  importDeclarations.forEach(function(decl) {
    const name = nameBySource.get(decl.source);
    decl.specifiers.sort(function(a, b) {
      if (a.name === "default") {
        return 1;
      }
      if (b.name === "default") {
        return -1;
      }
    }).forEach(function(s) {
      if (s.name !== "*") {
        const assignment = s.name === "default" && s.as === name ? s.as + " = " + name + ".default; " : "var " + s.as + " = " + name + "." + s.name + "; ";
        hoisted.push(assignment);
      }
    });
  });
  let transformed = "__shimport__.define('" + id + "', [" + deps + "], function(" + names + "){ " + hoisted.join("");
  const ranges = importDeclarations.concat(
    importStatements,
    importMetaUrls,
    exportDeclarations
  ).sort(function(a, b) {
    return a.start - b.start;
  });
  let c = 0;
  for (let i = 0; i < ranges.length; i += 1) {
    const range = ranges[i];
    transformed += source.slice(c, range.start) + range.toString(nameBySource);
    c = range.end;
  }
  transformed += source.slice(c);
  exportDeclarations.forEach(function(d) {
    if (d.name) {
      transformed += "\n__exports." + (d.as || d.name) + " = " + d.name + ";";
    }
  });
  transformed += "\n});\n//# sourceURL=" + id;
  return transformed;
}
var promises = {};
function define(id, deps, factory) {
  const __import = function(dep) {
    return load(new URL(dep, id).toString());
  };
  return Promise.all(deps.map(__import)).then((__deps) => {
    const __exports = {};
    factory(__import, __exports, ...__deps);
    return __exports;
  });
}
async function load(url) {
  return promises[url] ??= fetch(url).then((r) => {
    if (!r.ok) throw new Error(url + " returned non ok response");
    return r.text();
  }).then((text) => evaluate(transform(text, url)));
}
function evaluate(code) {
  try {
    return (0, eval)(code);
  } catch (e) {
    throw new Error("Error evaluating " + code + "\n" + e.stack);
  }
}
globalThis.__shimport__ = {
  define,
  load,
  transform
};

// util.js
var html = (str, ...val) => str.reduce((acc, str2, i) => acc + str2 + (val[i] ?? ""), "");
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false) return false;
  ctor = o.constructor;
  if (ctor === void 0) return true;
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  return Object.hasOwn(prot, "isPrototypeOf");
}

// sw-container.js
var import_range_parser = __toESM(require_range_parser(), 1);
globalThis.parseRange = import_range_parser.default;
var sw2 = (
  /** @type {ServiceWorkerGlobalScope & typeof globalThis} */
  globalThis
);
var target = `es${(/* @__PURE__ */ new Date()).getFullYear() - 2}`;
var chromeVersion = navigator.userAgentData?.brands.find((e) => e.brand === "Chromium")?.version;
var firefoxVersion = navigator.userAgent.match(/Firefox\/([0-9]+)\./)?.[1];
var safariVersion = navigator.userAgent.match(/Version\/(\d+)\.\d+ Safari/)?.[1];
if (chromeVersion) {
  target = "chrome" + chromeVersion;
} else if (firefoxVersion) {
  target = "firefox" + firefoxVersion;
} else if (safariVersion) {
  target = "safari" + safariVersion;
}
var base = new URL("/", import.meta.url).origin;
globalThis.loadLocalServiceWorker = async () => {
  root ??= await kv_default("get", "root").then(
    (dir) => dir?.type === "jsdelivr" ? getOriginPrivateDirectory_default(jsdelivr_default, dir.root) : dir
  );
  console.log("loading local service worker from", root);
  try {
    await load("/sw.js");
  } catch (e) {
    console.info("Failed to load local sw.js", e);
  }
};
async function cacheFirst(req) {
  const cache = await caches.open("v1");
  const cached = await cache.match(req);
  if (cached) return cached;
  const res = await fetch(req);
  await cache.put(req, res.clone());
  return res;
}
var origFetch = globalThis.fetch;
globalThis.fetch = async function fetch2(...args) {
  if (!(args[0] instanceof Request)) return fetch2(new Request(...args));
  if (args[0].url.startsWith(origin)) {
    const pathname = new URL(args[0].url).pathname.replace(/^\/+/, "");
    const entries = /* @__PURE__ */ new Map();
    root ??= await kv_default("get", "root");
    if (root?.type === "jsdelivr") {
      root = await getOriginPrivateDirectory_default(jsdelivr_default, root.root);
    }
    if (root) {
      const permission = await root.queryPermission?.({ mode: "read" });
      if (permission === "prompt") return fetch2(`${base}/clientmyadmin/allowread.html`);
      let p3 = "";
      try {
        p3 = decodeURIComponent(pathname);
      } catch (e) {
        return new Response("Not Found.", {
          status: 404,
          statusText: "Not found"
        });
      }
      if (root.type === "client") {
        const client = await sw2.clients.get(root.root);
        if (!client) {
          await kv_default("delete", "root");
          return Response.redirect(`/clientmyadmin/?client-not-found`);
        }
        const mc = new MessageChannel();
        client.postMessage({
          cmd: "open",
          path: p3,
          port: mc.port1
        }, [mc.port1]);
        const evt = await new Promise((rs) => mc.port2.onmessage = rs);
        const data = evt.data;
        if (data instanceof File) {
          return renderFile(data);
        } else if (data instanceof Error) {
          return new Response(data.message, {
            status: 500,
            statusText: "Internal Server Error"
          });
        } else {
          return renderTreeList(new Map(data));
        }
      }
      try {
        const handle = await fs_default.open(root, p3);
        if (handle.kind === "file") {
          const file = await handle.getFile();
          return renderFile(file, args[0]);
        } else {
          for await (const [name, entry2] of handle) {
            entries.set(`${pathname}/${name}`.replace(/^\//, ""), entry2);
          }
          return renderTreeList(entries);
        }
      } catch (e) {
        console.log(e);
        return new Response("Not Found.", {
          status: 404,
          statusText: "Not found"
        });
      }
    }
    const zipBlob = await kv_default("get", "zip-file");
    if (!zipBlob) {
      return Response.redirect("/clientmyadmin");
    }
    for await (const entry2 of read_default(zipBlob)) {
      if (!entry2.directory) entries.set(entry2.name, entry2);
    }
    const entry = entries.get(pathname);
    return entry ? renderFile(entry) : renderTreeList(entries);
  }
  return caches.match(args[0]).then((res) => {
    return res || origFetch(args[0]);
  });
};
var p2;
async function init() {
  const { initialize } = await load(base + "/esbuild.min.js");
  const res = await cacheFirst(base + "/esbuild.wasm");
  await initialize({
    worker: false,
    wasmModule: await WebAssembly.compileStreaming(res)
  });
}
async function _import(url, opts) {
  await (p2 ??= init());
  const { build, httpPlugin, sveltePlugin } = await load(base + "/esbuild.min.js");
  console.log([httpPlugin, sveltePlugin]);
  const options = {
    entryPoints: [url],
    format: "esm",
    minify: true,
    // format: 'iife',
    globalName: "xyz",
    sourcemap: true,
    // bundle: true,
    target,
    plugins: [
      sveltePlugin,
      httpPlugin
    ],
    ...opts
  };
  console.groupCollapsed("esbuild building " + url);
  console.info("options", options);
  console.groupEnd();
  const result = await build(options);
  return result.outputFiles[0].contents;
}
var router = Router();
var root;
router.get(
  (o) => (ctx) => ["script", "worker"].includes(ctx.request.destination),
  async (ctx) => {
    const ext = ctx.request.url.split(".").pop();
    if (ext === "html" && ctx.request.destination === "script") {
      const html2 = await fetch(ctx.request.url).then((res) => res.text());
      return new Response(`
        const t = document.createElement('template')
        t.innerHTML = ${JSON.stringify(html2)}
        export default t.content
      `, {
        headers: { "content-type": "text/javascript" }
      });
    }
    if (ext === "css" && ctx.request.destination === "script") {
      await (p2 ??= init());
      const { build, httpPlugin } = await load(base + "/esbuild.min.js");
      const options = {
        entryPoints: [ctx.request.url],
        minify: true,
        sourcemap: false,
        target,
        plugins: [httpPlugin],
        // @import should not be allowed in CSS modules?
        // https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418
        bundle: false
      };
      const result = await build(options);
      const esbuildCSS = new TextDecoder().decode(result.outputFiles[0].contents);
      return new Response(`
        const sheet = new CSSStyleSheet()
        await sheet.replace(${JSON.stringify(esbuildCSS)}, {
          baseURL: ${JSON.stringify(ctx.request.url)}
        })
        export default sheet
      `, {
        headers: { "content-type": "text/javascript" }
      });
    }
    if (["jsx", "ts", "tsx", "svelte"].includes(ext)) {
      const { rewriteImports } = await load(base + "/esbuild.min.js");
      const uint8 = await _import(ctx.request.url);
      let str = new TextDecoder().decode(uint8);
      str = await rewriteImports(str);
      const res = new Response(str, {
        headers: { "content-type": "text/javascript" }
      });
      return res;
    }
  }
);
router.get((o) => o.url.searchParams.get("installFrom"), async (ctx) => {
  root = void 0;
  return fetch(`${base}/clientmyadmin/installfrom.html`);
});
router.get("/clientmyadmin", (ctx) => {
  return Response.redirect("/clientmyadmin/", 302);
});
router.get("/clientmyadmin/clients", async (o) => {
  const clients = await sw2.clients.matchAll();
  const m = clients.map((client) => {
    const res = {};
    for (const key in client) {
      if (typeof client[key] !== "function") {
        res[key] = client[key];
      }
    }
    return res;
  });
  return Response.json({
    self: o.event.clientId,
    clients: m
  });
});
router.get(
  (evt) => evt.request.destination === "document" && evt.request.url.includes("/clientmyadmin/inspector"),
  (ctx) => fetch(`${base}/clientmyadmin/inspector.html`)
);
router.get(location.origin + "/clientmyadmin/*", (ctx) => {
  ctx.request = new Request(ctx.request.url.replace(location.origin, base));
  ctx.url = new URL(ctx.request.url);
});
var singleton = {};
router.all("/functions/*", async (evt) => {
  const url = new URL(evt.url.pathname, location.origin);
  const path = url.toString();
  let module;
  if (url.pathname.endsWith(".ts")) {
    singleton[path] ??= _import(path, { format: "iife" }).then(load2);
    module = await singleton[path];
  } else {
    module = await load(path);
  }
  let method = evt.request.method;
  method = method[0].toUpperCase() + method.slice(1).toLowerCase();
  const fn = module[`onRequest${method}`];
  return fn?.(evt);
});
router.all(
  (evt) => evt.request.destination === "document" && evt.url.pathname.toLowerCase().endsWith(".md"),
  (_) => fetch(`${base}/clientmyadmin/markdown.html`)
);
router.all(
  (evt) => evt.request.destination === "document" && evt.url.pathname.toLowerCase().endsWith(".json"),
  (_) => fetch(`${base}/clientmyadmin/json.html`)
);
router.all(
  (evt) => evt.request.destination === "script" && evt.url.pathname.toLowerCase().endsWith(".ce.vue"),
  async (ctx) => {
    const { compile } = await load(`${base}/clientmyadmin/vue-resolver.js`);
    return compile(ctx.request);
  }
);
router.all(
  (evt) => evt.request.destination === "document" && evt.url.pathname.toLowerCase().endsWith(".svelte"),
  async (ctx) => {
    const { compile } = await load("https://cdn.jsdelivr.net/npm/svelte@4.0.0/compiler.cjs/+esm");
    const { create_ssr_component } = await load("https://esm.sh/stable/svelte@4.0.0/es2022/src/runtime/internal/ssr.js");
    const options = { generate: "ssr" };
    const source = await fetch(ctx.request.url).then((res) => res.text());
    let code = compile(source, options).js.code;
    code = code.slice(code.indexOf(";")).replace("export default", "return");
    const result = new Function("create_ssr_component", code)(create_ssr_component).render();
    const str = html`<!DOCTYPE html>
    <html>
      <head>
        <style>${result.css.code}</style>
      </head>
      <body>${result.html}</body>
    </html>`;
    return new Response(str, {
      headers: { "content-type": "text/html" },
      status: 200,
      statusText: "OK"
    });
  }
);
globalThis.router = router;
router.get(
  (o) => o.request.destination === "style",
  async (ctx) => {
    await (p2 ??= init());
    const { build, httpPlugin, sveltePlugin } = await load(base + "/esbuild.min.js");
    const options = {
      entryPoints: [ctx.request.url],
      minify: true,
      sourcemap: true,
      target,
      // bundle: true,
      plugins: [httpPlugin, sveltePlugin]
    };
    const result2 = await build(options);
    const esbuildCSS = result2.outputFiles[0].text;
    return new Response(esbuildCSS, {
      headers: { "content-type": "text/css; charset=utf-8" }
    });
  }
);
function errorHandler(error, evt) {
  console.groupCollapsed("\u26A0\uFE0F Failed to handle request: " + evt.request.url);
  console.error(error);
  console.log(evt.request);
  console.groupEnd();
  return new Response(error.stack || "Server Error", {
    status: error.status || 200
  });
}
function convertToResponse(thing) {
  if (thing instanceof Response) return thing;
  if (typeof thing === void 0) {
    return new Response("Not Found.", { status: 404 });
  }
  if (Array.isArray(thing) || isPlainObject(thing)) {
    return Response.json(thing);
  }
  return new Response(thing);
}
sw2.addEventListener("fetch", (evt) => {
  evt.respondWith(
    router.handle(evt).then(convertToResponse).catch((err) => errorHandler(err, evt))
  );
});
var t = (evt, fn) => evt.waitUntil(fn().catch(console.error));
sw2.onactivate = (evt) => t(evt, () => sw2.clients.claim());
sw2.onmessage = async (evt) => {
  const { data, ports } = evt;
  if (data === "unload") {
    kv_default("delete", "root");
    root = null;
  }
  if (data?.type === "TRANSFER_CHANNEL" && data.targetClientId) {
    t(evt, async () => {
      const targetClient = await sw2.clients.get(data.targetClientId);
      targetClient.postMessage({ type: "CHANNEL_TRANSFER" }, ports);
    });
  }
  if (data === "claimMe") {
    t(evt, async () => {
      await sw2.clients.claim();
      ports[0].postMessage("claimed");
    });
  }
};
var _a;
function renderTreeList(entries) {
  const files = Array.from(entries.keys()).sort();
  const str = html(_a || (_a = __template([`<!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <meta name='viewport' content='width=device-width, initial-scale=1'>
        <link rel="stylesheet" href="/clientmyadmin/style.css">
        <script type="module" src="/clientmyadmin/prompt.js"><\/script>
        <style>body { margin: 20px; max-width: initial; }</style>
      </head>
      <body>
        <h1>Files</h1>
        <ul>
          `, "\n        </ul>\n      </body>\n    </html>"])), files.map((file) => {
    return entries.get(file).crc32 ? `<li><a href="/${file}">${file}</a> ${entries.get(file).size.toString().padStart(6, " ")}b </li>` : `<li><a href="/${file}">${file}</a></li>`;
  }).join(""));
  return new Response(str, {
    headers: { "content-type": "text/html" },
    status: 404,
    statusText: "Not found"
  });
}
function load2(uint8) {
  const str = new TextDecoder().decode(uint8);
  const body = `${str}; 
 return xyz`;
  const mod = new Function(body)();
  const result = mod?.default || mod;
  return result;
}
async function renderFile(file, request) {
  const rangeHeader = request?.headers.get("range");
  if (rangeHeader) {
    const [range] = (0, import_range_parser.default)(file.size, rangeHeader, { combine: true });
    const sliced = file.slice(range.start, range.end + 1);
    const headers2 = {
      "content-type": mod_default.getType(file.name) || file.type,
      "content-length": sliced.size,
      "accept-ranges": "bytes",
      "content-range": `bytes ${range.start}-${range.end}/${file.size}`
    };
    return new Response(sliced.stream(), {
      headers: headers2,
      status: 206
    });
  }
  const headers = {
    "content-type": mod_default.getType(file.name) || file.type,
    "content-length": file.size
  };
  return new Response(file.stream(), { headers });
}
/*! zip64. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! Bundled license information:

range-parser/index.js:
  (*!
   * range-parser
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
})()
//# sourceMappingURL=sw-container.min.js.map

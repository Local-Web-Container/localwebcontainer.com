(async () => {
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/native-file-system-adapter/src/util.js
var errors, config;
var init_util = __esm({
  "node_modules/native-file-system-adapter/src/util.js"() {
    errors = {
      INVALID: ["seeking position failed.", "InvalidStateError"],
      GONE: ["A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"],
      MISMATCH: ["The path supplied exists, but was not an entry of requested type.", "TypeMismatchError"],
      MOD_ERR: ["The object can not be modified in this way.", "InvalidModificationError"],
      SYNTAX: (m) => [`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${m}`, "SyntaxError"],
      SECURITY: ["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.", "SecurityError"],
      DISALLOWED: ["The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError"]
    };
    config = {
      writable: globalThis.WritableStream
    };
  }
});

// node_modules/native-file-system-adapter/src/adapters/sandbox.js
var sandbox_exports = {};
__export(sandbox_exports, {
  FileHandle: () => FileHandle,
  FolderHandle: () => FolderHandle,
  default: () => sandbox_default
});
var DISALLOWED, Sink, FileHandle, FolderHandle, sandbox_default;
var init_sandbox = __esm({
  "node_modules/native-file-system-adapter/src/adapters/sandbox.js"() {
    init_util();
    ({ DISALLOWED } = errors);
    Sink = class {
      constructor(writer, fileEntry) {
        this.writer = writer;
        this.fileEntry = fileEntry;
      }
      async write(chunk) {
        if (typeof chunk === "object") {
          if (chunk.type === "write") {
            if (Number.isInteger(chunk.position) && chunk.position >= 0) {
              this.writer.seek(chunk.position);
              if (this.writer.position !== chunk.position) {
                await new Promise((resolve, reject) => {
                  this.writer.onwriteend = resolve;
                  this.writer.onerror = reject;
                  this.writer.truncate(chunk.position);
                });
                this.writer.seek(chunk.position);
              }
            }
            if (!("data" in chunk)) {
              throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument", "SyntaxError");
            }
            chunk = chunk.data;
          } else if (chunk.type === "seek") {
            if (Number.isInteger(chunk.position) && chunk.position >= 0) {
              this.writer.seek(chunk.position);
              if (this.writer.position !== chunk.position) {
                throw new DOMException("seeking position failed", "InvalidStateError");
              }
              return;
            } else {
              throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument", "SyntaxError");
            }
          } else if (chunk.type === "truncate") {
            return new Promise((resolve) => {
              if (Number.isInteger(chunk.size) && chunk.size >= 0) {
                this.writer.onwriteend = (evt) => resolve();
                this.writer.truncate(chunk.size);
              } else {
                throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument", "SyntaxError");
              }
            });
          }
        }
        await new Promise((resolve, reject) => {
          this.writer.onwriteend = resolve;
          this.writer.onerror = reject;
          this.writer.write(new Blob([chunk]));
        });
      }
      close() {
        return new Promise(this.fileEntry.file.bind(this.fileEntry));
      }
    };
    FileHandle = class {
      constructor(file, writable = true) {
        this.file = file;
        this.kind = "file";
        this.writable = writable;
        this.readable = true;
      }
      get name() {
        return this.file.name;
      }
      isSameEntry(other) {
        return this.file.toURL() === other.file.toURL();
      }
      getFile() {
        return new Promise(this.file.file.bind(this.file));
      }
      createWritable(opts) {
        if (!this.writable)
          throw new DOMException(...DISALLOWED);
        return new Promise(
          (resolve, reject) => this.file.createWriter((fileWriter) => {
            if (opts.keepExistingData === false) {
              fileWriter.onwriteend = (evt) => resolve(new Sink(fileWriter, this.file));
              fileWriter.truncate(0);
            } else {
              resolve(new Sink(fileWriter, this.file));
            }
          }, reject)
        );
      }
    };
    FolderHandle = class {
      constructor(dir, writable = true) {
        this.dir = dir;
        this.writable = writable;
        this.readable = true;
        this.kind = "directory";
        this.name = dir.name;
      }
      isSameEntry(other) {
        return this.dir.fullPath === other.dir.fullPath;
      }
      async *entries() {
        const reader = this.dir.createReader();
        const entries = await new Promise(reader.readEntries.bind(reader));
        for (const x of entries) {
          yield [x.name, x.isFile ? new FileHandle(x, this.writable) : new FolderHandle(x, this.writable)];
        }
      }
      getDirectoryHandle(name, opts) {
        return new Promise((resolve, reject) => {
          this.dir.getDirectory(name, opts, (dir) => {
            resolve(new FolderHandle(dir));
          }, reject);
        });
      }
      getFileHandle(name, opts) {
        return new Promise(
          (resolve, reject) => this.dir.getFile(name, opts, (file) => resolve(new FileHandle(file)), reject)
        );
      }
      async removeEntry(name, opts) {
        const entry = await this.getDirectoryHandle(name, { create: false }).catch(
          (err) => err.name === "TypeMismatchError" ? this.getFileHandle(name, { create: false }) : err
        );
        if (entry instanceof Error)
          throw entry;
        return new Promise((resolve, reject) => {
          if (entry instanceof FolderHandle) {
            opts.recursive ? entry.dir.removeRecursively(() => resolve(), reject) : entry.dir.remove(() => resolve(), reject);
          } else if (entry.file) {
            entry.file.remove(() => resolve(), reject);
          }
        });
      }
    };
    sandbox_default = (opts = {}) => new Promise(
      (resolve, reject) => window.webkitRequestFileSystem(
        opts._persistent,
        0,
        (e) => resolve(new FolderHandle(e.root)),
        reject
      )
    );
  }
});

// node_modules/native-file-system-adapter/src/FileSystemHandle.js
var kAdapter, FileSystemHandle, FileSystemHandle_default;
var init_FileSystemHandle = __esm({
  "node_modules/native-file-system-adapter/src/FileSystemHandle.js"() {
    kAdapter = Symbol("adapter");
    FileSystemHandle = class {
      [kAdapter];
      name;
      kind;
      constructor(adapter) {
        this.kind = adapter.kind;
        this.name = adapter.name;
        this[kAdapter] = adapter;
      }
      async queryPermission({ mode = "read" } = {}) {
        const handle = this[kAdapter];
        if (handle.queryPermission) {
          return handle.queryPermission({ mode });
        }
        if (mode === "read") {
          return "granted";
        } else if (mode === "readwrite") {
          return handle.writable ? "granted" : "denied";
        } else {
          throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
        }
      }
      async requestPermission({ mode = "read" } = {}) {
        const handle = this[kAdapter];
        if (handle.requestPermission) {
          return handle.requestPermission({ mode });
        }
        if (mode === "read") {
          return "granted";
        } else if (mode === "readwrite") {
          return handle.writable ? "granted" : "denied";
        } else {
          throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
        }
      }
      async remove(options = {}) {
        await this[kAdapter].remove(options);
      }
      async isSameEntry(other) {
        if (this === other)
          return true;
        if (!other || typeof other !== "object" || this.kind !== other.kind || !other[kAdapter])
          return false;
        return this[kAdapter].isSameEntry(other[kAdapter]);
      }
    };
    Object.defineProperty(FileSystemHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FileSystemHandle_default = FileSystemHandle;
  }
});

// node_modules/native-file-system-adapter/src/config.js
var config2, config_default;
var init_config = __esm({
  "node_modules/native-file-system-adapter/src/config.js"() {
    config2 = {
      ReadableStream: globalThis.ReadableStream,
      WritableStream: globalThis.WritableStream,
      TransformStream: globalThis.TransformStream,
      DOMException: globalThis.DOMException,
      Blob: globalThis.Blob,
      File: globalThis.File
    };
    config_default = config2;
  }
});

// node_modules/native-file-system-adapter/src/FileSystemWritableFileStream.js
var WritableStream, FileSystemWritableFileStream, FileSystemWritableFileStream_default;
var init_FileSystemWritableFileStream = __esm({
  "node_modules/native-file-system-adapter/src/FileSystemWritableFileStream.js"() {
    init_config();
    ({ WritableStream } = config_default);
    FileSystemWritableFileStream = class extends WritableStream {
      constructor(...args) {
        super(...args);
        Object.setPrototypeOf(this, FileSystemWritableFileStream.prototype);
        this._closed = false;
      }
      close() {
        this._closed = true;
        const w = this.getWriter();
        const p3 = w.close();
        w.releaseLock();
        return p3;
      }
      seek(position) {
        return this.write({ type: "seek", position });
      }
      truncate(size) {
        return this.write({ type: "truncate", size });
      }
      write(data) {
        if (this._closed) {
          return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));
        }
        const writer = this.getWriter();
        const p3 = writer.write(data);
        writer.releaseLock();
        return p3;
      }
    };
    Object.defineProperty(FileSystemWritableFileStream.prototype, Symbol.toStringTag, {
      value: "FileSystemWritableFileStream",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemWritableFileStream.prototype, {
      close: { enumerable: true },
      seek: { enumerable: true },
      truncate: { enumerable: true },
      write: { enumerable: true }
    });
    FileSystemWritableFileStream_default = FileSystemWritableFileStream;
  }
});

// node_modules/native-file-system-adapter/src/FileSystemFileHandle.js
var FileSystemFileHandle_exports = {};
__export(FileSystemFileHandle_exports, {
  FileSystemFileHandle: () => FileSystemFileHandle,
  default: () => FileSystemFileHandle_default
});
var kAdapter2, FileSystemFileHandle, FileSystemFileHandle_default;
var init_FileSystemFileHandle = __esm({
  "node_modules/native-file-system-adapter/src/FileSystemFileHandle.js"() {
    init_FileSystemHandle();
    init_FileSystemWritableFileStream();
    kAdapter2 = Symbol("adapter");
    FileSystemFileHandle = class extends FileSystemHandle_default {
      [kAdapter2];
      constructor(adapter) {
        super(adapter);
        this[kAdapter2] = adapter;
      }
      async createWritable(options = {}) {
        return new FileSystemWritableFileStream_default(
          await this[kAdapter2].createWritable(options)
        );
      }
      async getFile() {
        return this[kAdapter2].getFile();
      }
    };
    Object.defineProperty(FileSystemFileHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemFileHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemFileHandle.prototype, {
      createWritable: { enumerable: true },
      getFile: { enumerable: true }
    });
    FileSystemFileHandle_default = FileSystemFileHandle;
  }
});

// node_modules/native-file-system-adapter/src/FileSystemDirectoryHandle.js
var FileSystemDirectoryHandle_exports = {};
__export(FileSystemDirectoryHandle_exports, {
  FileSystemDirectoryHandle: () => FileSystemDirectoryHandle,
  default: () => FileSystemDirectoryHandle_default
});
var kAdapter3, FileSystemDirectoryHandle, FileSystemDirectoryHandle_default;
var init_FileSystemDirectoryHandle = __esm({
  "node_modules/native-file-system-adapter/src/FileSystemDirectoryHandle.js"() {
    init_FileSystemHandle();
    kAdapter3 = Symbol("adapter");
    FileSystemDirectoryHandle = class extends FileSystemHandle_default {
      [kAdapter3];
      constructor(adapter) {
        super(adapter);
        this[kAdapter3] = adapter;
      }
      async getDirectoryHandle(name, options = {}) {
        if (name === "") {
          throw new TypeError(`Name can't be an empty string.`);
        }
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.create = !!options.create;
        const handle = await this[kAdapter3].getDirectoryHandle(name, options);
        return new FileSystemDirectoryHandle(handle);
      }
      async *entries() {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        for await (const [_, entry] of this[kAdapter3].entries())
          yield [entry.name, entry.kind === "file" ? new FileSystemFileHandle2(entry) : new FileSystemDirectoryHandle(entry)];
      }
      async *getEntries() {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        console.warn("deprecated, use .entries() instead");
        for await (let entry of this[kAdapter3].entries())
          yield entry.kind === "file" ? new FileSystemFileHandle2(entry) : new FileSystemDirectoryHandle(entry);
      }
      async getFileHandle(name, options = {}) {
        const { FileSystemFileHandle: FileSystemFileHandle2 } = await Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports));
        if (name === "")
          throw new TypeError(`Name can't be an empty string.`);
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.create = !!options.create;
        const handle = await this[kAdapter3].getFileHandle(name, options);
        return new FileSystemFileHandle2(handle);
      }
      async removeEntry(name, options = {}) {
        if (name === "") {
          throw new TypeError(`Name can't be an empty string.`);
        }
        if (name === "." || name === ".." || name.includes("/")) {
          throw new TypeError(`Name contains invalid characters.`);
        }
        options.recursive = !!options.recursive;
        return this[kAdapter3].removeEntry(name, options);
      }
      async resolve(possibleDescendant) {
        if (await possibleDescendant.isSameEntry(this)) {
          return [];
        }
        const openSet = [{ handle: this, path: [] }];
        while (openSet.length) {
          let { handle: current, path } = openSet.pop();
          for await (const entry of current.values()) {
            if (await entry.isSameEntry(possibleDescendant)) {
              return [...path, entry.name];
            }
            if (entry.kind === "directory") {
              openSet.push({ handle: entry, path: [...path, entry.name] });
            }
          }
        }
        return null;
      }
      async *keys() {
        for await (const [name] of this[kAdapter3].entries())
          yield name;
      }
      async *values() {
        for await (const [_, entry] of this)
          yield entry;
      }
      [Symbol.asyncIterator]() {
        return this.entries();
      }
    };
    Object.defineProperty(FileSystemDirectoryHandle.prototype, Symbol.toStringTag, {
      value: "FileSystemDirectoryHandle",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(FileSystemDirectoryHandle.prototype, {
      getDirectoryHandle: { enumerable: true },
      entries: { enumerable: true },
      getFileHandle: { enumerable: true },
      removeEntry: { enumerable: true }
    });
    FileSystemDirectoryHandle_default = FileSystemDirectoryHandle;
  }
});

// itty-router.js
function Router({ routes = [] } = {}) {
  return {
    __proto__: new Proxy({}, {
      get: (target, prop, receiver) => (matcher, ...handlers) => {
        if (typeof matcher !== "function") {
          const pattern = typeof matcher === "object" || matcher?.startsWith("http") ? new URLPattern(matcher) : new URLPattern({ pathname: matcher });
          matcher = (o) => o.match = pattern.exec(o.url);
        }
        return routes.push([
          prop.toUpperCase(),
          matcher,
          handlers
        ]) && receiver;
      }
    }),
    routes,
    async handle(event, ctx = {}) {
      let response;
      ctx.url = new URL(event.request.url);
      ctx.event = event;
      ctx.request = event.request;
      ctx.match = void 0;
      ctx.response = {
        status: 200,
        headers: new Headers(),
        body: null
      };
      ctx.metadata = {};
      for (let [method, matcher, handlers] of routes) {
        const matchMethod = method === "ALL" || method === ctx.request.method;
        if (matchMethod && matcher(ctx)) {
          for (let handler of handlers) {
            if ((response = await handler(ctx)) !== void 0)
              return response;
          }
        }
      }
    }
  };
}

// extern.js
var extern_default = globalThis;

// clientmyadmin/shared/kv.js
var p;
var query = (method, ...args) => (p ??= new Promise((rs) => {
  const open = indexedDB.open("clientmyadmin-kv");
  open.onupgradeneeded = () => open.result.createObjectStore("kv");
  open.onsuccess = () => {
    const db = open.result;
    query = (method2, ...args2) => {
      const q = db.transaction("kv", "readwrite").objectStore("kv")[method2](...args2);
      return new Promise((rs2, rj) => {
        q.onsuccess = () => rs2(q.result);
        q.onerror = () => rj(q.error);
      });
    };
    rs();
  };
})).then(() => query(method, ...args));
var kv_default = (...args) => query(...args);

// clientmyadmin/shared/fs.js
async function findHandle(root2, path) {
  if (path.length === 0) {
    return root2;
  }
  const name = path.shift();
  if (root2.kind === "directory") {
    const handle = await root2.getDirectoryHandle(name).catch((err) => {
      if (err.name === "TypeMismatchError") {
        return root2.getFileHandle(name);
      } else {
        throw err;
      }
    });
    return findHandle(handle, path);
  }
  throw new Error(`'${root2.name}' is a file, not a directory, cannot search for '${root2.name}/${name}'`);
}
async function mkdirp(dirHandle, paths) {
  for (const path of paths) {
    dirHandle = await dirHandle.getDirectoryHandle(path, { create: true });
  }
  return dirHandle;
}
async function touch(dirHandle, paths) {
  const file = paths.pop();
  if (!file)
    throw new Error("touch: no file name provided");
  dirHandle = await mkdirp(dirHandle, paths);
  return dirHandle.getFileHandle(file, { create: true });
}
async function* walkHandleRecursive(source) {
  yield source;
  console.log(source.kind);
  if (source.kind === "directory") {
    for await (const [name, child] of source) {
      yield* walkHandleRecursive(child);
    }
  }
}
async function emptyDir(source) {
  for await (const [name, handle] of source) {
    await handle.remove({ recursive: true });
  }
  return source;
}
async function cp(source, dest, newName) {
  if (source.kind === "file") {
    const file = await source.getFile();
    const fileHandle = await dest.getFileHandle(newName, { create: true });
    const writer = await fileHandle.createWritable();
    await writer.write(file);
    await writer.close();
  } else {
    const dirHandle = await dest.getDirectoryHandle(newName, { create: true });
    for await (const [name, child] of source) {
      await cp(child, dirHandle, name);
    }
  }
}
var fs_default = {
  mkdirp,
  touch,
  cp,
  walkHandleRecursive,
  emptyDir,
  open(root2, path) {
    return findHandle(root2, path.split("/").filter(Boolean));
  }
};

// clientmyadmin/mime/standard.json
var standard_default = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };

// clientmyadmin/mime/mod.js
var Mime = class {
  #types = /* @__PURE__ */ Object.create(null);
  #extensions = /* @__PURE__ */ Object.create(null);
  constructor(...args) {
    for (let i = 0; i < args.length; i++) {
      this.define(args[i]);
    }
  }
  define(typeMap, force) {
    for (let type in typeMap) {
      const extensions = typeMap[type].map((t2) => t2.toLowerCase());
      type = type.toLowerCase();
      for (let i = 0; i < extensions.length; i++) {
        const ext = extensions[i];
        if (ext[0] === "*")
          continue;
        if (!force && ext in this.#types) {
          throw new Error(
            'Attempt to change mapping for "' + ext + '" extension from "' + this.#types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
          );
        }
        this.#types[ext] = type;
      }
      if (force || !this.#extensions[type]) {
        const ext = extensions[0];
        this.#extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
      }
    }
  }
  getType(path) {
    const last = path.replace(/^.*[/\\]/, "").toLowerCase();
    const ext = last.replace(/^.*\./, "").toLowerCase();
    const hasPath = last.length < path.length;
    const hasDot = ext.length < last.length - 1;
    return (hasDot || !hasPath) && this.#types[ext];
  }
  getExtension(type) {
    type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
    return type && this.#extensions[type.toLowerCase()];
  }
};
var mod_default = new Mime(standard_default);

// clientmyadmin/shared/zip64/read.js
var ERR_BAD_FORMAT = "File format is not recognized.";
var ZIP_COMMENT_MAX = 65536;
var EOCDR_MIN = 22;
var EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;
var MAX_VALUE_32BITS = 4294967295;
var decoder = new TextDecoder();
var uint16e = (b, n) => b[n] | b[n + 1] << 8;
var GZIP_HEADER = Uint8Array.from([
  31,
  139,
  8,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function getRawChunk(file, entry) {
  return file.slice(entry.offset + 26, entry.offset + 30).arrayBuffer().then((ab) => {
    const bytes = new Uint8Array(ab);
    const localFileOffset = uint16e(bytes, 0) + uint16e(bytes, 2) + 30;
    const start = entry.offset + localFileOffset;
    const end = start + entry.compressedSize;
    return file.slice(start, end);
  });
}
var Entry = class {
  #dataView;
  #fileLike;
  #extraFields = {};
  #name;
  type = "";
  constructor(dataView, fileLike) {
    if (dataView.getUint32(0) !== 1347092738) {
      throw new Error("ERR_BAD_FORMAT");
    }
    const dv = dataView;
    this.#dataView = dv;
    this.#fileLike = fileLike;
    for (let i = 46 + this.filenameLength; i < dv.byteLength; ) {
      const id = dv.getUint16(i, true);
      const len = dv.getUint16(i + 2, true);
      const start = dv.byteOffset + i + 4;
      this.#extraFields[id] = new DataView(dv.buffer.slice(start, start + len));
      i += len + 4;
    }
  }
  get versionMadeBy() {
    return this.#dataView.getUint16(4, true);
  }
  get versionNeeded() {
    return this.#dataView.getUint16(6, true);
  }
  get bitFlag() {
    return this.#dataView.getUint16(8, true);
  }
  get encrypted() {
    return (this.bitFlag & 1) === 1;
  }
  get compressionMethod() {
    return this.#dataView.getUint16(10, true);
  }
  get crc32() {
    return this.#dataView.getUint32(16, true);
  }
  get compressedSize() {
    return this.#dataView.getUint32(20, true);
  }
  get filenameLength() {
    return this.#dataView.getUint16(28, true);
  }
  get extraFieldLength() {
    return this.#dataView.getUint16(30, true);
  }
  get commentLength() {
    return this.#dataView.getUint16(32, true);
  }
  get diskNumberStart() {
    return this.#dataView.getUint16(34, true);
  }
  get internalFileAttributes() {
    return this.#dataView.getUint16(36, true);
  }
  get externalFileAttributes() {
    return this.#dataView.getUint32(38, true);
  }
  get directory() {
    return !!(this.#dataView.getUint8(38) & 16) || this.size === 0 && this.name.endsWith("/");
  }
  get offset() {
    return this.#dataView.getUint32(42, true);
  }
  get zip64() {
    return this.#dataView.getUint32(24, true) === MAX_VALUE_32BITS;
  }
  get comment() {
    const dv = this.#dataView;
    const uint8 = new Uint8Array(
      dv.buffer,
      dv.byteOffset + this.filenameLength + this.extraFieldLength + 46,
      this.commentLength
    );
    return decoder.decode(uint8);
  }
  get lastModified() {
    const t2 = this.#dataView.getUint32(12, true);
    return new Date(
      (t2 >> 25 & 127) + 1980,
      (t2 >> 21 & 15) - 1,
      t2 >> 16 & 31,
      t2 >> 11 & 31,
      t2 >> 5 & 63,
      (t2 & 31) << 1
    ).getTime();
  }
  set lastModified(v) {
    if (typeof v !== "number")
      throw new TypeError("lastModified must be a number");
    const date = new Date(v);
    const val = date.getFullYear() - 1980 << 25 | date.getMonth() + 1 << 21 | date.getDate() << 16 | date.getHours() << 11 | date.getMinutes() << 5 | date.getSeconds() >> 1;
    this.#dataView.setUint32(12, val, true);
  }
  get name() {
    if (this.#name !== void 0)
      return this.#name;
    if (!this.bitFlag && this.#extraFields[28789]) {
      return this.#name = decoder.decode(this.#extraFields[28789].buffer.slice(5));
    }
    const dv = this.#dataView;
    const uint8 = new Uint8Array(
      dv.buffer,
      dv.byteOffset + 46,
      this.filenameLength
    );
    return this.#name = decoder.decode(uint8);
  }
  set name(v) {
    if (typeof v !== "string")
      throw new TypeError("name must be a string");
    this.#name = v;
  }
  get size() {
    const size = this.#dataView.getUint32(24, true);
    return size === MAX_VALUE_32BITS ? this.#extraFields[1].getUint8(0) : size;
  }
  set size(size) {
    if (size > MAX_VALUE_32BITS) {
      this.#extraFields[1] = new DataView(new ArrayBuffer(1));
      this.#extraFields[1].setUint8(0, size);
    } else {
    }
  }
  rawBytes() {
    return getRawChunk(this.#fileLike, this);
  }
  stream() {
    const ts = new TransformStream();
    const crc = this.crc32;
    const uncompressedSize = this.size;
    this.rawBytes().then((chunk) => {
      chunk.stream().pipeTo(ts.writable);
    });
    return this.compressionMethod ? ts.readable.pipeThrough(new TransformStream({
      start(controller) {
        controller.enqueue(GZIP_HEADER);
      },
      flush(controller) {
        const tmp = new DataView(new ArrayBuffer(8));
        tmp.setUint32(0, crc, true);
        tmp.setUint32(4, uncompressedSize, true);
        controller.enqueue(new Uint8Array(tmp.buffer));
      }
    })).pipeThrough(new DecompressionStream("gzip")) : ts.readable;
  }
  async arrayBuffer() {
    if (!this.compressionMethod) {
      return getRawChunk(this.#fileLike, this).then((c) => c.arrayBuffer());
    }
    return new Response(this.stream()).arrayBuffer().catch((e) => {
      throw new Error(`Failed to read Entry
${e}`);
    });
  }
  async text() {
    if (!this.compressionMethod) {
      return getRawChunk(this.#fileLike, this).then((c) => c.text());
    }
    return new Response(this.stream()).text().catch((e) => {
      throw new Error(`Failed to read Entry
${e}`);
    });
  }
  async file() {
    const reader = this.compressionMethod ? this.arrayBuffer() : getRawChunk(this.#fileLike, this);
    return reader.then((chunk) => new File([chunk], this.name, { lastModified: this.lastModified })).catch((err) => {
      throw new Error(`Failed to read Entry
${err}`);
    });
  }
};
async function* Reader(file) {
  if (file.size < EOCDR_MIN)
    throw new Error(ERR_BAD_FORMAT);
  async function doSeek(length) {
    const ab = await file.slice(file.size - length).arrayBuffer();
    const bytes2 = new Uint8Array(ab);
    for (let i = bytes2.length - EOCDR_MIN; i >= 0; i--) {
      if (bytes2[i] === 80 && bytes2[i + 1] === 75 && bytes2[i + 2] === 5 && bytes2[i + 3] === 6) {
        return new DataView(bytes2.buffer, i, EOCDR_MIN);
      }
    }
    return null;
  }
  let dv = await doSeek(EOCDR_MIN) || await doSeek(Math.min(EOCDR_MAX, file.size));
  if (!dv)
    throw new Error(ERR_BAD_FORMAT);
  let fileslength = dv.getUint16(8, true);
  let centralDirSize = dv.getUint32(12, true);
  let centralDirOffset = dv.getUint32(16, true);
  const isZip64 = centralDirOffset === MAX_VALUE_32BITS;
  if (isZip64) {
    const l = -dv.byteLength - 20;
    dv = new DataView(await file.slice(l, -dv.byteLength).arrayBuffer());
    const signature = dv.getUint32(0, true);
    const diskWithZip64CentralDirStart = dv.getUint32(4, true);
    const relativeOffsetEndOfZip64CentralDir = Number(
      dv.getBigInt64(8, true)
    );
    const numberOfDisks = dv.getUint32(16, true);
    const zip64centralBlob = file.slice(relativeOffsetEndOfZip64CentralDir, l);
    dv = new DataView(await zip64centralBlob.arrayBuffer());
    fileslength = Number(dv.getBigInt64(32, true));
    centralDirSize = Number(dv.getBigInt64(40, true));
    centralDirOffset = Number(dv.getBigInt64(48, true));
  }
  if (centralDirOffset < 0 || centralDirOffset >= file.size) {
    throw new Error(ERR_BAD_FORMAT);
  }
  const start = centralDirOffset;
  const end = centralDirOffset + centralDirSize;
  const blob = file.slice(start, end);
  const bytes = new Uint8Array(await blob.arrayBuffer());
  for (let i = 0, index = 0; i < fileslength; i++) {
    const size = uint16e(bytes, index + 28) + uint16e(bytes, index + 30) + uint16e(bytes, index + 32) + 46;
    if (index + size > bytes.length) {
      throw new Error("Invalid ZIP file.");
    }
    yield new Entry(new DataView(bytes.buffer, index, size), file);
    index += size;
  }
}
var read_default = Reader;

// node_modules/native-file-system-adapter/src/getOriginPrivateDirectory.js
if (globalThis.DataTransferItem && !DataTransferItem.prototype.getAsFileSystemHandle) {
  DataTransferItem.prototype.getAsFileSystemHandle = async function() {
    const entry = this.webkitGetAsEntry();
    const [
      { FileHandle: FileHandle3, FolderHandle: FolderHandle3 },
      { FileSystemDirectoryHandle: FileSystemDirectoryHandle2 },
      { FileSystemFileHandle: FileSystemFileHandle2 }
    ] = await Promise.all([
      Promise.resolve().then(() => (init_sandbox(), sandbox_exports)),
      Promise.resolve().then(() => (init_FileSystemDirectoryHandle(), FileSystemDirectoryHandle_exports)),
      Promise.resolve().then(() => (init_FileSystemFileHandle(), FileSystemFileHandle_exports))
    ]);
    return entry.isFile ? new FileSystemFileHandle2(new FileHandle3(entry, false)) : new FileSystemDirectoryHandle2(new FolderHandle3(entry, false));
  };
}
async function getOriginPrivateDirectory(driver, options = {}) {
  if (!driver) {
    return globalThis.navigator?.storage?.getDirectory() || globalThis.getOriginPrivateDirectory();
  }
  const { FileSystemDirectoryHandle: FileSystemDirectoryHandle2 } = await Promise.resolve().then(() => (init_FileSystemDirectoryHandle(), FileSystemDirectoryHandle_exports));
  const module = await driver;
  const sandbox = await (module.default ? module.default(options) : module(options));
  return new FileSystemDirectoryHandle2(sandbox);
}
var getOriginPrivateDirectory_default = getOriginPrivateDirectory;

// node_modules/native-file-system-adapter/src/adapters/jsdelivr.js
init_util();
var { GONE, MISMATCH, SYNTAX, DISALLOWED: DISALLOWED2 } = errors;
var FileHandle2 = class {
  constructor(entry, root2) {
    this.name = entry.name;
    this.kind = "file";
    this._deleted = false;
    this._root = root2;
    this._entry = entry;
    this.writable = false;
    this.readable = true;
  }
  async getFile() {
    const res = await fetch(`https://cdn.jsdelivr.net/${this._root}/${this.name}`);
    const blob = await res.blob();
    return new File([blob], this.name, {
      type: blob.type,
      lastModified: this._entry.time
    });
  }
  async createWritable() {
    throw new DOMException(...DISALLOWED2);
  }
  async isSameEntry(other) {
    return this === other;
  }
};
function toDic(files, root2) {
  const dic = {};
  for (const x of files) {
    x.time = +new Date(x.time);
    if (x.type === "file") {
      dic[x.name] = new FileHandle2(x, root2);
    } else {
      dic[x.name] = new FolderHandle2(x.files, `${root2}/${x.name}`, x.name);
    }
  }
  return dic;
}
var FolderHandle2 = class {
  constructor(files, root2, name = "") {
    this.name = name;
    this.kind = "directory";
    this._deleted = false;
    this._entries = toDic(files, root2);
    this.writable = false;
    this.readable = true;
  }
  async *entries() {
    yield* Object.entries(this._entries);
  }
  async isSameEntry(other) {
    return this === other;
  }
  async getDirectoryHandle(name, opts) {
    if (this._deleted)
      throw new DOMException(...GONE);
    const entry = this._entries[name];
    if (entry) {
      if (entry instanceof FileHandle2) {
        throw new DOMException(...MISMATCH);
      } else {
        return entry;
      }
    } else {
      if (opts.create) {
        throw new DOMException(...DISALLOWED2);
      } else {
        throw new DOMException(...GONE);
      }
    }
  }
  async getFileHandle(name, opts) {
    const entry = this._entries[name];
    const isFile = entry instanceof FileHandle2;
    if (entry && isFile)
      return entry;
    if (entry && !isFile)
      throw new DOMException(...MISMATCH);
    if (!entry && !opts.create)
      throw new DOMException(...GONE);
    if (!entry && opts.create) {
      throw new DOMException(...DISALLOWED2);
    }
  }
  async removeEntry(name, opts) {
    throw new DOMException(...DISALLOWED2);
  }
};
var jsdelivr_default = async (root2) => {
  const res = await fetch(`https://data.jsdelivr.com/v1/package/${root2}`);
  const { files } = await res.json();
  return new FolderHandle2(files, root2);
};

// shimport.js
function get_alias(specifiers, name) {
  var i = specifiers.length;
  while (i--) {
    if (specifiers[i].name === name) {
      return specifiers[i].as;
    }
  }
}
function importDecl(str, start, end, specifiers, source) {
  var name = get_alias(specifiers, "*") || get_alias(specifiers, "default");
  return {
    start,
    end,
    source,
    name,
    specifiers,
    toString() {
      return "/*" + str.slice(start, end) + "*/";
    }
  };
}
function exportDefaultDeclaration(str, start, end) {
  var match = /^\s*(?:(class)(\s+extends|\s*{)|(function)\s*\()/.exec(str.slice(end));
  if (match) {
    end += match[0].length;
    var name = "__default_export";
    return {
      start,
      end,
      name,
      as: "default",
      toString() {
        return match[1] ? "class " + name + match[2] : "function " + name + "(";
      }
    };
  }
  return {
    start,
    end,
    toString() {
      return "__exports.default =";
    }
  };
}
function exportSpecifiersDeclaration(str, start, specifiersStart, specifiersEnd, end, source) {
  var specifiers = processSpecifiers(str.slice(specifiersStart + 1, specifiersEnd - 1).trim());
  return {
    start,
    end,
    source,
    toString(nameBySource) {
      var name = source && nameBySource.get(source);
      return specifiers.map(function(s) {
        return "__exports." + s.as + " = " + (name ? name + "." + s.name : s.name) + "; ";
      }).join("") + "/*" + str.slice(start, end) + "*/";
    }
  };
}
function exportDecl(str, start, c) {
  var end = c;
  while (str[c] && /\S/.test(str[c])) {
    c += 1;
  }
  while (str[c] && !/\S/.test(str[c])) {
    c += 1;
  }
  var nameStart = c;
  while (str[c] && !punctuatorChars.test(str[c]) && !isWhitespace(str[c])) {
    c += 1;
  }
  var nameEnd = c;
  var name = str.slice(nameStart, nameEnd);
  if (name === "function") {
    while (str[c] && /\S/.test(str[c])) {
      c += 1;
    }
    while (str[c] && !/\S/.test(str[c])) {
      c += 1;
    }
    nameStart = c;
    while (str[c] && !punctuatorChars.test(str[c]) && !isWhitespace(str[c])) {
      c += 1;
    }
    nameEnd = c;
    name = str.slice(nameStart, nameEnd);
  }
  return {
    start,
    end,
    name,
    toString() {
      return "";
    }
  };
}
function exportStarDeclaration(str, start, end, source) {
  return {
    start,
    end,
    source,
    toString(nameBySource) {
      return "Object.assign(__exports, " + nameBySource.get(source) + "); /*" + str.slice(start, end) + "*/";
    }
  };
}
var keywords = /\b(case|default|delete|do|else|in|instanceof|new|return|throw|typeof|void)\s*$/;
var punctuators = /(^|\{|\(|\[\.|;|,|<|>|<=|>=|==|!=|===|!==|\+|-|\*\%|<<|>>|>>>|&|\||\^|!|~|&&|\|\||\?|:|=|\+=|-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|\/=|\/)\s*$/;
var ambiguous = /(\}|\)|\+\+|--)\s*$/;
var punctuatorChars = /[{}()[.;,<>=+\-*%&|\^!~?:/]/;
var keywordChars = /[a-zA-Z_$0-9]/;
var whitespace_obj = { " ": 1, "	": 1, "\n": 1, "\r": 1, "\f": 1, "\v": 1, "\xA0": 1, "\u2028": 1, "\u2029": 1 };
function isWhitespace(char) {
  return char in whitespace_obj;
}
function isQuote(char) {
  return char === "'" || char === '"';
}
var namespaceImport = /^\*\s+as\s+(\w+)$/;
var defaultAndStarImport = /(\w+)\s*,\s*\*\s*as\s*(\w+)$/;
var defaultAndNamedImport = /(\w+)\s*,\s*{(.+)}$/;
function processImportSpecifiers(str) {
  var match = namespaceImport.exec(str);
  if (match) {
    return [{ name: "*", as: match[1] }];
  }
  match = defaultAndStarImport.exec(str);
  if (match) {
    return [{ name: "default", as: match[1] }, { name: "*", as: match[2] }];
  }
  match = defaultAndNamedImport.exec(str);
  if (match) {
    return [{ name: "default", as: match[1] }].concat(processSpecifiers(match[2].trim()));
  }
  if (str[0] === "{") {
    return processSpecifiers(str.slice(1, -1).trim());
  }
  if (str) {
    return [{ name: "default", as: str }];
  }
  return [];
}
function processSpecifiers(str) {
  return str ? str.split(",").map(function(part) {
    var ref = part.trim().split(/[^\S]+/);
    var name = ref[0];
    var as = ref[2];
    return { name, as: as || name };
  }) : [];
}
function getImportDeclaration(str, i) {
  var start = i;
  var specifierStart = i += 6;
  while (str[i] && isWhitespace(str[i])) {
    i += 1;
  }
  while (str[i] && !isQuote(str[i])) {
    i += 1;
  }
  var specifierEnd = i;
  var sourceStart = i += 1;
  while (str[i] && !isQuote(str[i])) {
    i += 1;
  }
  var sourceEnd = i++;
  return importDecl(
    str,
    start,
    i,
    processImportSpecifiers(str.slice(specifierStart, specifierEnd).replace(/from\s*$/, "").trim()),
    str.slice(sourceStart, sourceEnd)
  );
}
function getImportStatement(i) {
  return {
    start: i,
    end: i + 6,
    toString() {
      return "__import";
    }
  };
}
var importMetaUrlPattern = /^import\s*\.\s*meta\s*\.\s*url/;
function getImportMetaUrl(str, start, id) {
  var match = importMetaUrlPattern.exec(str.slice(start));
  if (match) {
    return {
      start,
      end: start + match[0].length,
      toString() {
        return JSON.stringify("" + id);
      }
    };
  }
}
function getExportDeclaration(str, i) {
  var start = i;
  i += 6;
  while (str[i] && isWhitespace(str[i])) {
    i += 1;
  }
  var declarationStart = i;
  if (str[i] === "{") {
    while (str[i] !== "}") {
      i += 1;
    }
    i += 1;
    var specifiersEnd = i;
    var source = null;
    while (isWhitespace(str[i])) {
      i += 1;
    }
    if (/^from[\s\n'"]/.test(str.slice(i, i + 5))) {
      i += 4;
      while (isWhitespace(str[i])) {
        i += 1;
      }
      while (str[i] && !isQuote(str[i])) {
        i += 1;
      }
      var sourceStart = i += 1;
      while (str[i] && !isQuote(str[i])) {
        i += 1;
      }
      source = str.slice(sourceStart, i);
      i += 1;
    }
    return exportSpecifiersDeclaration(
      str,
      start,
      declarationStart,
      specifiersEnd,
      i,
      source
    );
  }
  if (str[i] === "*") {
    i += 1;
    while (isWhitespace(str[i])) {
      i += 1;
    }
    i += 4;
    while (str[i] && !isQuote(str[i])) {
      i += 1;
    }
    var sourceStart$1 = i += 1;
    while (str[i] && !isQuote(str[i])) {
      i += 1;
    }
    var sourceEnd = i++;
    return exportStarDeclaration(
      str,
      start,
      i,
      str.slice(sourceStart$1, sourceEnd)
    );
  }
  if (/^default\b/.test(str.slice(i, i + 8))) {
    return exportDefaultDeclaration(
      str,
      start,
      declarationStart + 7
    );
  }
  return exportDecl(
    str,
    start,
    declarationStart
  );
}
function find(str, id) {
  var escapedFrom;
  var regexEnabled = true;
  var pfixOp = false;
  var stack = [];
  var lsci = -1;
  var lsc = function() {
    return str[lsci];
  };
  var parenMatches = {};
  var openingParenPositions = {};
  var parenDepth = 0;
  var importDeclarations = [];
  var importStatements = [];
  var importMetaUrls = [];
  var exportDeclarations = [];
  function tokenClosesExpression() {
    if (lsc() === ")") {
      var c = parenMatches[lsci];
      while (isWhitespace(str[c - 1])) {
        c -= 1;
      }
      return !/(if|while)$/.test(str.slice(c - 5, c));
    }
    return true;
  }
  var base2 = {
    pattern: /(?:(\()|(\))|({)|(})|(")|(')|(\/\/)|(\/\*)|(\/)|(`)|(import)|(export)|(\+\+|--))/g,
    handlers: [
      function(i) {
        lsci = i;
        openingParenPositions[parenDepth++] = i;
      },
      function(i) {
        lsci = i;
        parenMatches[i] = openingParenPositions[--parenDepth];
      },
      function(i) {
        lsci = i;
        stack.push(base2);
      },
      function(i) {
        lsci = i;
        return stack.pop();
      },
      function(i) {
        stack.push(base2);
        return double_quoted;
      },
      function(i) {
        stack.push(base2);
        return single_quoted;
      },
      function(i) {
        return line_comment;
      },
      function(i) {
        return block_comment;
      },
      function(i) {
        var b = i;
        while (b > 0 && isWhitespace(str[b - 1])) {
          b -= 1;
        }
        if (b > 0) {
          var a = b;
          if (punctuatorChars.test(str[a - 1])) {
            while (a > 0 && punctuatorChars.test(str[a - 1])) {
              a -= 1;
            }
          } else {
            while (a > 0 && keywordChars.test(str[a - 1])) {
              a -= 1;
            }
          }
          var token = str.slice(a, b);
          regexEnabled = token ? keywords.test(token) || punctuators.test(token) || ambiguous.test(token) && !tokenClosesExpression() : false;
        } else {
          regexEnabled = true;
        }
        return slash;
      },
      function(i) {
        return template_string;
      },
      function(i) {
        if (i === 0 || isWhitespace(str[i - 1]) || punctuatorChars.test(str[i - 1])) {
          var j2 = i + 6;
          var char;
          do {
            char = str[j2++];
          } while (isWhitespace(char));
          var hasWhitespace = j2 > i + 7;
          if (/^['"{*]$/.test(char) || hasWhitespace && /^[a-zA-Z_$]$/.test(char)) {
            var d = getImportDeclaration(str, i);
            importDeclarations.push(d);
            p3 = d.end;
          } else if (char === "(") {
            var s = getImportStatement(i);
            importStatements.push(s);
            p3 = s.end;
          } else if (char === ".") {
            var u = getImportMetaUrl(str, i, id);
            if (u) {
              importMetaUrls.push(u);
              p3 = u.end;
            }
          }
        }
      },
      function(i) {
        if (i === 0 || isWhitespace(str[i - 1]) || punctuatorChars.test(str[i - 1])) {
          if (/export[\s\n{]/.test(str.slice(i, i + 7))) {
            var d = getExportDeclaration(str, i);
            exportDeclarations.push(d);
            p3 = d.end;
          }
        }
      },
      function(i) {
        pfixOp = !pfixOp && str[i - 1] === "+";
      }
    ]
  };
  var slash = {
    pattern: /(?:(\[)|(\\)|(.))/g,
    handlers: [
      function(i) {
        return regexEnabled ? regex_character : base2;
      },
      function(i) {
        return escapedFrom = regex, escaped;
      },
      function(i) {
        return regexEnabled && !pfixOp ? regex : base2;
      }
    ]
  };
  var regex = {
    pattern: /(?:(\[)|(\\)|(\/))/g,
    handlers: [
      function() {
        return regex_character;
      },
      function() {
        return escapedFrom = regex, escaped;
      },
      function() {
        return base2;
      }
    ]
  };
  var regex_character = {
    pattern: /(?:(\])|(\\))/g,
    handlers: [
      function() {
        return regex;
      },
      function() {
        return escapedFrom = regex_character, escaped;
      }
    ]
  };
  var double_quoted = {
    pattern: /(?:(\\)|("))/g,
    handlers: [
      function() {
        return escapedFrom = double_quoted, escaped;
      },
      function() {
        return stack.pop();
      }
    ]
  };
  var single_quoted = {
    pattern: /(?:(\\)|('))/g,
    handlers: [
      function() {
        return escapedFrom = single_quoted, escaped;
      },
      function() {
        return stack.pop();
      }
    ]
  };
  var escaped = {
    pattern: /(.)/g,
    handlers: [
      function() {
        return escapedFrom;
      }
    ]
  };
  var template_string = {
    pattern: /(?:(\${)|(\\)|(`))/g,
    handlers: [
      function() {
        stack.push(template_string);
        return base2;
      },
      function() {
        return escapedFrom = template_string, escaped;
      },
      function() {
        return base2;
      }
    ]
  };
  var line_comment = {
    pattern: /((?:\n|$))/g,
    handlers: [
      function() {
        return base2;
      }
    ]
  };
  var block_comment = {
    pattern: /(\*\/)/g,
    handlers: [
      function() {
        return base2;
      }
    ]
  };
  var state = base2;
  var p3 = 0;
  while (p3 < str.length) {
    state.pattern.lastIndex = p3;
    var match = state.pattern.exec(str);
    if (!match) {
      if (stack.length > 0 || state !== base2) {
        throw new Error("Unexpected end of file");
      }
      break;
    }
    p3 = match.index + match[0].length;
    for (var j = 1; j < match.length; j += 1) {
      if (match[j]) {
        state = state.handlers[j - 1](match.index) || state;
        break;
      }
    }
  }
  return [
    importDeclarations,
    importStatements,
    importMetaUrls,
    exportDeclarations
  ];
}
function transform(source, id) {
  var ref = find(source, id);
  var importDeclarations = ref[0];
  var importStatements = ref[1];
  var importMetaUrls = ref[2];
  var exportDeclarations = ref[3];
  var nameBySource = /* @__PURE__ */ new Map();
  importDeclarations.forEach(function(d) {
    if (nameBySource.has(d.source)) {
      return;
    }
    nameBySource.set(d.source, d.name || "__dep_" + nameBySource.size);
  });
  exportDeclarations.forEach(function(d) {
    if (!d.source) {
      return;
    }
    if (nameBySource.has(d.source)) {
      return;
    }
    nameBySource.set(d.source, d.name || "__dep_" + nameBySource.size);
  });
  var deps = Array.from(nameBySource.keys()).map(function(s) {
    return "'" + s + "'";
  }).join(", ");
  var names = ["__import", "__exports"].concat(Array.from(nameBySource.values())).join(", ");
  var hoisted = [];
  importDeclarations.forEach(function(decl) {
    var name = nameBySource.get(decl.source);
    decl.specifiers.sort(function(a, b) {
      if (a.name === "default") {
        return 1;
      }
      if (b.name === "default") {
        return -1;
      }
    }).forEach(function(s) {
      if (s.name !== "*") {
        var assignment = s.name === "default" && s.as === name ? s.as + " = " + name + ".default; " : "var " + s.as + " = " + name + "." + s.name + "; ";
        hoisted.push(assignment);
      }
    });
  });
  var transformed = "__shimport__.define('" + id + "', [" + deps + "], function(" + names + "){ " + hoisted.join("");
  var ranges = importDeclarations.concat(
    importStatements,
    importMetaUrls,
    exportDeclarations
  ).sort(function(a, b) {
    return a.start - b.start;
  });
  var c = 0;
  for (var i = 0; i < ranges.length; i += 1) {
    var range = ranges[i];
    transformed += source.slice(c, range.start) + range.toString(nameBySource);
    c = range.end;
  }
  transformed += source.slice(c);
  exportDeclarations.forEach(function(d) {
    if (d.name) {
      transformed += "\n__exports." + (d.as || d.name) + " = " + d.name + ";";
    }
  });
  transformed += "\n});\n//# sourceURL=" + id;
  return transformed;
}
var promises = {};
function define(id, deps, factory) {
  var __import = function(dep) {
    return load(new URL(dep, id).toString());
  };
  return Promise.all(deps.map(__import)).then(function(__deps) {
    var __exports = {};
    factory.apply(void 0, [__import, __exports].concat(__deps));
    return __exports;
  });
}
async function load(url) {
  return promises[url] ??= fetch(url).then((r) => {
    if (!r.ok)
      throw new Error(url + " returned non ok response");
    return r.text();
  }).then((text) => evaluate(transform(text, url)));
}
function evaluate(code) {
  return (0, eval)(code);
}
globalThis.__shimport__ = {
  define,
  load,
  transform
};

// sw-container.js
var { hasOwn } = Object;
var base = location.origin.includes("localhost") ? "http://localhost:4445" : "https://localwebcontainer.com";
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
async function cacheFirst(req) {
  const cache = await caches.open("v1");
  const cached = await cache.match(req);
  if (cached)
    return cached;
  const res = await fetch(req);
  await cache.put(req, res.clone());
  return res;
}
extern_default.addEventListener("install", () => {
  caches.open("v1").then(
    (cache) => cache.addAll([
      "https://sindresorhus.com/github-markdown-css/github-markdown.css",
      base + "/clientmyadmin/index.html",
      base + "/clientmyadmin/json.html",
      base + "/clientmyadmin/style.css",
      base + "/clientmyadmin/markdown.html",
      base + "/clientmyadmin/style.html",
      base + "/clientmyadmin/allowread.html",
      base + "/clientmyadmin/shared/kv.js",
      base + "/clientmyadmin/shared/fs.js"
    ])
  );
});
function isPlainObject(o) {
  var ctor, prot;
  if (isObject(o) === false)
    return false;
  ctor = o.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  return hasOwn(prot, "isPrototypeOf");
}
var origFetch = globalThis.fetch;
globalThis.fetch = async function fetch2(request) {
  if (!(request instanceof Request))
    return fetch2(new Request(...arguments));
  if (request.url.startsWith(origin)) {
    const pathname = new URL(request.url).pathname.replace(/^\/+/, "");
    const entries = /* @__PURE__ */ new Map();
    const x = await kv_default("get", "root");
    root ??= x;
    if (root?.type === "jsdelivr") {
      root = await getOriginPrivateDirectory_default(jsdelivr_default, root.root);
    }
    if (root) {
      globalThis.x = root;
      const permission = await root.queryPermission({ mode: "read" });
      if (permission === "prompt")
        return fetch2(`${base}/clientmyadmin/allowread.html`);
      let path = "";
      try {
        path = decodeURIComponent(pathname);
      } catch (e) {
        return new Response("Not Found.", {
          status: 404,
          statusText: "Not found"
        });
      }
      const handle = await fs_default.open(root, path);
      if (handle.kind === "file") {
        return handle.getFile().then(renderFile);
      } else {
        for await (const [name, entry2] of handle) {
          entries.set(`${pathname}/${name}`.replace(/^\//, ""), entry2);
        }
        return renderTreeList(entries);
      }
    }
    const zipBlob = await kv_default("get", "zip-file");
    if (!zipBlob)
      return Response.redirect("/clientmyadmin");
    for await (const entry2 of read_default(zipBlob)) {
      if (!entry2.directory)
        entries.set(entry2.name, entry2);
    }
    const entry = entries.get(pathname);
    return entry ? renderFile(entry) : renderTreeList(entries);
  }
  return caches.match(request[0]).then((res) => {
    return res || origFetch(request[0]);
  });
};
var p2;
async function init() {
  const { initialize } = await load(base + "/esbuild.min.js");
  const res = await cacheFirst(base + "/esbuild.wasm");
  await initialize({
    worker: false,
    wasmModule: await WebAssembly.compileStreaming(res)
  });
}
async function _import(url, opts) {
  await (p2 ??= init());
  const { build, httpPlugin } = await load(base + "/esbuild.min.js");
  const options = {
    entryPoints: [url],
    format: "esm",
    minify: true,
    globalName: "xyz",
    sourcemap: true,
    plugins: [httpPlugin],
    ...opts
  };
  console.groupCollapsed("esbuild building " + url);
  console.info("options", options);
  console.groupEnd();
  const result = await build(options);
  return new TextDecoder().decode(result.outputFiles[0].contents);
}
var router = Router();
var root;
router.all("*", async (ctx) => {
  ctx.headers;
});
router.get("/clientmyadmin/foo.css", async (ctx) => {
  return new Response(new Blob(["body { color: red; }"], {}));
});
router.get((o) => ["script", "worker"].includes(o.request.destination), (ctx) => {
  if (ctx.request.url.endsWith(".ts")) {
    return _import(ctx.request.url).then((str) => new Response(str, {
      headers: { "content-type": "application/javascript" }
    }));
  }
});
router.get((o) => o.url.searchParams.get("installFrom"), async (ctx) => {
  root = void 0;
  return fetch(`${base}/clientmyadmin/installfrom.html`);
});
router.get("/clientmyadmin", (ctx) => {
  return Response.redirect("/clientmyadmin/", 302);
});
router.get("/clientmyadmin/clients", async (o) => {
  const clients = await extern_default.clients.matchAll();
  const m = clients.map((client) => {
    const res = {};
    for (const key in client) {
      if (typeof client[key] !== "function") {
        res[key] = client[key];
      }
    }
    return res;
  });
  return Response.json({
    self: o.event.clientId,
    clients: m
  });
});
router.get(
  (o) => o.request.destination === "document" && o.request.url.includes("/clientmyadmin/inspector"),
  (ctx) => fetch(`${base}/clientmyadmin/inspector.html`)
);
router.get(location.origin + "/clientmyadmin/*", (ctx) => {
  ctx.request = new Request(ctx.request.url.replace(location.origin, base));
  ctx.url = new URL(ctx.request.url);
});
var singleton = {};
router.all("/functions/*", async (ctx) => {
  const url = new URL(ctx.url.pathname, location.origin);
  const path = url.toString();
  let module;
  if (url.pathname.endsWith(".ts")) {
    singleton[path] ??= _import(path, { format: "iife" }).then(load2);
    module = await singleton[path];
  } else {
    module = await load(path);
  }
  let method = ctx.request.method;
  method = method[0].toUpperCase() + method.slice(1).toLowerCase();
  const fn = module[`onRequest${method}`];
  return fn?.(ctx);
});
router.all(
  (o) => o.request.destination === "document" && o.url.pathname.toLowerCase().endsWith(".md"),
  (ctx) => fetch(`${base}/clientmyadmin/markdown.html`)
);
router.all(
  (o) => o.request.destination === "document" && o.url.pathname.toLowerCase().endsWith(".json"),
  (ctx) => fetch(`${base}/clientmyadmin/json.html`)
);
router.all({}, (ctx) => fetch(ctx.request));
function errorHandler(error) {
  console.error(error);
  return new Response(error.stack || "Server Error", {
    status: error.status || 200
  });
}
function convertToResponse(thing) {
  if (thing instanceof Response)
    return thing;
  if (typeof thing === void 0) {
    return new Response("Not Found.", { status: 404 });
  }
  if (Array.isArray(thing) || isPlainObject(thing)) {
    return Response.json(thing);
  }
  return new Response(thing);
}
extern_default.addEventListener(
  "fetch",
  (evt) => evt.respondWith(
    router.handle(evt).then(convertToResponse).catch(errorHandler)
  )
);
var t = (evt, fn) => evt.waitUntil(fn().catch(console.error));
extern_default.onactivate = (evt) => t(evt, () => extern_default.clients.claim());
extern_default.onmessage = async (evt) => {
  const { data, ports } = evt;
  if (data !== "claimMe")
    return;
  t(evt, async () => {
    await extern_default.clients.claim();
    ports[0].postMessage("claimed");
  });
};
function renderTreeList(entries) {
  const files = Array.from(entries.keys()).sort();
  const html = `<!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <meta name='viewport' content='width=device-width, initial-scale=1'>
        <link rel="stylesheet" href="/clientmyadmin/style.css">
        <style>
          body {
            margin: 20px;
            max-width: initial;
          }
        </style>
      </head>
      <body>
        <ul>
          ${files.map((file) => {
    return entries.get(file).crc32 ? `<li><a href="/${file}">${file}</a> ${entries.get(file).size.toString().padStart(6, " ")}b </li>` : `<li><a href="/${file}">${file}</a></li>`;
  }).join("")}
        </ul>
      </body>
    </html>`;
  return new Response(html, {
    headers: { "content-type": "text/html" },
    status: 404,
    statusText: "Not found"
  });
}
function load2(str) {
  const body = `${str}; 
 return xyz`;
  const mod = new Function(body)();
  const result = mod?.default || mod;
  return result;
}
async function renderFile(file) {
  const headers = {
    "content-type": mod_default.getType(file.name) || file.type,
    "content-length": file.size
  };
  return new Response(file.stream(), { headers });
}
/*! zip64. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
})()
//# sourceMappingURL=sw-container.min.js.map
